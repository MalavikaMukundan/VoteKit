{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VoteKit Documentation","text":"<p>VoteKit is a Swiss army knife for computational social choice research.</p> <p>Version: 2.0.0 Date March 1, 2024</p> <p>Helpful links: Source Repository | Documentation | Issues | MGGG.org</p> <p> </p> <p>Votekit is Python package that provides tools to simulate and analyze elections. It was designed with researchers and folks interested in exploring properties of alternative voting systems in mind. If you're new to the world of social choice or have questions on how to use Votekit, you can explore Votekit`s documentation through the links below. If you're interesting in contributing, check out the Development and Contribution section to get started.</p> <ul> <li>Getting Started: A beginner's guide to running elections with Votekit</li> <li>User Guide: How-to guides for VoteKit's key features and design elements</li> <li>API Reference: Complete documentation for all functions, methods and objects</li> <li>Social Choice Reference: The Hitchhiker's Guide to Social Choice theory</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Votekit can be installed through any standard package management tool:</p> <pre><code>pip install votekit\n</code></pre> <p>or</p> <pre><code>poetry add votekit\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>A simple example of how to use VoteKit to load, clean, and run an election using real data taken from the 2013 Minneapolis Mayoral election. For a more comprehensive walkthrough, read Getting started with VoteKit. </p> <pre><code>from votekit import load_csv, remove_noncands\nfrom votekit.elections import STV, fractional_transfer\n\nminneapolis_profile = load_csv(\"mn_2013_cast_vote_record.csv\")\n\n# clean downloaded file to remove edited aspects of the cast vote record\nminneapolis_profile = remove_noncands(minneapolis_profile, [\"undervote\", \"overvote\", \"UWI\"])\n\nminn_election = STV(profile = minneapolis_profile, transfer = fractional_transfer, seats = 1)\nminn_election.run_election()\n</code></pre> <pre><code>                   Candidate     Status  Round\n                BETSY HODGES    Elected     35\n                 MARK ANDREW Eliminated     34\n                 DON SAMUELS Eliminated     33\n                  CAM WINTON Eliminated     32\n          JACKIE CHERRYHOMES Eliminated     31\n                    BOB FINE Eliminated     30\n                   DAN COHEN Eliminated     29\n          STEPHANIE WOODRUFF Eliminated     28\n             MARK V ANDERSON Eliminated     27\n                   DOUG MANN Eliminated     26\n                  OLE SAVIOR Eliminated     25\n               JAMES EVERETT Eliminated     24\n           ALICIA K. BENNETT Eliminated     23\n  ABDUL M RAHAMAN \"THE ROCK\" Eliminated     22\n        CAPTAIN JACK SPARROW Eliminated     21\n           CHRISTOPHER CLARK Eliminated     20\n                   TONY LANE Eliminated     19\n                JAYMIE KELLY Eliminated     18\n                  MIKE GOULD Eliminated     17\n             KURTIS W. HANNA Eliminated     16\n CHRISTOPHER ROBIN ZIMMERMAN Eliminated     15\n         JEFFREY ALAN WAGNER Eliminated     14\n                 NEAL BAXTER Eliminated     13\n            TROY BENJEGERDES Eliminated     12\n            GREGG A. IVERSON Eliminated     11\n            MERRILL ANDERSON Eliminated     10\n                  JOSHUA REA Eliminated      9\n                   BILL KAHN Eliminated      8\n         JOHN LESLIE HARTWIG Eliminated      7\n      EDMUND BERNARD BRUYERE Eliminated      6\nJAMES \"JIMMY\" L. STROUD, JR. Eliminated      5\n            RAHN V. WORKCUFF Eliminated      4\n       BOB \"AGAIN\" CARNEY JR Eliminated      3\n                  CYD GORMAN Eliminated      2\n         JOHN CHARLES WILSON Eliminated      1\n</code></pre>"},{"location":"#development-and-contribution","title":"Development and Contribution","text":"<p>This project is in active development in the mggg/VoteKit GitHub repository, where bug reports and feature requests, as well as contributions, are welcome.</p> <p>VoteKit project requires <code>poetry</code>, and Python &gt;= 3.9. (This version chosen somewhat arbitrarily.)</p> <p>To get up and running, run <code>poetry install</code> from within the project directory to install all dependencies. This will create a <code>.venv</code> directory that will contain dependencies. You can interact with this virtualenv by running your commands prefixed with <code>poetry run</code>, or use <code>poetry shell</code> to activate the virtualenv.</p> <p>Once you've run <code>poetry install</code>, if you run <code>poetry run pre-commit install</code> it will install code linting hooks that will run on every commit. This helps ensure code quality.</p> <p>To run tests run <code>poetry run pytest</code> or <code>./run_tests.sh</code> (the latter will generate a coverage report).</p> <p>To release, run <code>poetry publish --build</code>.</p>"},{"location":"SCR_ballot_generators/","title":"Ballot Generators","text":"<p>In addition to being able to read real world voting data, VoteKit also has the ability to generate ballots using different models. This is useful when you want to run experiments or just play around with some data. We make no claims that these models accurately predict real voting behavior.</p>"},{"location":"SCR_ballot_generators/#ballot-simplex-models","title":"Ballot Simplex Models","text":"<p>Models listed below generate ballots by using the ballot simplex. This means we take a draw from the Dirichlet distribution, which gives us a probability distribution on full, linear rankings. We then generate ballots according to this distribution.</p>"},{"location":"SCR_ballot_generators/#impartial-culture","title":"Impartial Culture","text":"<p>The Impartial Culture model has \\(\\alpha = \\infty\\). As discussed in ballot simplex, this is not actually a valid parameter for the Dirichlet distribution, so instead VoteKit sets \\(\\alpha = 10^{20}\\). This means that the point drawn from the ballot simplex has a very high probability of being in the center, which means it gives uniform probability to each linear ranking.</p>"},{"location":"SCR_ballot_generators/#impartial-anonymous-culture","title":"Impartial Anonymous Culture","text":"<p>The Impartial Anonymous Culture model has \\(\\alpha = 1\\). This means that the point is uniformly drawn from the ballot simplex. This does not mean we have a uniform distribution on rankings; rather, we have a uniform chance of choosing any distribution on rankings.</p>"},{"location":"SCR_ballot_generators/#candidate-simplex-models","title":"Candidate Simplex Models","text":""},{"location":"SCR_ballot_generators/#name-plackett-luce","title":"Name-Plackett-Luce","text":"<p>The name-Plackett-Luce model (n-PL) samples ranked ballots as follows. Assume there are \\(n\\) blocs of voters. Within a bloc, say bloc \\(A\\), voters have \\(n\\) preference intervals, one for each slate of candidates. A bloc also has a fixed \\(n\\)-tuple of cohesion parameters \\(\\pi_A = (\\pi_{AA}, \\pi_{AB},\\dots)\\); we require that \\(\\sum_B \\pi_{AB}=1\\). To generate a ballot for a voter in bloc \\(A\\), each preference interval \\(I_B\\) is rescaled by the corresponding cohesion parameter \\(\\pi_{AB}\\), and then concatenated to create one preference interval.  Voters then sample without replacement from the combined preference interval.</p>"},{"location":"SCR_ballot_generators/#name-bradley-terry","title":"Name-Bradley-Terry","text":"<p>The name-Bradley-Terry model (n-BT) samples ranked ballots as follows. Assume there are \\(n\\) blocs of voters. Within a bloc, say bloc \\(A\\), voters have \\(n\\) preference intervals, one for each slate of candidates. A bloc also has a fixed \\(n\\)-tuple of cohesion parameters \\(\\pi_A = (\\pi_{AA}, \\pi_{AB},\\dots)\\); we require that \\(\\sum_B \\pi_{AB}=1\\). To generate a ballot for a voter in bloc \\(A\\), each preference interval \\(I_B\\) is rescaled by the corresponding cohesion parameter \\(\\pi_{AB}\\), and then concatenated to create one preference interval.  Voters then sample ballots proportional to pairwise probabilities of candidates. That is, the probability that the ballot \\(C_1&gt;C_2&gt;C_3\\) is sampled is proprotional to \\(P(C_1&gt;C_2)P(C_2&gt;C_3)P(C_1&gt;C_3)\\), where these pairwise probabilities are given by \\(P(C_1&gt;C_2) = C_1/(C_1+C_2)\\). Here \\(C_i\\) denotes the length of \\(C_i\\)'s share of the combined preference interval.</p>"},{"location":"SCR_ballot_generators/#name-cumulative","title":"Name-Cumulative","text":"<p>The name-Cumulative model (n-C) samples ranked ballots as follows. Assume there are \\(n\\) blocs of voters. Within a bloc, say bloc \\(A\\), voters have \\(n\\) preference intervals, one for each slate of candidates. A bloc also has a fixed \\(n\\)-tuple of cohesion parameters \\(\\pi_A = (\\pi_{AA}, \\pi_{AB},\\dots)\\); we require that \\(\\sum_B \\pi_{AB}=1\\). To generate a ballot for a voter in bloc \\(A\\), each preference interval \\(I_B\\) is rescaled by the corresponding cohesion parameter \\(\\pi_{AB}\\), and then concatenated to create one preference interval. To generate a ballot, voters sample with replacement from the combined interval as many times as determined by the length of the desired ballot.</p>"},{"location":"SCR_ballot_generators/#slate-plackett-luce","title":"Slate-Plackett-Luce","text":"<p>The slate-Plackett-Luce model (s-PL) samples ranked ballots as follows. Assume there are \\(n\\) blocs of voters. Within a bloc, say bloc \\(A\\), voters have \\(n\\) preference intervals, one for each slate of candidates. A bloc also has a fixed \\(n\\)-tuple of cohesion parameters \\(\\pi_A = (\\pi_{AA}, \\pi_{AB},\\dots)\\); we require that \\(\\sum_B \\pi_{AB}=1\\). Now the cohesion parameters play a different role than in the name models above. For s-PL, \\(\\pi_{AB}\\) gives the probability that we put a \\(B\\) candidate in each position on the ballot. If we have already exhausted the number of \\(B\\) candidates, we remove \\(\\pi_{AB}\\) and renormalize. Once we have a ranking of the slates on the ballot, we fill in candidate ordering by sampling without replacement from each individual preference interval (we do not concatenate them!).</p>"},{"location":"SCR_ballot_generators/#slate-bradley-terry","title":"Slate-Bradley-Terry","text":"<p>The slate-Bradley-Terry model (s-BT) samples ranked ballots as follows. We assume there are 2 blocs of voters. Within a bloc, say bloc \\(A\\), voters have 2 preference intervals, one for each slate of candidates. A bloc also has a fixed tuple of cohesion parameters \\(\\pi_A = (\\pi_A, 1-\\pi_A)\\). Now the cohesion parameters play a different role than in the name models above. For s-BT, we again start by filling out a ballot with bloc labels only. Now, the probability that we sample the ballot \\(A&gt;A&gt;B\\) is proportional to \\(\\pi_A^2\\); just like name-Bradley-Terry, we are computing pairwise comparisons. In \\(A&gt;A&gt;B\\), slate \\(A\\) must beat slate \\(B\\) twice. As another example, the probability of \\(A&gt;B&gt;A\\) is proportional to \\(\\pi_A(1-\\pi_A)\\). Once we have a ranking of the slates on the ballot, we fill in candidate ordering by sampling without replacement from each individual preference interval (we do not concatenate them!).</p>"},{"location":"SCR_ballot_generators/#alternating-crossover","title":"Alternating-Crossover","text":"<p>The Alternating-Crossover model (AC) samples ranked ballots as follows. It assumes there are only two blocs. Within a bloc, voters either vote with the bloc, or they alternate. The proportion of such voters is determined by the cohesion parameter. If a voter votes with the bloc, they list all of their bloc's candidates above the other bloc's. If a voter alternates, they list an opposing candidate first, and then alternate between their bloc and the opposing until they run out of one set of candidates. In either case, the order of candidates is determined by a PL model.</p> <ul> <li> <p>The AC model can generate incomplete ballots if there are a different number of candidates in each bloc.</p> </li> <li> <p>The AC model can be initialized from a set of preference intervals, along with which candidates belong to which bloc and a set of cohesion parameters.</p> </li> <li> <p>The AC model only works with two blocs.</p> </li> <li> <p>The AC model also requires information about what proportion of voters belong to each bloc.</p> </li> </ul>"},{"location":"SCR_ballot_generators/#cambridge-sampler","title":"Cambridge-Sampler","text":"<p>The Cambridge-Sampler (CS) samples ranked ballots as follows. Assume there is a majority and a minority bloc. If a voter votes with their bloc, they rank a bloc candidate first. If they vote against their bloc, they rank an opposing bloc candidate first. The proportion of such voters is determined by the cohesion parameter. Once a first entry is recorded, the CS samples a ballot type from historical Cambridge, MA election data. That is, if a voter puts a majorrity candidate first, the rest of their ballot type is sampled in proportion to the number of historical ballots that started with a majority candidate. Once a ballot type is determined, the order of candidates is determined by a PL model.</p> <p>Let's do an example. I am a voter in the majority bloc. I flip a coin weighted by the cohesion parameter, and it comes up tails. My ballot type will start with a minority candidate \\(m\\). The CS samples historical ballots that also started with \\(m\\), and tells me my ballot type is \\(mmM\\); two minority candidates, then a majority. Finally, CS uses a PL model to determine which minority/majority candidates go in the slots.</p> <ul> <li> <p>CS can generate incomplete ballots since it uses historical data.</p> </li> <li> <p>The CS model can be initialized from a set of preference intervals, along with which candidates belong to which bloc and a set of cohesion parameters.</p> </li> <li> <p>The CS model only works with two blocs if you use the Cambridge data.</p> </li> <li> <p>The CS model also requires information about what proportion of voters belong to each bloc.</p> </li> <li> <p>You can give the CS model other historical election data to use.</p> </li> </ul>"},{"location":"SCR_ballot_generators/#distance-models","title":"Distance Models","text":""},{"location":"SCR_ballot_generators/#1-d-spatial","title":"1-D Spatial","text":"<p>The 1-D Spatial model samples ranked ballots as follows. First, it assigns each candidate a position on the real number line according to a normal distribution. Then, it does the same with each voter. Finally, a voter's ranking is determined by their distance from each candidate.</p> <ul> <li> <p>The 1-D Spatial model only generates full ballots.</p> </li> <li> <p>The 1-D Spatial model can be initialized from a list of candidates.</p> </li> </ul>"},{"location":"SCR_distances/","title":"Distances between PreferenceProfiles","text":""},{"location":"SCR_distances/#earthmover-distance","title":"Earthmover Distance","text":"<p>The Earthmover distance is a measure of how far apart two distributions are over a given metric space. In our case, the metric space is the <code>BallotGraph</code> endowed with the shortes path metric. We then consider a <code>PreferenceProfile</code> to be a distribution that assigns the number of times a ballot was cast to a node of the <code>BallotGraph</code>. Informally, the Earthmover distance is the minimum cost of moving the \"dirt\" piled on the nodes by the first profile to the second profile given the distance it must travel.</p>"},{"location":"SCR_distances/#l_p-distance","title":"\\(L_p\\) Distance","text":"<p>The \\(L_p\\) distance is a metric parameterized by \\(p\\in (0,\\infty]\\). It is computed as \\(d(P_1,P_2) = \\left(\\sum |P_1(b)-P_2(b)|^p\\right)^{1/p}\\), where the sum is indexed over all possible ballots, and \\(P_i(b)\\) denotes the number of times that ballot was cast.</p>"},{"location":"SCR_elections/","title":"Elections","text":""},{"location":"SCR_elections/#stv","title":"STV","text":"<p>An STV election stands for single transferable vote. Voters cast ranked choice ballots. A threshold is set; if a candidate crosses the threshold, they are elected. The threshold defaults to the Droop quota. We also enable functionality for the Hare quota.</p> <p>In the first round, the first place votes for each candidate are tallied. If a candidate crosses the threshold, they are elected. Any surplus votes are distributed amongst the other candidates according to a transfer rule. If another candidate crosses the threshold, they are elected. If no candidate does, the candidate with the least first place votes is eliminated, and their ballots are redistributed according to the transfer rule. This repeats until all seats are filled.</p> <ul> <li> <p>An STV election can use either the Droop or Hare quota.</p> </li> <li> <p>The current transfer methods are stored in the elections module.</p> </li> <li> <p>If there is a tiebreak needed, STV defaults to a random tiebreak. Other methods of tiebreak are given in the tie_broken_ranking function of the utils module.</p> </li> </ul>"},{"location":"SCR_elections/#limited","title":"Limited","text":""},{"location":"SCR_elections/#bloc","title":"Bloc","text":""},{"location":"SCR_elections/#sntv","title":"SNTV","text":""},{"location":"SCR_elections/#sntv_stv_hybrid","title":"SNTV_STV_Hybrid","text":""},{"location":"SCR_elections/#toptwo","title":"TopTwo","text":""},{"location":"SCR_elections/#dominatingsets","title":"DominatingSets","text":""},{"location":"SCR_elections/#condo-borda","title":"Condo Borda","text":""},{"location":"SCR_elections/#sequentialrcv","title":"SequentialRCV","text":""},{"location":"SCR_elections/#borda","title":"Borda","text":""},{"location":"SCR_elections/#plurality","title":"Plurality","text":""},{"location":"SCR_elections/#quotas-and-transfers","title":"Quotas and Transfers","text":""},{"location":"SCR_elections/#droop","title":"Droop","text":""},{"location":"SCR_elections/#hare","title":"Hare","text":""},{"location":"SCR_elections/#fractional-trasnfer","title":"Fractional Trasnfer","text":""},{"location":"SCR_general_vocabulary/","title":"General Vocabulary","text":"<ul> <li>Social choice theory: the study of making decisions from collective input.</li> <li>Bullet vote: casting a vote for a single candidate.</li> <li>Ranked choice voting: the act of electing candidates using rankings instead of bullet votes.</li> <li>Linear ranking: an ordering of the candidates \\(A&gt;C&gt;B\\) by your preference for each. \\(A&gt;C\\) means you prefer \\(A\\) to \\(C\\).</li> <li>Ballot: the information gathered from a voter, usually a ranking, but could be points as well.</li> <li>Preference profile: a collection of ballots from voters. Note, this is not the same as an election.</li> <li>Election: a choice of rules for converting a preference profile into an outcome.</li> <li>Ballot generator: a method for creating ballots.</li> <li>Bloc: a group of voters who share some similar voting patterns.</li> <li>CVR: cast vote record, i.e., the collection of ballots.</li> <li>BLT: a file type used to record CVRs in Scottish elections.</li> </ul>"},{"location":"SCR_preference_intervals/","title":"Preference Intervals","text":"<p>A preference interval stores information about a voter's preferences for candidates. We visualize this, unsurprisingly, as an interval. We take the interval \\([0,1]\\) and divide it into pieces, where each piece is proportional to the voter's preference for a particular candidate. If we have two candidates \\(A,B\\), we fix an order of our interval and say that the first piece will denote our preference for \\(A,\\) and the second for \\(B\\). As an abuse of notaton, one could write \\((A,B)\\), where we let \\(A\\) represent the candidate and the length of the interval. For example, if a voter likes candidate \\(A\\) a lot more than \\(B\\), they might have the preference interval \\((0.9, 0.1)\\). This can be extended to any number of candidates, as long as each entry is non-negative and the total of the entries is 1.</p> <p>We have not said how this preference interval actually gets translated into a ranked ballot for a particular voter. That we leave up to the ballot generator models, like the Plackett-Luce model.</p> <p>It should be remarked that there is a difference, at least to VoteKit, between the intervals \\((0.9,0.1,0.0)\\) and \\((0.9,0.1)\\). While both say there is no preference for a third candidate, if the latter interval is fed into VoteKit, that third candidate will never appear on a generated ballot. If we feed it the former interval, the third candidate will always appear at the bottom of the ballot.</p> <p></p> <p>VoteKit provides an option, from_params, which allows you to randomly generate preference intervals. For more on how this is done, see the page on Simplices.</p>"},{"location":"SCR_simplex/","title":"Simplices in Social Choice","text":""},{"location":"SCR_simplex/#candidate-simplex","title":"Candidate Simplex","text":"<p>There is a unique correspondence between preference intervals and points in the candidate simplex. This will be easiest to visualize with three candidates; let's call them \\(A,B,C\\). Our candidate simplex is a triangle, with each vertex representing one of the candidates. If a point on the simplex is close to vertex \\(A\\), that means the point represents a preference interval with strong preference for \\(A\\) (likewise for \\(B\\) or \\(C\\)).</p> <p></p> <p>More formally, we have vectors \\(e_A = (1,0,0), e_B = (0,1,0), e_C = (0,0,1)\\).  Each point on the triangle is a vector \\((a,b,c)\\) where \\(a+b+c=1\\) and \\(a,b,c\\ge 0\\). That is, each point is a convex combination of the vectors \\(e_A, e_B,e_C\\). The value of \\(a\\) denotes someone's \"preference\" for \\(A\\). Thus, a point in the candidate simplex is precisely a preference interval for the candidates!</p> <p>The candidate simplex extends to an arbitrary number of candidates.</p>"},{"location":"SCR_simplex/#ballot-simplex","title":"Ballot Simplex","text":"<p>The ballot simplex is the same thing as the candidate simplex, except now the vertices of the simplex represent full linear rankings. So in the case of 3 candidates, we have \\(3!=6\\) vertices, one for each permutation of the ranking \\(A&gt;B&gt;C\\). A point in the ballot simplex represents a probability distribution over these full linear rankings. This is much harder to visualize since we're stuck in 3 dimensions!  </p> <p>Read about the BallotSimplex object.</p>"},{"location":"SCR_simplex/#dirichlet-distribution","title":"Dirichlet Distribution","text":"<p>Throughout VoteKit, it will be useful to be able to sample from the candidate simplex (if we want to generate preference intervals) or the ballot simplex (if we want a distribution on rankings). How will we sample from the simplex? The Dirichlet distribution! </p> <p>In what follows, we will presume we are discussing the candidate simplex, but it all applies to the ballot simplex as well. The Dirichlet distribution is a probability distribution on the simplex. We parameterize it with a value \\(\\alpha \\in (0,\\infty)\\).  As \\(\\alpha\\to \\infty\\), the mass of the distribution moves to the center of the simplex. This means we are more likely to sample preference intervals that have equal support for all candidates. As \\(\\alpha\\to 0\\), the mass moves to the vertices. This means we are more likely to sample preference intervals that have strong support for one candidate. When \\(\\alpha=1\\), all bets are off. In this regime, we have no knowledge of which candidates are likely to receive support.</p> <p>The value \\(\\alpha\\) is never allowed to be 0 or \\(\\infty\\), so VoteKit uses an arbitrary large number (\\(10^{20}\\)) and an arbitrary small number \\((10^{-10})\\). When members of MGGG have done experiments for studies, they have taken \\(\\alpha = 1/2\\) to be small and \\(\\alpha = 2\\) to be big.</p> <p></p>"},{"location":"SCR_simplex/#multiple-blocs","title":"Multiple Blocs","text":""},{"location":"SCR_simplex/#cohesion-parameters","title":"Cohesion Parameters","text":"<p>When there are multiple blocs, or types, of voters, we utilize cohesion parameters to measure how much voters prefer candidates from their own bloc versus the opposing blocs. In our name models, like <code>name_PlackettLuce</code> or <code>name_BradleyTerry</code>, the cohesion parameters operate as follows. Suppose there are two blocs of voters, \\(X,Y\\). We assume that voters from the \\(X\\) bloc have some underlying preference interval \\(I_{XX}\\) for candidates within their bloc, and a different underlying preference interval \\(I_{XY}\\) for the candidates in the opposing bloc. In order to construct one preference interval for \\(X\\) voters, we take \\(I_{XX}\\) and scale it by \\(\\pi_X\\), then we take \\(I_{XY}\\) and scale it by \\(1-\\pi_X\\), and finally we concatenate the two. As a concrete example, if \\(\\pi_X = .75\\), this means that 3/4 of the preference interval for \\(X\\) voters is taken up by candidates from the \\(X\\) bloc, and the other 1/4 by \\(Y\\) candidates.</p> <p></p> <p>In our slate models, like <code>slate_PlackettLuce</code>, the cohesion parameter is used to determine the probability of sampling a particular slate at each position in the ballot. How exactly this is done depends on the model. Then candidate names are filled in afterwards by sampling without replacement from each preference interval.</p>"},{"location":"SCR_simplex/#combining-dirichlet-and-cohesion","title":"Combining Dirichlet and Cohesion","text":"<p>When there are multiple blocs of voters, we need more than one \\(\\alpha\\) value for the Dirichlet distribution. Suppose there are two blocs of voters, \\(X,Y\\). Then we need four values, \\(\\alpha_{XX}, \\alpha_{XY}, \\alpha_{YX}, \\alpha_{YY}\\). The value \\(\\alpha_{XX}\\) determines what kind of preferences \\(X\\) voters will have for \\(X\\) candidates. The value \\(\\alpha_{XY}\\) determines what kind of preferences \\(X\\) voters have for \\(Y\\) candidates. We sample preference intervals from the candidate simplex using these \\(\\alpha\\) values, and then use cohesion parameters to combine them into a single interval, one for each bloc. This is how from_params initializes different ballot generator models.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#objects","title":"Objects","text":""},{"location":"api/#votekit.ballot.Ballot","title":"<code>Ballot</code>","text":"<p>Ballot class, contains ranking and assigned weight.</p> <p>Attributes <code>ranking</code> :   tuple of candidate ranking. Entry \\(i\\) of the tuple is a frozenset of candidates ranked     in position \\(i\\).</p> <p><code>weight</code> :   (Fraction) weight assigned to a given a ballot. Defaults to 1.</p> <p><code>voter_set</code> :   optional set of voters who cast a given a ballot.</p> <p><code>id</code> :   optional ballot id.</p> Source code in <code>src/votekit/ballot.py</code> <pre><code>@dataclass(frozen=True, config=ConfigDict(arbitrary_types_allowed=True))\nclass Ballot:\n    \"\"\"\n    Ballot class, contains ranking and assigned weight.\n\n    **Attributes**\n    `ranking`\n    :   tuple of candidate ranking. Entry $i$ of the tuple is a frozenset of candidates ranked\n        in position $i$.\n\n    `weight`\n    :   (Fraction) weight assigned to a given a ballot. Defaults to 1.\n\n    `voter_set`\n    :   optional set of voters who cast a given a ballot.\n\n    `id`\n    :   optional ballot id.\n    \"\"\"\n\n    ranking: tuple[frozenset, ...] = field(default_factory=tuple)\n    weight: Fraction = Fraction(1, 1)\n    voter_set: Optional[set[str]] = None\n    id: Optional[str] = None\n\n    def __post_init__(self):\n        # converts weight to a Fraction if an integer or float\n        if not isinstance(self.weight, Fraction):\n            object.__setattr__(\n                self, \"weight\", Fraction(self.weight).limit_denominator()\n            )\n\n    def __eq__(self, other):\n        # Check type\n        if not isinstance(other, Ballot):\n            return False\n\n        # Check id\n        if self.id is not None:\n            if self.id != other.id:\n                return False\n\n        # Check ranking\n        if self.ranking != other.ranking:\n            return False\n\n        # Check weight\n        if self.weight != other.weight:\n            return False\n\n        # Check voters\n        if self.voter_set is not None:\n            if self.voter_set != other.voter_set:\n                return False\n\n        return True\n\n    def __hash__(self):\n        return hash(self.ranking)\n\n    def __str__(self):\n        weight_str = f\"Weight: {self.weight}\\n\"\n        ranking_str = \"Ballot\\n\"\n\n        if self.ranking:\n            for i, s in enumerate(self.ranking):\n                # display number and candidates\n                ranking_str += f\"{i+1}.) \"\n                for c in s:\n                    ranking_str += f\"{c}, \"\n\n                # if tie\n                if len(s) &gt; 1:\n                    ranking_str += \"(tie)\"\n                ranking_str += \"\\n\"\n        else:\n            ranking_str += \"Empty\\n\"\n\n        return ranking_str + weight_str\n\n    __repr__ = __str__\n</code></pre>"},{"location":"api/#votekit.pref_interval.PreferenceInterval","title":"<code>PreferenceInterval</code>","text":"<p>PreferenceInterval class, contains preference for individual candidates stored as relative share of the interval [0,1].</p> <p>Attributes</p> <p><code>interval</code> :   dictionary (candidate, support). A dictionary representing the given PreferenceInterval.     The keys are candidate names, and the values are floats representing that candidates     share of the interval. Does not have to sum to one, the init method will renormalize.</p> <p><code>candidates</code> : frozenset. A frozenset of candidates (with zero and non-zero support)</p> <p><code>non_zero_cands</code> : frozenset. A frozenset of candidates with non-zero support.</p> <p><code>zero_cands</code> : frozenset. A frozenset of candidates with zero support.</p> <p>Methods</p> <p><code>from_dirichlet</code> : sample a PreferenceInterval from the Dirichlet distribution on the candidate simplex.</p> <p><code>normalize</code> : normalize the support values of the PreferenceInterval to sum to 1.</p> <p><code>remove_zero_support_cands</code> : remove candidates with zero support from the interval and store them in the attribute     <code>zero_cands</code>.</p> Source code in <code>src/votekit/pref_interval.py</code> <pre><code>class PreferenceInterval:\n    \"\"\"\n    PreferenceInterval class, contains preference for individual candidates stored as relative\n    share of the interval [0,1].\n\n    **Attributes**\n\n    `interval`\n    :   dictionary (candidate, support). A dictionary representing the given PreferenceInterval.\n        The keys are candidate names, and the values are floats representing that candidates\n        share of the interval. Does not have to sum to one, the init method will renormalize.\n\n    `candidates`\n    : frozenset. A frozenset of candidates (with zero and non-zero support)\n\n    `non_zero_cands`\n    : frozenset. A frozenset of candidates with non-zero support.\n\n    `zero_cands`\n    : frozenset. A frozenset of candidates with zero support.\n\n\n    **Methods**\n\n    `from_dirichlet`\n    : sample a PreferenceInterval from the Dirichlet distribution on the candidate simplex.\n\n    `normalize`\n    : normalize the support values of the PreferenceInterval to sum to 1.\n\n    `remove_zero_support_cands`\n    : remove candidates with zero support from the interval and store them in the attribute\n        `zero_cands`.\n    \"\"\"\n\n    # TODO frozendict, frozenclass\n\n    def __init__(self, interval: dict):\n        self.interval = types.MappingProxyType(interval)\n        self.candidates = frozenset(self.interval.keys())\n\n        self.zero_cands: frozenset = frozenset()\n        self.non_zero_cands: frozenset = frozenset()\n        self._remove_zero_support_cands()\n        self._normalize()\n\n    @classmethod\n    def from_dirichlet(cls, candidates: list[str], alpha: float):\n        \"\"\"\n        Samples a PreferenceInterval from the Dirichlet distribution on the candidate simplex.\n        Alpha tends to 0 is strong support, alpha tends to infinity is uniform support, alpha = 1\n        is all bets are off.\n        \"\"\"\n        probs = list(np.random.default_rng().dirichlet(alpha=[alpha] * len(candidates)))\n\n        return cls({c: s for c, s in zip(candidates, probs)})\n\n    def _normalize(self):\n        \"\"\"\n        Normalize a PreferenceInterval so the support values sum to 1.\n        \"\"\"\n        summ = sum(self.interval.values())\n\n        if summ == 0:\n            raise ZeroDivisionError(\"There are no candidates with non-zero support.\")\n\n        self.interval = types.MappingProxyType(\n            {c: s / summ for c, s in self.interval.items()}\n        )\n\n    def _remove_zero_support_cands(self):\n        \"\"\"\n        Remove candidates with zero support from the interval. Store candidates\n        with zero support as a set in the attribute `zero_cands`.\n\n        Should only be run once.\n        \"\"\"\n\n        if not self.zero_cands and not self.non_zero_cands:\n            self.zero_cands = frozenset([c for c, s in self.interval.items() if s == 0])\n            self.interval = types.MappingProxyType(\n                {c: s for c, s in self.interval.items() if s &gt; 0}\n            )\n            self.non_zero_cands = frozenset(self.interval.keys())\n\n    def __eq__(self, other):\n        if not isinstance(other, PreferenceInterval):\n            raise TypeError(\"Both types must be PreferenceInterval.\")\n\n        if not self.zero_cands == other.zero_cands:\n            return False\n\n        if not self.non_zero_cands == other.non_zero_cands:\n            return False\n\n        if not len(self.interval) == len(other.interval):\n            return False\n\n        else:\n            return all(\n                round(other.interval[key], 8) == round(value, 8)\n                for key, value in self.interval.items()\n            )\n\n    def __repr__(self):\n        printed_interval = {c: round(v, 4) for c, v in self.interval.items()}\n        return str(printed_interval)\n</code></pre>"},{"location":"api/#votekit.pref_interval.PreferenceInterval.from_dirichlet","title":"<code>from_dirichlet(candidates, alpha)</code>  <code>classmethod</code>","text":"<p>Samples a PreferenceInterval from the Dirichlet distribution on the candidate simplex. Alpha tends to 0 is strong support, alpha tends to infinity is uniform support, alpha = 1 is all bets are off.</p> Source code in <code>src/votekit/pref_interval.py</code> <pre><code>@classmethod\ndef from_dirichlet(cls, candidates: list[str], alpha: float):\n    \"\"\"\n    Samples a PreferenceInterval from the Dirichlet distribution on the candidate simplex.\n    Alpha tends to 0 is strong support, alpha tends to infinity is uniform support, alpha = 1\n    is all bets are off.\n    \"\"\"\n    probs = list(np.random.default_rng().dirichlet(alpha=[alpha] * len(candidates)))\n\n    return cls({c: s for c, s in zip(candidates, probs)})\n</code></pre>"},{"location":"api/#votekit.pref_interval.combine_preference_intervals","title":"<code>combine_preference_intervals(intervals, proportions)</code>","text":"<pre><code>Combine a list of preference intervals given a list of proportions used to reweight each\ninterval.\n</code></pre> <p>Arguments <code>intervals</code> : list.  A list of PreferenceInterval objects to combine.</p> <p><code>proportions</code> : list. A list of floats used to reweight the PreferenceInterval objects. Proportion \\(i\\) will reweight interval \\(i\\).</p> Source code in <code>src/votekit/pref_interval.py</code> <pre><code>def combine_preference_intervals(\n    intervals: list[PreferenceInterval], proportions: list[float]\n):\n    \"\"\"\n        Combine a list of preference intervals given a list of proportions used to reweight each\n        interval.\n\n    **Arguments**\n    `intervals`\n    : list.  A list of PreferenceInterval objects to combine.\n\n    `proportions`\n    : list. A list of floats used to reweight the PreferenceInterval objects. Proportion $i$ will\n    reweight interval $i$.\n    \"\"\"\n    if not (\n        len(frozenset.union(*[pi.candidates for pi in intervals]))\n        == sum(len(pi.candidates) for pi in intervals)\n    ):\n        raise ValueError(\"Intervals must have disjoint candidate sets\")\n\n    if round(sum(proportions), 8) != 1:\n        raise ValueError(\"Proportions must sum to 1.\")\n\n    sum_pi = PreferenceInterval(\n        interval={\n            key: value * prop\n            for pi, prop in zip(intervals, proportions)\n            for key, value in pi.interval.items()\n        }\n    )\n\n    # carry along the candidates with zero support\n    zero_cands = frozenset.union(*[pi.zero_cands for pi in intervals])\n\n    # need to union to ensure that if one of the proportions is 0 those candidates are saved\n    sum_pi.zero_cands = sum_pi.zero_cands.union(zero_cands)\n    return sum_pi\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile","title":"<code>PreferenceProfile</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>PreferenceProfile class, contains ballots and candidates for a given election.</p> <p>Attributes</p> <p><code>ballots</code> :   list of <code>Ballot</code> objects.</p> <p><code>candidates</code> :   list of candidates.</p> <p>Methods</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>class PreferenceProfile(BaseModel):\n    \"\"\"\n    PreferenceProfile class, contains ballots and candidates for a given election.\n\n    **Attributes**\n\n    `ballots`\n    :   list of `Ballot` objects.\n\n    `candidates`\n    :   list of candidates.\n\n    **Methods**\n    \"\"\"\n\n    ballots: list[Ballot] = []\n    candidates: Optional[list] = None\n    df: pd.DataFrame = pd.DataFrame()\n\n    @validator(\"candidates\")\n    def cands_must_be_unique(cls, candidates: list) -&gt; list:\n        if not len(set(candidates)) == len(candidates):\n            raise ValueError(\"all candidates must be unique\")\n        return candidates\n\n    def get_ballots(self) -&gt; list[Ballot]:\n        \"\"\"\n        Returns:\n         List of ballots.\n        \"\"\"\n        return self.ballots[:]\n\n    def get_candidates(self, received_votes: Optional[bool] = True) -&gt; list:\n        \"\"\"\n        Args:\n            received_votes: If True, only return candidates that received votes. Defaults\n                    to True.\n        Returns:\n          List of candidates.\n        \"\"\"\n\n        if received_votes or not self.candidates:\n            unique_cands: set = set()\n            for ballot in self.ballots:\n                unique_cands.update(*ballot.ranking)\n\n            return list(unique_cands)\n        else:\n            return self.candidates\n\n    # can also cache\n    def num_ballots(self) -&gt; Fraction:\n        \"\"\"\n        Counts number of ballots based on assigned weight.\n\n        Returns:\n            Number of ballots cast.\n        \"\"\"\n        num_ballots = Fraction(0)\n        for ballot in self.ballots:\n            num_ballots += ballot.weight\n\n        return num_ballots\n\n    def to_dict(self, standardize: bool = False) -&gt; dict:\n        \"\"\"\n        Converts to dictionary with keys = rankings and values = corresponding total weights.\n\n        Args:\n            standardize (Boolean): If True, divides the weight of each ballot\n                            by the total weight. Defaults to False.\n\n        Returns:\n            A dictionary with ranking (keys) and corresponding total weights (values).\n        \"\"\"\n        num_ballots = self.num_ballots()\n        di: dict = {}\n        for ballot in self.ballots:\n            rank_tuple = tuple(next(iter(item)) for item in ballot.ranking)\n            if standardize:\n                weight = ballot.weight / num_ballots\n            else:\n                weight = ballot.weight\n            if rank_tuple not in di.keys():\n                di[rank_tuple] = weight\n            else:\n                di[rank_tuple] += weight\n        return di\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def to_csv(self, fpath: str):\n        \"\"\"\n        Saves PreferenceProfile to CSV.\n\n        Args:\n            fpath: Path to the saved csv.\n        \"\"\"\n        with open(fpath, \"w\", newline=\"\") as csvfile:\n            fieldnames = [\"weight\", \"ranking\"]\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for ballot in self.ballots:\n                writer.writerow({\"weight\": ballot.weight, \"ranking\": ballot.ranking})\n\n    def _create_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Creates pandas DataFrame for display and building plots.\n        \"\"\"\n        weights = []\n        ballots = []\n        for ballot in self.ballots:\n            part = []\n            for ranking in ballot.ranking:\n                if len(ranking) == 1:\n                    part.append(list(ranking)[0])\n\n                else:\n                    part.append(f\"{ranking} (Tie)\")\n\n            ballots.append(tuple(part))\n            weights.append(ballot.weight)\n\n        df = pd.DataFrame({\"Ballots\": ballots, \"Weight\": weights})\n\n        try:\n            df[\"Percent\"] = df[\"Weight\"] / df[\"Weight\"].sum()\n        except ZeroDivisionError:\n            df[\"Percent\"] = np.nan\n\n        # fill nans with zero for edge cases\n        df[\"Percent\"] = df[\"Percent\"].fillna(0.0)\n\n        def format_as_percent(frac):\n            return f\"{float(frac):.2%}\"\n\n        df[\"Percent\"] = df[\"Percent\"].apply(format_as_percent)\n        return df.reset_index(drop=True)\n\n    def head(\n        self,\n        n: int,\n        sort_by_weight: Optional[bool] = True,\n        percents: Optional[bool] = False,\n        totals: Optional[bool] = False,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Displays top-n ballots in profile.\n\n        Args:\n            n: Number of ballots to view.\n            sort_by_weight: If True, rank ballot from most to least votes. Defaults to True.\n            percents: If True, show voter share for a given ballot.\n            totals: If True, show total values for Percent and Weight.\n\n        Returns:\n            A dataframe with top-n ballots.\n        \"\"\"\n        if self.df.empty:\n            self.df = self._create_df()\n\n        if sort_by_weight:\n            df = (\n                self.df.sort_values(by=\"Weight\", ascending=False)\n                .head(n)\n                .reset_index(drop=True)\n            )\n        else:\n            df = self.df.head(n).reset_index(drop=True)\n\n        if totals:\n            df = self._sum_row(df)\n\n        if not percents:\n            return df.drop(columns=\"Percent\")\n\n        return df\n\n    def tail(\n        self,\n        n: int,\n        sort_by_weight: Optional[bool] = True,\n        percents: Optional[bool] = False,\n        totals: Optional[bool] = False,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Displays bottom-n ballots in profile.\n\n        Args:\n            n: Number of ballots to view.\n            sort_by_weight: If True, rank ballot from least to most votes. Defaults to True.\n            percents: If True, show voter share for a given ballot.\n            totals: If True, show total values for Percent and Weight.\n\n        Returns:\n            A data frame with bottom-n ballots.\n        \"\"\"\n\n        if self.df.empty:\n            self.df = self._create_df()\n\n        if sort_by_weight:\n            df = self.df.sort_values(by=\"Weight\", ascending=True)\n            df[\"New Index\"] = [x for x in range(len(self.df) - 1, -1, -1)]\n            df = df.set_index(\"New Index\").head(n)\n            df.index.name = None\n\n        else:\n            df = self.df.iloc[::-1].head(n)\n\n        if totals:\n            df = self._sum_row(df)\n\n        if not percents:\n            return df.drop(columns=\"Percent\")\n\n        return df\n\n    def __str__(self) -&gt; str:\n        # Displays top 15 cast ballots or entire profile\n\n        if self.df.empty:\n            self.df = self._create_df()\n\n        if len(self.df) &lt; 15:\n            return self.head(n=len(self.df), sort_by_weight=True).to_string(\n                index=False, justify=\"justify\"\n            )\n\n        print(\n            f\"PreferenceProfile too long, only showing 15 out of {len(self.df) } rows.\"\n        )\n        return self.head(n=15, sort_by_weight=True).to_string(\n            index=False, justify=\"justify\"\n        )\n\n    # set repr to print outputs\n    __repr__ = __str__\n\n    def condense_ballots(self) -&gt; PreferenceProfile:\n        \"\"\"\n        Groups ballots by rankings and updates weights.\n\n        Returns:\n            A PreferenceProfile object with condensed ballot list.\n        \"\"\"\n        ranking_to_index: dict = {}\n        weight_accumulator = {}\n\n        for ballot in self.ballots:\n            if ballot.ranking not in ranking_to_index:\n                ranking_to_index[ballot.ranking] = len(ranking_to_index)\n                weight_accumulator[ballot.ranking] = Fraction(0)\n\n            weight_accumulator[ballot.ranking] += ballot.weight\n\n        new_ballot_list = [\n            Ballot(ranking=tuple(map(frozenset, ranking)), weight=weight)\n            for ranking, weight in weight_accumulator.items()\n        ]\n\n        condensed_profile = PreferenceProfile(ballots=new_ballot_list)\n        return condensed_profile\n\n    def __eq__(self, other):\n        if not isinstance(other, PreferenceProfile):\n            return False\n        pp_1 = self.condense_ballots()\n        pp_2 = other.condense_ballots()\n        for b in pp_1.ballots:\n            if b not in pp_2.ballots:\n                return False\n        for b in pp_2.ballots:\n            if b not in pp_1.ballots:\n                return False\n        return True\n\n    def _sum_row(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"\n        Computes sum total for weight and percent column\n        \"\"\"\n\n        def format_as_float(percent_str):\n            return float(percent_str.split(\"%\")[0])\n\n        sum_row = {\n            \"Ballot\": \"\",\n            \"Weight\": f'{df[\"Weight\"].sum()} out of {self.num_ballots()}',\n            \"Percent\": f'{df[\"Percent\"].apply(format_as_float).sum():.2f} out of 100%',\n        }\n\n        df.loc[\"Totals\"] = sum_row  # type: ignore\n\n        return df.fillna(\"\")\n\n    def __add__(self, other):\n        \"\"\"\n        Add two PreferenceProfiles by combining their ballot lists.\n        \"\"\"\n        if isinstance(other, PreferenceProfile):\n            ballots = self.ballots + other.ballots\n            pp = PreferenceProfile(ballots=ballots)\n            pp.condense_ballots()\n            return pp\n        else:\n            raise TypeError(\n                \"Unsupported operand type. Must be an instance of PreferenceProfile.\"\n            )\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.__add__","title":"<code>__add__(other)</code>","text":"<p>Add two PreferenceProfiles by combining their ballot lists.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Add two PreferenceProfiles by combining their ballot lists.\n    \"\"\"\n    if isinstance(other, PreferenceProfile):\n        ballots = self.ballots + other.ballots\n        pp = PreferenceProfile(ballots=ballots)\n        pp.condense_ballots()\n        return pp\n    else:\n        raise TypeError(\n            \"Unsupported operand type. Must be an instance of PreferenceProfile.\"\n        )\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.condense_ballots","title":"<code>condense_ballots()</code>","text":"<p>Groups ballots by rankings and updates weights.</p> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A PreferenceProfile object with condensed ballot list.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def condense_ballots(self) -&gt; PreferenceProfile:\n    \"\"\"\n    Groups ballots by rankings and updates weights.\n\n    Returns:\n        A PreferenceProfile object with condensed ballot list.\n    \"\"\"\n    ranking_to_index: dict = {}\n    weight_accumulator = {}\n\n    for ballot in self.ballots:\n        if ballot.ranking not in ranking_to_index:\n            ranking_to_index[ballot.ranking] = len(ranking_to_index)\n            weight_accumulator[ballot.ranking] = Fraction(0)\n\n        weight_accumulator[ballot.ranking] += ballot.weight\n\n    new_ballot_list = [\n        Ballot(ranking=tuple(map(frozenset, ranking)), weight=weight)\n        for ranking, weight in weight_accumulator.items()\n    ]\n\n    condensed_profile = PreferenceProfile(ballots=new_ballot_list)\n    return condensed_profile\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.get_ballots","title":"<code>get_ballots()</code>","text":"<p>Returns:</p> Type Description <code>list[Ballot]</code> <p>List of ballots.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def get_ballots(self) -&gt; list[Ballot]:\n    \"\"\"\n    Returns:\n     List of ballots.\n    \"\"\"\n    return self.ballots[:]\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.get_candidates","title":"<code>get_candidates(received_votes=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>received_votes</code> <code>Optional[bool]</code> <p>If True, only return candidates that received votes. Defaults     to True.</p> <code>True</code> <p>Returns:   List of candidates.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def get_candidates(self, received_votes: Optional[bool] = True) -&gt; list:\n    \"\"\"\n    Args:\n        received_votes: If True, only return candidates that received votes. Defaults\n                to True.\n    Returns:\n      List of candidates.\n    \"\"\"\n\n    if received_votes or not self.candidates:\n        unique_cands: set = set()\n        for ballot in self.ballots:\n            unique_cands.update(*ballot.ranking)\n\n        return list(unique_cands)\n    else:\n        return self.candidates\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.head","title":"<code>head(n, sort_by_weight=True, percents=False, totals=False)</code>","text":"<p>Displays top-n ballots in profile.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of ballots to view.</p> required <code>sort_by_weight</code> <code>Optional[bool]</code> <p>If True, rank ballot from most to least votes. Defaults to True.</p> <code>True</code> <code>percents</code> <code>Optional[bool]</code> <p>If True, show voter share for a given ballot.</p> <code>False</code> <code>totals</code> <code>Optional[bool]</code> <p>If True, show total values for Percent and Weight.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with top-n ballots.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def head(\n    self,\n    n: int,\n    sort_by_weight: Optional[bool] = True,\n    percents: Optional[bool] = False,\n    totals: Optional[bool] = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Displays top-n ballots in profile.\n\n    Args:\n        n: Number of ballots to view.\n        sort_by_weight: If True, rank ballot from most to least votes. Defaults to True.\n        percents: If True, show voter share for a given ballot.\n        totals: If True, show total values for Percent and Weight.\n\n    Returns:\n        A dataframe with top-n ballots.\n    \"\"\"\n    if self.df.empty:\n        self.df = self._create_df()\n\n    if sort_by_weight:\n        df = (\n            self.df.sort_values(by=\"Weight\", ascending=False)\n            .head(n)\n            .reset_index(drop=True)\n        )\n    else:\n        df = self.df.head(n).reset_index(drop=True)\n\n    if totals:\n        df = self._sum_row(df)\n\n    if not percents:\n        return df.drop(columns=\"Percent\")\n\n    return df\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.num_ballots","title":"<code>num_ballots()</code>","text":"<p>Counts number of ballots based on assigned weight.</p> <p>Returns:</p> Type Description <code>Fraction</code> <p>Number of ballots cast.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def num_ballots(self) -&gt; Fraction:\n    \"\"\"\n    Counts number of ballots based on assigned weight.\n\n    Returns:\n        Number of ballots cast.\n    \"\"\"\n    num_ballots = Fraction(0)\n    for ballot in self.ballots:\n        num_ballots += ballot.weight\n\n    return num_ballots\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.tail","title":"<code>tail(n, sort_by_weight=True, percents=False, totals=False)</code>","text":"<p>Displays bottom-n ballots in profile.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of ballots to view.</p> required <code>sort_by_weight</code> <code>Optional[bool]</code> <p>If True, rank ballot from least to most votes. Defaults to True.</p> <code>True</code> <code>percents</code> <code>Optional[bool]</code> <p>If True, show voter share for a given ballot.</p> <code>False</code> <code>totals</code> <code>Optional[bool]</code> <p>If True, show total values for Percent and Weight.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A data frame with bottom-n ballots.</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def tail(\n    self,\n    n: int,\n    sort_by_weight: Optional[bool] = True,\n    percents: Optional[bool] = False,\n    totals: Optional[bool] = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Displays bottom-n ballots in profile.\n\n    Args:\n        n: Number of ballots to view.\n        sort_by_weight: If True, rank ballot from least to most votes. Defaults to True.\n        percents: If True, show voter share for a given ballot.\n        totals: If True, show total values for Percent and Weight.\n\n    Returns:\n        A data frame with bottom-n ballots.\n    \"\"\"\n\n    if self.df.empty:\n        self.df = self._create_df()\n\n    if sort_by_weight:\n        df = self.df.sort_values(by=\"Weight\", ascending=True)\n        df[\"New Index\"] = [x for x in range(len(self.df) - 1, -1, -1)]\n        df = df.set_index(\"New Index\").head(n)\n        df.index.name = None\n\n    else:\n        df = self.df.iloc[::-1].head(n)\n\n    if totals:\n        df = self._sum_row(df)\n\n    if not percents:\n        return df.drop(columns=\"Percent\")\n\n    return df\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.to_csv","title":"<code>to_csv(fpath)</code>","text":"<p>Saves PreferenceProfile to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>Path to the saved csv.</p> required Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def to_csv(self, fpath: str):\n    \"\"\"\n    Saves PreferenceProfile to CSV.\n\n    Args:\n        fpath: Path to the saved csv.\n    \"\"\"\n    with open(fpath, \"w\", newline=\"\") as csvfile:\n        fieldnames = [\"weight\", \"ranking\"]\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        for ballot in self.ballots:\n            writer.writerow({\"weight\": ballot.weight, \"ranking\": ballot.ranking})\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.to_dict","title":"<code>to_dict(standardize=False)</code>","text":"<p>Converts to dictionary with keys = rankings and values = corresponding total weights.</p> <p>Parameters:</p> Name Type Description Default <code>standardize</code> <code>Boolean</code> <p>If True, divides the weight of each ballot             by the total weight. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with ranking (keys) and corresponding total weights (values).</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def to_dict(self, standardize: bool = False) -&gt; dict:\n    \"\"\"\n    Converts to dictionary with keys = rankings and values = corresponding total weights.\n\n    Args:\n        standardize (Boolean): If True, divides the weight of each ballot\n                        by the total weight. Defaults to False.\n\n    Returns:\n        A dictionary with ranking (keys) and corresponding total weights (values).\n    \"\"\"\n    num_ballots = self.num_ballots()\n    di: dict = {}\n    for ballot in self.ballots:\n        rank_tuple = tuple(next(iter(item)) for item in ballot.ranking)\n        if standardize:\n            weight = ballot.weight / num_ballots\n        else:\n            weight = ballot.weight\n        if rank_tuple not in di.keys():\n            di[rank_tuple] = weight\n        else:\n            di[rank_tuple] += weight\n    return di\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState","title":"<code>ElectionState</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class for storing information on each round of an election and the final outcome.</p> <p>Attributes <code>curr_round</code> :   current round number. Defaults to 0.</p> <p><code>elected</code> :   list of candidates who pass a threshold to win.</p> <p><code>eliminated_cands</code> :   list of candidates who were eliminated.</p> <p><code>remaining</code> :   list of candidates who are still in the running.</p> <p><code>profile</code> :   an instance of a PreferenceProfile object.</p> <p><code>previous</code> :   an instance of ElectionState representing the previous round.</p> <p>Methods</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>class ElectionState(BaseModel):\n    \"\"\"\n    Class for storing information on each round of an election and the final outcome.\n\n    **Attributes**\n    `curr_round`\n    :   current round number. Defaults to 0.\n\n    `elected`\n    :   list of candidates who pass a threshold to win.\n\n    `eliminated_cands`\n    :   list of candidates who were eliminated.\n\n    `remaining`\n    :   list of candidates who are still in the running.\n\n    `profile`\n    :   an instance of a PreferenceProfile object.\n\n    `previous`\n    :   an instance of ElectionState representing the previous round.\n\n    **Methods**\n    \"\"\"\n\n    curr_round: int = 0\n    elected: list[set[str]] = []\n    eliminated_cands: list[set[str]] = []\n    remaining: list[set[str]] = []\n    profile: PreferenceProfile\n    scores: dict = {}\n    previous: Optional[\"ElectionState\"] = None\n\n    class Config:\n        allow_mutation = False\n\n    def winners(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns:\n         A list of elected candidates ordered from first round to current round.\n        \"\"\"\n        if self.previous:\n            return self.previous.winners() + self.elected\n\n        return self.elected\n\n    def eliminated(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns:\n          A list of eliminated candidates ordered from current round to first round.\n        \"\"\"\n        if self.previous:\n            return self.eliminated_cands + self.previous.eliminated()\n\n        return self.eliminated_cands\n\n    def rankings(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns:\n          List of all candidates in order of their ranking after each round, first the winners,\\\n          then the eliminated candidates.\n        \"\"\"\n        if self.remaining != [{}]:\n            return self.winners() + self.remaining + self.eliminated()\n\n        return self.winners() + self.eliminated()\n\n    def round_outcome(self, round: int) -&gt; dict:\n        # {'elected':list[set[str]], 'eliminated':list[set[str]]}\n        \"\"\"\n        Finds the outcome of a given round.\n\n        Args:\n            round (int): Round number.\n\n        Returns:\n          A dictionary with elected and eliminated candidates.\n        \"\"\"\n        if self.curr_round == round:\n            return {\n                \"Elected\": self.elected,\n                \"Eliminated\": self.eliminated_cands,\n                \"Remaining\": self.remaining,\n            }\n        elif self.previous:\n            return self.previous.round_outcome(round)\n        else:\n            raise ValueError(\"Round number out of range\")\n\n    def get_scores(self, round: int = curr_round) -&gt; dict:\n        \"\"\"\n        Returns a dictionary of the candidate scores for the inputted round.\n        Defaults to the last round\n        \"\"\"\n        if round == 0 or round &gt; self.curr_round:\n            raise ValueError('Round number out of range\"')\n\n        if round == self.curr_round:\n            return self.scores\n\n        return self.previous.get_scores(self.curr_round - 1)  # type: ignore\n\n    def changed_rankings(self) -&gt; dict:\n        \"\"\"\n        Returns:\n            A dictionary with keys = candidate(s) who changed \\\n                ranking from previous round and values = a tuple of (previous rank, new rank).\n        \"\"\"\n\n        if not self.previous:\n            raise ValueError(\"This is the first round, cannot compare previous ranking\")\n\n        prev_ranking: dict = candidate_position_dict(self.previous.rankings())\n        curr_ranking: dict = candidate_position_dict(self.rankings())\n        if curr_ranking == prev_ranking:\n            return {}\n\n        changes = {}\n        for candidate, index in curr_ranking.items():\n            if prev_ranking[candidate] != index:\n                changes[candidate] = (prev_ranking[candidate], index)\n        return changes\n\n    def status(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns:\n          Data frame displaying candidate, status (elected, eliminated,\n            remaining), and the round their status updated.\n        \"\"\"\n        all_cands = [c for s in self.rankings() for c in s]\n        status_df = pd.DataFrame(\n            {\n                \"Candidate\": all_cands,\n                \"Status\": [\"Remaining\"] * len(all_cands),\n                \"Round\": [self.curr_round] * len(all_cands),\n            }\n        )\n\n        for round in range(1, self.curr_round + 1):\n            results = self.round_outcome(round)\n            for status, ranking in results.items():\n                for s in ranking:\n                    for cand in s:\n                        tied_str = \"\"\n                        # if tie\n                        if len(s) &gt; 1:\n                            remaining_cands = \", \".join(list(s.difference(cand)))\n                            tied_str = f\" (tie with {remaining_cands})\"\n\n                        status_df.loc[status_df[\"Candidate\"] == cand, \"Status\"] = (\n                            status + tied_str\n                        )\n                        status_df.loc[status_df[\"Candidate\"] == cand, \"Round\"] = round\n\n        return status_df\n\n    def to_dict(self, keep: list = []) -&gt; dict:\n        \"\"\"\n        Returns election results as a dictionary.\n\n        Args:\n            keep (list, optional): List of information to store in dictionary, should be subset of\n                \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list,\n                which stores all information.\n\n        \"\"\"\n        keys = [\"elected\", \"eliminated\", \"remaining\", \"ranking\"]\n        values: list = [\n            self.winners(),\n            self.eliminated(),\n            self.remaining,\n            self.rankings(),\n        ]\n\n        rv = {}\n        for key, values in zip(keys, values):\n            if keep and key not in keep:\n                continue\n            # pull out candidates from sets, if tied adds tuple of tied candidates\n            temp_lst = []\n            for cand_set in values:\n                if len(cand_set) &gt; 1:\n                    temp_lst.append(tuple(cand_set))\n                else:\n                    temp_lst += [cand for cand in cand_set]\n            rv[key] = temp_lst\n\n        return rv\n\n    def to_json(self, file_path: Path, keep: list = []):\n        \"\"\"\n        Saves election state object as a JSON file:\n\n        Args:\n            keep (list, optional): List of information to store in dictionary, should be subset of\n                \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list,\n                which stores all information.\n        \"\"\"\n\n        json_dict = json.dumps(self.to_dict(keep=keep))\n        with open(file_path, \"w\") as outfile:\n            outfile.write(json_dict)\n\n    def __str__(self):\n        show = self.status()\n        print(f\"Current Round: {self.curr_round}\")\n        return show.to_string(index=False, justify=\"justify\")\n\n    __repr__ = __str__\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.changed_rankings","title":"<code>changed_rankings()</code>","text":"<p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys = candidate(s) who changed                 ranking from previous round and values = a tuple of (previous rank, new rank).</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def changed_rankings(self) -&gt; dict:\n    \"\"\"\n    Returns:\n        A dictionary with keys = candidate(s) who changed \\\n            ranking from previous round and values = a tuple of (previous rank, new rank).\n    \"\"\"\n\n    if not self.previous:\n        raise ValueError(\"This is the first round, cannot compare previous ranking\")\n\n    prev_ranking: dict = candidate_position_dict(self.previous.rankings())\n    curr_ranking: dict = candidate_position_dict(self.rankings())\n    if curr_ranking == prev_ranking:\n        return {}\n\n    changes = {}\n    for candidate, index in curr_ranking.items():\n        if prev_ranking[candidate] != index:\n            changes[candidate] = (prev_ranking[candidate], index)\n    return changes\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.eliminated","title":"<code>eliminated()</code>","text":"<p>Returns:</p> Type Description <code>list[set[str]]</code> <p>A list of eliminated candidates ordered from current round to first round.</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def eliminated(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns:\n      A list of eliminated candidates ordered from current round to first round.\n    \"\"\"\n    if self.previous:\n        return self.eliminated_cands + self.previous.eliminated()\n\n    return self.eliminated_cands\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.get_scores","title":"<code>get_scores(round=curr_round)</code>","text":"<p>Returns a dictionary of the candidate scores for the inputted round. Defaults to the last round</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def get_scores(self, round: int = curr_round) -&gt; dict:\n    \"\"\"\n    Returns a dictionary of the candidate scores for the inputted round.\n    Defaults to the last round\n    \"\"\"\n    if round == 0 or round &gt; self.curr_round:\n        raise ValueError('Round number out of range\"')\n\n    if round == self.curr_round:\n        return self.scores\n\n    return self.previous.get_scores(self.curr_round - 1)  # type: ignore\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.rankings","title":"<code>rankings()</code>","text":"<p>Returns:</p> Type Description <code>list[set[str]]</code> <p>List of all candidates in order of their ranking after each round, first the winners,          then the eliminated candidates.</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def rankings(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns:\n      List of all candidates in order of their ranking after each round, first the winners,\\\n      then the eliminated candidates.\n    \"\"\"\n    if self.remaining != [{}]:\n        return self.winners() + self.remaining + self.eliminated()\n\n    return self.winners() + self.eliminated()\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.round_outcome","title":"<code>round_outcome(round)</code>","text":"<p>Finds the outcome of a given round.</p> <p>Parameters:</p> Name Type Description Default <code>round</code> <code>int</code> <p>Round number.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with elected and eliminated candidates.</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def round_outcome(self, round: int) -&gt; dict:\n    # {'elected':list[set[str]], 'eliminated':list[set[str]]}\n    \"\"\"\n    Finds the outcome of a given round.\n\n    Args:\n        round (int): Round number.\n\n    Returns:\n      A dictionary with elected and eliminated candidates.\n    \"\"\"\n    if self.curr_round == round:\n        return {\n            \"Elected\": self.elected,\n            \"Eliminated\": self.eliminated_cands,\n            \"Remaining\": self.remaining,\n        }\n    elif self.previous:\n        return self.previous.round_outcome(round)\n    else:\n        raise ValueError(\"Round number out of range\")\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.status","title":"<code>status()</code>","text":"<p>Returns:</p> Type Description <code>DataFrame</code> <p>Data frame displaying candidate, status (elected, eliminated, remaining), and the round their status updated.</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def status(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns:\n      Data frame displaying candidate, status (elected, eliminated,\n        remaining), and the round their status updated.\n    \"\"\"\n    all_cands = [c for s in self.rankings() for c in s]\n    status_df = pd.DataFrame(\n        {\n            \"Candidate\": all_cands,\n            \"Status\": [\"Remaining\"] * len(all_cands),\n            \"Round\": [self.curr_round] * len(all_cands),\n        }\n    )\n\n    for round in range(1, self.curr_round + 1):\n        results = self.round_outcome(round)\n        for status, ranking in results.items():\n            for s in ranking:\n                for cand in s:\n                    tied_str = \"\"\n                    # if tie\n                    if len(s) &gt; 1:\n                        remaining_cands = \", \".join(list(s.difference(cand)))\n                        tied_str = f\" (tie with {remaining_cands})\"\n\n                    status_df.loc[status_df[\"Candidate\"] == cand, \"Status\"] = (\n                        status + tied_str\n                    )\n                    status_df.loc[status_df[\"Candidate\"] == cand, \"Round\"] = round\n\n    return status_df\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.to_dict","title":"<code>to_dict(keep=[])</code>","text":"<p>Returns election results as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>keep</code> <code>list</code> <p>List of information to store in dictionary, should be subset of \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list, which stores all information.</p> <code>[]</code> Source code in <code>src/votekit/election_state.py</code> <pre><code>def to_dict(self, keep: list = []) -&gt; dict:\n    \"\"\"\n    Returns election results as a dictionary.\n\n    Args:\n        keep (list, optional): List of information to store in dictionary, should be subset of\n            \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list,\n            which stores all information.\n\n    \"\"\"\n    keys = [\"elected\", \"eliminated\", \"remaining\", \"ranking\"]\n    values: list = [\n        self.winners(),\n        self.eliminated(),\n        self.remaining,\n        self.rankings(),\n    ]\n\n    rv = {}\n    for key, values in zip(keys, values):\n        if keep and key not in keep:\n            continue\n        # pull out candidates from sets, if tied adds tuple of tied candidates\n        temp_lst = []\n        for cand_set in values:\n            if len(cand_set) &gt; 1:\n                temp_lst.append(tuple(cand_set))\n            else:\n                temp_lst += [cand for cand in cand_set]\n        rv[key] = temp_lst\n\n    return rv\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.to_json","title":"<code>to_json(file_path, keep=[])</code>","text":"<p>Saves election state object as a JSON file:</p> <p>Parameters:</p> Name Type Description Default <code>keep</code> <code>list</code> <p>List of information to store in dictionary, should be subset of \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list, which stores all information.</p> <code>[]</code> Source code in <code>src/votekit/election_state.py</code> <pre><code>def to_json(self, file_path: Path, keep: list = []):\n    \"\"\"\n    Saves election state object as a JSON file:\n\n    Args:\n        keep (list, optional): List of information to store in dictionary, should be subset of\n            \"elected\", \"eliminated\", \"remaining\", \"ranking\". Defaults to empty list,\n            which stores all information.\n    \"\"\"\n\n    json_dict = json.dumps(self.to_dict(keep=keep))\n    with open(file_path, \"w\") as outfile:\n        outfile.write(json_dict)\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.winners","title":"<code>winners()</code>","text":"<p>Returns:</p> Type Description <code>list[set[str]]</code> <p>A list of elected candidates ordered from first round to current round.</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def winners(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns:\n     A list of elected candidates ordered from first round to current round.\n    \"\"\"\n    if self.previous:\n        return self.previous.winners() + self.elected\n\n    return self.elected\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph","title":"<code>BallotGraph</code>","text":"<p>             Bases: <code>Graph</code></p> <p>Class to build ballot graphs.</p> <p>Attributes</p> <p><code>source</code> :   data to create graph from, either PreferenceProfile object, number of         candidates, or list of candidates.</p> <p><code>allow_partial</code> :   if True, builds graph using all possible ballots,     if False, only uses total linear ordered ballots.     If building from a PreferenceProfile, defaults to True.</p> <p><code>fix_short</code> : if True, auto completes ballots of length n-1 to n.</p> <p>Methods</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>class BallotGraph(Graph):\n    \"\"\"\n    Class to build ballot graphs.\n\n    **Attributes**\n\n    `source`\n    :   data to create graph from, either PreferenceProfile object, number of\n            candidates, or list of candidates.\n\n    `allow_partial`\n    :   if True, builds graph using all possible ballots,\n        if False, only uses total linear ordered ballots.\n        If building from a PreferenceProfile, defaults to True.\n\n    `fix_short`\n    : if True, auto completes ballots of length n-1 to n.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        source: Union[PreferenceProfile, int, list],\n        allow_partial: Optional[bool] = True,\n        fix_short: Optional[bool] = True,\n    ):\n        super().__init__()\n\n        self.profile = None\n        self.candidates = None\n        self.allow_partial = allow_partial\n\n        if isinstance(source, int):\n            self.num_cands = source\n            self.graph = self.build_graph(source)\n\n        if isinstance(source, list):\n            self.num_cands = len(source)\n            self.graph = self.build_graph(len(source))\n            self.candidates = source\n\n        if isinstance(source, PreferenceProfile):\n            self.profile = source\n            self.num_voters = source.num_ballots()\n            self.num_cands = len(source.get_candidates())\n            self.allow_partial = True\n            if not self.graph:\n                self.graph = self.build_graph(len(source.get_candidates()))\n            self.graph = self.from_profile(source, fix_short=fix_short)\n\n        self.num_voters = sum(self.node_weights.values())\n\n        # if no partial ballots allowed, create induced subgraph\n        if not self.allow_partial:\n            total_ballots = [n for n in self.graph.nodes() if len(n) == self.num_cands]\n            self.graph = self.graph.subgraph(total_ballots)\n\n        if not self.node_weights:\n            self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n    def _relabel(self, gr: nx.Graph, new_label: int, num_cands: int) -&gt; nx.Graph:\n        \"\"\"\n        Relabels nodes in gr based on new_label\n        \"\"\"\n        node_map = {}\n        graph_nodes = list(gr.nodes)\n\n        for k in graph_nodes:\n            # add the value of new_label to every entry in every ballot\n            tmp = [new_label + y for y in k]\n\n            # reduce everything mod new_label\n            for i in range(len(tmp)):\n                if tmp[i] &gt; num_cands:\n                    tmp[i] = tmp[i] - num_cands\n            node_map[k] = tuple([new_label] + tmp)\n\n        return nx.relabel_nodes(gr, node_map)\n\n    def build_graph(self, n: int) -&gt; nx.Graph:  # ask Gabe about optimizing?\n        \"\"\"\n        Builds graph of all possible ballots given a number of candiates.\n\n        Args:\n            n: Number of candidates in an election.\n\n        Returns:\n            A networkx graph.\n        \"\"\"\n        Gc = nx.Graph()\n        # base cases\n        if n == 1:\n            Gc.add_nodes_from([(1)], weight=0, cast=False)\n\n        elif n == 2:\n            Gc.add_nodes_from([(1, 2), (2, 1)], weight=0, cast=False)\n            Gc.add_edges_from([((1, 2), (2, 1))])\n\n        elif n &gt; 2:\n            G_prev = self.build_graph(n - 1)\n            for i in range(1, n + 1):\n                # add the node for the bullet vote i\n                Gc.add_node((i,), weight=0, cast=False)\n\n                # make the subgraph for the ballots where i is ranked first\n                G_corner = self._relabel(G_prev, i, n)\n\n                # add the components from that graph to the larger graph\n                Gc.add_nodes_from(G_corner.nodes, weight=0, cast=False)\n                Gc.add_edges_from(G_corner.edges)\n\n                # connect the bullet vote node to the appropriate vertices\n                if n == 3:\n                    Gc.add_edges_from([(k, (i,)) for k in G_corner.nodes])\n                else:\n                    Gc.add_edges_from(\n                        [(k, (i,)) for k in G_corner.nodes if len(k) == 2]\n                    )\n\n            nodes = Gc.nodes\n\n            new_edges = [\n                (bal, (bal[1], bal[0]) + bal[2:]) for bal in nodes if len(bal) &gt;= 2\n            ]\n            Gc.add_edges_from(new_edges)\n\n        return Gc\n\n    def from_profile(\n        self, profile: PreferenceProfile, fix_short: Optional[bool] = True\n    ) -&gt; nx.Graph:\n        \"\"\"\n        Updates existing graph based on cast ballots from a PreferenceProfile,\n        or creates graph based on PreferenceProfile.\n\n        Args:\n            profile: PreferenceProfile assigned to graph.\n\n\n        Returns:\n            Graph based on PreferenceProfile, 'cast' node attribute indicates\n                    ballots cast in PreferenceProfile.\n        \"\"\"\n        if not self.profile:\n            self.profile = profile\n\n        if not self.num_voters:\n            self.num_voters = profile.num_ballots()\n\n        self.candidates = profile.get_candidates()\n        ballots = profile.get_ballots()\n        self.cand_num = self._number_cands(tuple(self.candidates))\n        self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n        for ballot in ballots:\n            ballot_node = []\n            for position in ballot.ranking:\n                if len(position) &gt; 1:\n                    raise ValueError(\n                        \"ballots must be cleaned to resolve ties\"\n                    )  # still unsure about ties\n                for cand in position:\n                    ballot_node.append(self.cand_num[cand])\n            if len(ballot_node) == len(self.candidates) - 1 and fix_short:\n                ballot_node = self.fix_short_ballot(\n                    ballot_node, list(self.cand_num.values())\n                )\n\n            if tuple(ballot_node) in self.graph.nodes:\n                self.graph.nodes[tuple(ballot_node)][\"weight\"] += ballot.weight\n                self.graph.nodes[tuple(ballot_node)][\"cast\"] = True\n                self.node_weights[tuple(ballot_node)] += ballot.weight\n\n        return self.graph\n\n    def fix_short_ballot(self, ballot: list, candidates: list) -&gt; list:\n        \"\"\"\n        Adds missing candidates to a short ballot.\n\n        Args:\n            ballot: A list of candidates on the ballot.\n            candidates: A list of all candidates.\n\n        Returns:\n            A new list with the missing candidates added to the end of the ballot.\n\n        \"\"\"\n        missing = set(candidates).difference(set(ballot))\n\n        return ballot + list(missing)\n\n    def label_cands(self, candidates, to_display: Callable = all_nodes):\n        \"\"\"\n        Assigns candidate labels to ballot graph for plotting.\n\n        Args:\n            candidates (list): A list of candidates.\n            to_display: A Boolean callable that takes in a graph and node,\n                        returns True if node should be displayed.\n        \"\"\"\n\n        candidate_numbers = self._number_cands(tuple(candidates))\n\n        cand_dict = {value: key for key, value in candidate_numbers.items()}\n\n        cand_labels = {}\n        for node in self.graph.nodes:\n            if to_display(self.graph, node):\n                ballot = []\n                for num in node:\n                    ballot.append(cand_dict[num])\n\n                # label the ballot and give the number of votes\n                cand_labels[node] = (\n                    str(tuple(ballot)) + \": \" + str(self.graph.nodes[node][\"weight\"])\n                )\n\n        return cand_labels\n\n    def label_weights(self, to_display: Callable = all_nodes):\n        \"\"\"\n        Assigns weight labels to ballot graph for plotting.\n        Only shows weight if non-zero.\n\n        Args:\n            to_display: A Boolean callable that takes in a graph and node,\n                        returns True if node should be displayed.\n        \"\"\"\n        node_labels = {}\n        for node in self.graph.nodes:\n            if to_display(self.graph, node):\n                # label the ballot and give the number of votes\n                if self.graph.nodes[node][\"weight\"] &gt; 0:\n                    node_labels[node] = (\n                        str(node) + \": \" + str(self.graph.nodes[node][\"weight\"])\n                    )\n                else:\n                    node_labels[node] = str(node)\n\n        return node_labels\n\n    @cache\n    def _number_cands(self, cands: tuple) -&gt; dict:\n        \"\"\"\n        Assigns numerical marker to candidates\n        \"\"\"\n        legend = {}\n        for idx, cand in enumerate(cands):\n            legend[cand] = idx + 1\n\n        return legend\n\n    def draw(\n        self,\n        to_display: Callable = all_nodes,\n        neighborhoods: Optional[list[tuple]] = [],\n        show_cast: Optional[bool] = False,\n        labels: Optional[bool] = False,\n    ):\n        \"\"\"\n        Visualize the graph.\n\n        Args:\n            to_display: A boolean function that takes the graph and a node as input,\n                returns True if you want that node displayed. Defaults to showing all nodes.\n            neighborhoods: A list of neighborhoods to display, given as tuple (node, radius).\n                            (ex. (n,1) gives all nodes within one step of n).\n            show_cast: If True, show only nodes with \"cast\" attribute = True.\n                        If False, show all nodes.\n            labels: If True, labels nodes with candidate names and vote totals.\n        \"\"\"\n\n        def cast_nodes(graph, node):\n            return graph.nodes[node][\"cast\"]\n\n        def in_neighborhoods(graph, node):\n            centers = [node for node, radius in neighborhoods]\n            radii = [radius for node, radius in neighborhoods]\n\n            distances = [nx.shortest_path_length(graph, node, x) for x in centers]\n\n            return True in [d &lt;= r for d, r in zip(distances, radii)]\n\n        if show_cast:\n            to_display = cast_nodes\n\n        if neighborhoods:\n            to_display = in_neighborhoods\n\n        ballots = [n for n in self.graph.nodes if to_display(self.graph, n)]\n\n        if labels:\n            if not self.candidates:\n                raise ValueError(\"no candidate names assigned\")\n            node_labels = self.label_cands(self.candidates, to_display)\n\n        else:\n            node_labels = self.label_weights(to_display)\n\n            # if not labeling the nodes with candidates and graph is drawn from profile,\n            # print labeling dictionary\n            if self.profile and self.candidates:\n                print(\"The candidates are labeled as follows.\")\n                cand_dict = self._number_cands(cands=tuple(self.candidates))\n                for cand, value in cand_dict.items():\n                    print(value, cand)\n\n        subgraph = self.graph.subgraph(ballots)\n\n        pos = nx.spring_layout(subgraph)\n        nx.draw_networkx(subgraph, pos=pos, with_labels=True, labels=node_labels)\n\n        # handles labels overlapping with margins\n        x_values, y_values = zip(*pos.values())\n        x_max, y_max = max(x_values), max(y_values)\n        x_min, y_min = min(x_values), min(y_values)\n        x_margin = (x_max - x_min) * 0.25\n        y_margin = (y_max - y_min) * 0.25\n        plt.xlim(x_min - x_margin, x_max + x_margin)\n        plt.ylim(y_min - y_margin, y_max + y_margin)\n        plt.show()\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.build_graph","title":"<code>build_graph(n)</code>","text":"<p>Builds graph of all possible ballots given a number of candiates.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of candidates in an election.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>A networkx graph.</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def build_graph(self, n: int) -&gt; nx.Graph:  # ask Gabe about optimizing?\n    \"\"\"\n    Builds graph of all possible ballots given a number of candiates.\n\n    Args:\n        n: Number of candidates in an election.\n\n    Returns:\n        A networkx graph.\n    \"\"\"\n    Gc = nx.Graph()\n    # base cases\n    if n == 1:\n        Gc.add_nodes_from([(1)], weight=0, cast=False)\n\n    elif n == 2:\n        Gc.add_nodes_from([(1, 2), (2, 1)], weight=0, cast=False)\n        Gc.add_edges_from([((1, 2), (2, 1))])\n\n    elif n &gt; 2:\n        G_prev = self.build_graph(n - 1)\n        for i in range(1, n + 1):\n            # add the node for the bullet vote i\n            Gc.add_node((i,), weight=0, cast=False)\n\n            # make the subgraph for the ballots where i is ranked first\n            G_corner = self._relabel(G_prev, i, n)\n\n            # add the components from that graph to the larger graph\n            Gc.add_nodes_from(G_corner.nodes, weight=0, cast=False)\n            Gc.add_edges_from(G_corner.edges)\n\n            # connect the bullet vote node to the appropriate vertices\n            if n == 3:\n                Gc.add_edges_from([(k, (i,)) for k in G_corner.nodes])\n            else:\n                Gc.add_edges_from(\n                    [(k, (i,)) for k in G_corner.nodes if len(k) == 2]\n                )\n\n        nodes = Gc.nodes\n\n        new_edges = [\n            (bal, (bal[1], bal[0]) + bal[2:]) for bal in nodes if len(bal) &gt;= 2\n        ]\n        Gc.add_edges_from(new_edges)\n\n    return Gc\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.draw","title":"<code>draw(to_display=all_nodes, neighborhoods=[], show_cast=False, labels=False)</code>","text":"<p>Visualize the graph.</p> <p>Parameters:</p> Name Type Description Default <code>to_display</code> <code>Callable</code> <p>A boolean function that takes the graph and a node as input, returns True if you want that node displayed. Defaults to showing all nodes.</p> <code>all_nodes</code> <code>neighborhoods</code> <code>Optional[list[tuple]]</code> <p>A list of neighborhoods to display, given as tuple (node, radius).             (ex. (n,1) gives all nodes within one step of n).</p> <code>[]</code> <code>show_cast</code> <code>Optional[bool]</code> <p>If True, show only nodes with \"cast\" attribute = True.         If False, show all nodes.</p> <code>False</code> <code>labels</code> <code>Optional[bool]</code> <p>If True, labels nodes with candidate names and vote totals.</p> <code>False</code> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def draw(\n    self,\n    to_display: Callable = all_nodes,\n    neighborhoods: Optional[list[tuple]] = [],\n    show_cast: Optional[bool] = False,\n    labels: Optional[bool] = False,\n):\n    \"\"\"\n    Visualize the graph.\n\n    Args:\n        to_display: A boolean function that takes the graph and a node as input,\n            returns True if you want that node displayed. Defaults to showing all nodes.\n        neighborhoods: A list of neighborhoods to display, given as tuple (node, radius).\n                        (ex. (n,1) gives all nodes within one step of n).\n        show_cast: If True, show only nodes with \"cast\" attribute = True.\n                    If False, show all nodes.\n        labels: If True, labels nodes with candidate names and vote totals.\n    \"\"\"\n\n    def cast_nodes(graph, node):\n        return graph.nodes[node][\"cast\"]\n\n    def in_neighborhoods(graph, node):\n        centers = [node for node, radius in neighborhoods]\n        radii = [radius for node, radius in neighborhoods]\n\n        distances = [nx.shortest_path_length(graph, node, x) for x in centers]\n\n        return True in [d &lt;= r for d, r in zip(distances, radii)]\n\n    if show_cast:\n        to_display = cast_nodes\n\n    if neighborhoods:\n        to_display = in_neighborhoods\n\n    ballots = [n for n in self.graph.nodes if to_display(self.graph, n)]\n\n    if labels:\n        if not self.candidates:\n            raise ValueError(\"no candidate names assigned\")\n        node_labels = self.label_cands(self.candidates, to_display)\n\n    else:\n        node_labels = self.label_weights(to_display)\n\n        # if not labeling the nodes with candidates and graph is drawn from profile,\n        # print labeling dictionary\n        if self.profile and self.candidates:\n            print(\"The candidates are labeled as follows.\")\n            cand_dict = self._number_cands(cands=tuple(self.candidates))\n            for cand, value in cand_dict.items():\n                print(value, cand)\n\n    subgraph = self.graph.subgraph(ballots)\n\n    pos = nx.spring_layout(subgraph)\n    nx.draw_networkx(subgraph, pos=pos, with_labels=True, labels=node_labels)\n\n    # handles labels overlapping with margins\n    x_values, y_values = zip(*pos.values())\n    x_max, y_max = max(x_values), max(y_values)\n    x_min, y_min = min(x_values), min(y_values)\n    x_margin = (x_max - x_min) * 0.25\n    y_margin = (y_max - y_min) * 0.25\n    plt.xlim(x_min - x_margin, x_max + x_margin)\n    plt.ylim(y_min - y_margin, y_max + y_margin)\n    plt.show()\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.fix_short_ballot","title":"<code>fix_short_ballot(ballot, candidates)</code>","text":"<p>Adds missing candidates to a short ballot.</p> <p>Parameters:</p> Name Type Description Default <code>ballot</code> <code>list</code> <p>A list of candidates on the ballot.</p> required <code>candidates</code> <code>list</code> <p>A list of all candidates.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A new list with the missing candidates added to the end of the ballot.</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def fix_short_ballot(self, ballot: list, candidates: list) -&gt; list:\n    \"\"\"\n    Adds missing candidates to a short ballot.\n\n    Args:\n        ballot: A list of candidates on the ballot.\n        candidates: A list of all candidates.\n\n    Returns:\n        A new list with the missing candidates added to the end of the ballot.\n\n    \"\"\"\n    missing = set(candidates).difference(set(ballot))\n\n    return ballot + list(missing)\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.from_profile","title":"<code>from_profile(profile, fix_short=True)</code>","text":"<p>Updates existing graph based on cast ballots from a PreferenceProfile, or creates graph based on PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>PreferenceProfile assigned to graph.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>Graph based on PreferenceProfile, 'cast' node attribute indicates     ballots cast in PreferenceProfile.</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def from_profile(\n    self, profile: PreferenceProfile, fix_short: Optional[bool] = True\n) -&gt; nx.Graph:\n    \"\"\"\n    Updates existing graph based on cast ballots from a PreferenceProfile,\n    or creates graph based on PreferenceProfile.\n\n    Args:\n        profile: PreferenceProfile assigned to graph.\n\n\n    Returns:\n        Graph based on PreferenceProfile, 'cast' node attribute indicates\n                ballots cast in PreferenceProfile.\n    \"\"\"\n    if not self.profile:\n        self.profile = profile\n\n    if not self.num_voters:\n        self.num_voters = profile.num_ballots()\n\n    self.candidates = profile.get_candidates()\n    ballots = profile.get_ballots()\n    self.cand_num = self._number_cands(tuple(self.candidates))\n    self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n    for ballot in ballots:\n        ballot_node = []\n        for position in ballot.ranking:\n            if len(position) &gt; 1:\n                raise ValueError(\n                    \"ballots must be cleaned to resolve ties\"\n                )  # still unsure about ties\n            for cand in position:\n                ballot_node.append(self.cand_num[cand])\n        if len(ballot_node) == len(self.candidates) - 1 and fix_short:\n            ballot_node = self.fix_short_ballot(\n                ballot_node, list(self.cand_num.values())\n            )\n\n        if tuple(ballot_node) in self.graph.nodes:\n            self.graph.nodes[tuple(ballot_node)][\"weight\"] += ballot.weight\n            self.graph.nodes[tuple(ballot_node)][\"cast\"] = True\n            self.node_weights[tuple(ballot_node)] += ballot.weight\n\n    return self.graph\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.label_cands","title":"<code>label_cands(candidates, to_display=all_nodes)</code>","text":"<p>Assigns candidate labels to ballot graph for plotting.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>list</code> <p>A list of candidates.</p> required <code>to_display</code> <code>Callable</code> <p>A Boolean callable that takes in a graph and node,         returns True if node should be displayed.</p> <code>all_nodes</code> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def label_cands(self, candidates, to_display: Callable = all_nodes):\n    \"\"\"\n    Assigns candidate labels to ballot graph for plotting.\n\n    Args:\n        candidates (list): A list of candidates.\n        to_display: A Boolean callable that takes in a graph and node,\n                    returns True if node should be displayed.\n    \"\"\"\n\n    candidate_numbers = self._number_cands(tuple(candidates))\n\n    cand_dict = {value: key for key, value in candidate_numbers.items()}\n\n    cand_labels = {}\n    for node in self.graph.nodes:\n        if to_display(self.graph, node):\n            ballot = []\n            for num in node:\n                ballot.append(cand_dict[num])\n\n            # label the ballot and give the number of votes\n            cand_labels[node] = (\n                str(tuple(ballot)) + \": \" + str(self.graph.nodes[node][\"weight\"])\n            )\n\n    return cand_labels\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.label_weights","title":"<code>label_weights(to_display=all_nodes)</code>","text":"<p>Assigns weight labels to ballot graph for plotting. Only shows weight if non-zero.</p> <p>Parameters:</p> Name Type Description Default <code>to_display</code> <code>Callable</code> <p>A Boolean callable that takes in a graph and node,         returns True if node should be displayed.</p> <code>all_nodes</code> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def label_weights(self, to_display: Callable = all_nodes):\n    \"\"\"\n    Assigns weight labels to ballot graph for plotting.\n    Only shows weight if non-zero.\n\n    Args:\n        to_display: A Boolean callable that takes in a graph and node,\n                    returns True if node should be displayed.\n    \"\"\"\n    node_labels = {}\n    for node in self.graph.nodes:\n        if to_display(self.graph, node):\n            # label the ballot and give the number of votes\n            if self.graph.nodes[node][\"weight\"] &gt; 0:\n                node_labels[node] = (\n                    str(node) + \": \" + str(self.graph.nodes[node][\"weight\"])\n                )\n            else:\n                node_labels[node] = str(node)\n\n    return node_labels\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph","title":"<code>PairwiseComparisonGraph</code>","text":"<p>             Bases: <code>Graph</code></p> <p>Class to construct the pairwise comparison graph where nodes are candidates and edges are pairwise preferences.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to construct graph from.</p> <p><code>ballot_length</code> :   (optional) max length of ballot, defaults to longest possible ballot length.</p> <p>Methods</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>class PairwiseComparisonGraph(Graph):\n    \"\"\"\n    Class to construct the pairwise comparison graph where nodes are candidates\n    and edges are pairwise preferences.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to construct graph from.\n\n    `ballot_length`\n    :   (optional) max length of ballot, defaults to longest possible ballot length.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(self, profile: PreferenceProfile, ballot_length=None):\n        self.ballot_length = ballot_length\n        if ballot_length is None:\n            self.ballot_length = len(profile.get_candidates())\n        full_profile = self.ballot_fill(profile, self.ballot_length)\n        self.profile = full_profile\n        self.candidates = self.profile.get_candidates()\n        self.pairwise_dict = self.compute_pairwise_dict()\n        self.pairwise_graph = self.build_graph()\n\n    def ballot_fill(self, profile: PreferenceProfile, ballot_length: int):\n        \"\"\"\n        Fills incomplete ballots for pairwise comparison.\n\n        Args:\n            profile: PreferenceProfile to fill.\n            ballot_length: How long a ballot is.\n\n        Returns:\n            PreferenceProfile (PreferenceProfile): A PreferenceProfile with incomplete\n                ballots filled in.\n        \"\"\"\n        cand_list = [{cand} for cand in profile.get_candidates()]\n        updated_ballot_list = []\n\n        for ballot in profile.get_ballots():\n            if len(ballot.ranking) &lt; ballot_length:\n                missing_cands = [\n                    cand for cand in cand_list if cand not in ballot.ranking\n                ]\n                missing_cands_perms = list(\n                    permutations(missing_cands, len(missing_cands))\n                )\n                frac_freq = ballot.weight / (len(missing_cands_perms))\n                for perm in missing_cands_perms:\n                    updated_rank = ballot.ranking + tuple([frozenset(c) for c in perm])\n                    updated_ballot = Ballot(\n                        ranking=updated_rank, weight=Fraction(frac_freq, 1)\n                    )\n                    updated_ballot_list.append(updated_ballot)\n            else:\n                updated_ballot_list.append(ballot)\n        return PreferenceProfile(ballots=updated_ballot_list)\n\n    # Helper functions to make pairwise comparison graph\n    def head2head_count(self, cand1, cand2) -&gt; Fraction:\n        \"\"\"\n        Counts head to head comparisons between two candidates. Note that the given order\n        of the candidates matters here.\n\n        Args:\n            cand1 (str): The first candidate to compare.\n            cand2 (str): The second candidate to compare.\n\n        Returns:\n            A count of the number of times cand1 is preferred to cand2.\n        \"\"\"\n        count = 0\n        ballots_list = self.profile.get_ballots()\n        for ballot in ballots_list:\n            rank_list = ballot.ranking\n            for s in rank_list:\n                if cand1 in s:\n                    count += ballot.weight\n                    break\n                elif cand2 in s:\n                    break\n        return Fraction(count)\n\n    def compute_pairwise_dict(self) -&gt; dict:\n        \"\"\"\n        Constructs dictionary where keys are tuples (cand_a, cand_b) containing\n        two candidates and values is the frequency cand_a is preferred to\n        cand_b.\n\n        Returns:\n            A dictionary with keys = (cand_a, cand_b) and values = frequency cand_a is preferred\n                to cand_b.\n        \"\"\"\n        pairwise_dict = {}  # {(cand_a, cand_b): freq cand_a is preferred over cand_b}\n        cand_pairs = combinations(self.candidates, 2)\n\n        for pair in cand_pairs:\n            cand_a, cand_b = pair[0], pair[1]\n            head_2_head_dict = {\n                (cand_a, cand_b): self.head2head_count(cand_a, cand_b),\n                (cand_b, cand_a): self.head2head_count(cand_b, cand_a),\n            }\n            max_pair = max(zip(head_2_head_dict.values(), head_2_head_dict.keys()))\n            pairwise_dict[max_pair[1]] = abs(\n                self.head2head_count(cand_a, cand_b)\n                - self.head2head_count(cand_b, cand_a)\n            )\n\n            ## would display x:y instead of abs(x-y)\n            # winner, loser = max_pair[1]\n            # pairwise_dict[max_pair[1]] = f\"{head_2_head_dict[(winner, loser)]}: \\\n            # {head_2_head_dict[(loser, winner)]}\"\n\n        return pairwise_dict\n\n    def build_graph(self) -&gt; nx.DiGraph:\n        \"\"\"\n        Builds the networkx pairwise comparison graph.\n\n        Returns:\n            The networkx digraph representing the pairwise comparison graph.\n        \"\"\"\n        G = nx.DiGraph()\n        G.add_nodes_from(self.candidates)\n        for e in self.pairwise_dict.keys():\n            G.add_edge(e[0], e[1], weight=self.pairwise_dict[e])\n        return G\n\n    def draw(self, outfile=None):\n        \"\"\"\n        Draws pairwise comparison graph.\n\n        Args:\n            outfile (str): The filepath to save the graph. Defaults to not saving.\n        \"\"\"\n        G = self.pairwise_graph\n\n        pos = nx.circular_layout(G)\n        nx.draw_networkx(\n            G,\n            pos,\n            with_labels=True,\n            node_size=500,\n            node_color=\"skyblue\",\n            edgelist=list(),\n        )\n        nx.draw_networkx_edges(\n            G,\n            pos,\n            edgelist=G.edges,\n            width=1.5,\n            edge_color=\"b\",\n            arrows=True,\n            alpha=1,\n            node_size=1000,\n            arrowsize=25,\n        )\n        edge_labels = {(i, j): G[i][j][\"weight\"] for i, j in G.edges()}\n        nx.draw_networkx_edge_labels(\n            G, pos, edge_labels=edge_labels, label_pos=1 / 3, font_size=10\n        )\n        # Out stuff\n        if outfile is not None:\n            plt.savefig(outfile)\n        else:\n            plt.show()\n        plt.close()\n\n    # More complicated Requests\n    def has_condorcet_winner(self) -&gt; bool:\n        \"\"\"\n        Checks if graph has a condorcet winner.\n\n        Returns:\n            True if condorcet winner exists, False otherwise.\n        \"\"\"\n        dominating_tiers = self.dominating_tiers()\n        if len(dominating_tiers[0]) == 1:\n            return True\n        return False\n\n    def get_condorcet_winner(self) -&gt; str:\n        \"\"\"\n        Returns the condorcet winner. Raises a ValueError if no condorcet winner.\n\n        Returns:\n            The condorcet winner.\n        \"\"\"\n\n        if self.has_condorcet_winner():\n            return list(self.dominating_tiers()[0])[0]\n\n        else:\n            raise ValueError(\"There is no condorcet winner.\")\n\n    @cache\n    def dominating_tiers(self) -&gt; list[set]:\n        \"\"\"\n        Finds dominating tiers within an election.\n\n        Returns:\n            A list of dominating tiers.\n        \"\"\"\n        beat_set_size_dict = {}\n        for i, cand in enumerate(self.candidates):\n            beat_set = set()\n            for j, other_cand in enumerate(self.candidates):\n                if i != j:\n                    if nx.has_path(self.pairwise_graph, cand, other_cand):\n                        beat_set.add(other_cand)\n            beat_set_size_dict[cand] = len(beat_set)\n\n        # We want to return candidates sorted and grouped by beat set size\n        tier_dict: dict = {}\n        for k, v in beat_set_size_dict.items():\n            if v in tier_dict.keys():\n                tier_dict[v].add(k)\n            else:\n                tier_dict[v] = {k}\n        tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n        return tier_list\n\n    def has_condorcet_cycles(self) -&gt; bool:\n        \"\"\"\n        Checks if graph has any condorcet cycles, which we define as any cycle of length\n            greater than 2 in the graph.\n\n        Returns:\n            True if condorcet cycles exists, False otherwise.\n        \"\"\"\n\n        if len(self.get_condorcet_cycles()) &gt; 0:\n            return True\n\n        else:\n            return False\n\n    @cache\n    def get_condorcet_cycles(self) -&gt; list:\n        \"\"\"\n        Returns a list of condorcet cycles in the graph, which we define as any cycle of length\n            greater than 2.\n\n        Returns:\n            List of condorcet cycles sorted by length.\n        \"\"\"\n\n        G = self.pairwise_graph\n        list_of_cycles = nx.recursive_simple_cycles(G)\n        return sorted(list_of_cycles, key=lambda x: len(x))\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.ballot_fill","title":"<code>ballot_fill(profile, ballot_length)</code>","text":"<p>Fills incomplete ballots for pairwise comparison.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>PreferenceProfile to fill.</p> required <code>ballot_length</code> <code>int</code> <p>How long a ballot is.</p> required <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>A PreferenceProfile with incomplete ballots filled in.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def ballot_fill(self, profile: PreferenceProfile, ballot_length: int):\n    \"\"\"\n    Fills incomplete ballots for pairwise comparison.\n\n    Args:\n        profile: PreferenceProfile to fill.\n        ballot_length: How long a ballot is.\n\n    Returns:\n        PreferenceProfile (PreferenceProfile): A PreferenceProfile with incomplete\n            ballots filled in.\n    \"\"\"\n    cand_list = [{cand} for cand in profile.get_candidates()]\n    updated_ballot_list = []\n\n    for ballot in profile.get_ballots():\n        if len(ballot.ranking) &lt; ballot_length:\n            missing_cands = [\n                cand for cand in cand_list if cand not in ballot.ranking\n            ]\n            missing_cands_perms = list(\n                permutations(missing_cands, len(missing_cands))\n            )\n            frac_freq = ballot.weight / (len(missing_cands_perms))\n            for perm in missing_cands_perms:\n                updated_rank = ballot.ranking + tuple([frozenset(c) for c in perm])\n                updated_ballot = Ballot(\n                    ranking=updated_rank, weight=Fraction(frac_freq, 1)\n                )\n                updated_ballot_list.append(updated_ballot)\n        else:\n            updated_ballot_list.append(ballot)\n    return PreferenceProfile(ballots=updated_ballot_list)\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.build_graph","title":"<code>build_graph()</code>","text":"<p>Builds the networkx pairwise comparison graph.</p> <p>Returns:</p> Type Description <code>DiGraph</code> <p>The networkx digraph representing the pairwise comparison graph.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def build_graph(self) -&gt; nx.DiGraph:\n    \"\"\"\n    Builds the networkx pairwise comparison graph.\n\n    Returns:\n        The networkx digraph representing the pairwise comparison graph.\n    \"\"\"\n    G = nx.DiGraph()\n    G.add_nodes_from(self.candidates)\n    for e in self.pairwise_dict.keys():\n        G.add_edge(e[0], e[1], weight=self.pairwise_dict[e])\n    return G\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.compute_pairwise_dict","title":"<code>compute_pairwise_dict()</code>","text":"<p>Constructs dictionary where keys are tuples (cand_a, cand_b) containing two candidates and values is the frequency cand_a is preferred to cand_b.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys = (cand_a, cand_b) and values = frequency cand_a is preferred to cand_b.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def compute_pairwise_dict(self) -&gt; dict:\n    \"\"\"\n    Constructs dictionary where keys are tuples (cand_a, cand_b) containing\n    two candidates and values is the frequency cand_a is preferred to\n    cand_b.\n\n    Returns:\n        A dictionary with keys = (cand_a, cand_b) and values = frequency cand_a is preferred\n            to cand_b.\n    \"\"\"\n    pairwise_dict = {}  # {(cand_a, cand_b): freq cand_a is preferred over cand_b}\n    cand_pairs = combinations(self.candidates, 2)\n\n    for pair in cand_pairs:\n        cand_a, cand_b = pair[0], pair[1]\n        head_2_head_dict = {\n            (cand_a, cand_b): self.head2head_count(cand_a, cand_b),\n            (cand_b, cand_a): self.head2head_count(cand_b, cand_a),\n        }\n        max_pair = max(zip(head_2_head_dict.values(), head_2_head_dict.keys()))\n        pairwise_dict[max_pair[1]] = abs(\n            self.head2head_count(cand_a, cand_b)\n            - self.head2head_count(cand_b, cand_a)\n        )\n\n        ## would display x:y instead of abs(x-y)\n        # winner, loser = max_pair[1]\n        # pairwise_dict[max_pair[1]] = f\"{head_2_head_dict[(winner, loser)]}: \\\n        # {head_2_head_dict[(loser, winner)]}\"\n\n    return pairwise_dict\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.dominating_tiers","title":"<code>dominating_tiers()</code>  <code>cached</code>","text":"<p>Finds dominating tiers within an election.</p> <p>Returns:</p> Type Description <code>list[set]</code> <p>A list of dominating tiers.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>@cache\ndef dominating_tiers(self) -&gt; list[set]:\n    \"\"\"\n    Finds dominating tiers within an election.\n\n    Returns:\n        A list of dominating tiers.\n    \"\"\"\n    beat_set_size_dict = {}\n    for i, cand in enumerate(self.candidates):\n        beat_set = set()\n        for j, other_cand in enumerate(self.candidates):\n            if i != j:\n                if nx.has_path(self.pairwise_graph, cand, other_cand):\n                    beat_set.add(other_cand)\n        beat_set_size_dict[cand] = len(beat_set)\n\n    # We want to return candidates sorted and grouped by beat set size\n    tier_dict: dict = {}\n    for k, v in beat_set_size_dict.items():\n        if v in tier_dict.keys():\n            tier_dict[v].add(k)\n        else:\n            tier_dict[v] = {k}\n    tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n    return tier_list\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.draw","title":"<code>draw(outfile=None)</code>","text":"<p>Draws pairwise comparison graph.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The filepath to save the graph. Defaults to not saving.</p> <code>None</code> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def draw(self, outfile=None):\n    \"\"\"\n    Draws pairwise comparison graph.\n\n    Args:\n        outfile (str): The filepath to save the graph. Defaults to not saving.\n    \"\"\"\n    G = self.pairwise_graph\n\n    pos = nx.circular_layout(G)\n    nx.draw_networkx(\n        G,\n        pos,\n        with_labels=True,\n        node_size=500,\n        node_color=\"skyblue\",\n        edgelist=list(),\n    )\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=G.edges,\n        width=1.5,\n        edge_color=\"b\",\n        arrows=True,\n        alpha=1,\n        node_size=1000,\n        arrowsize=25,\n    )\n    edge_labels = {(i, j): G[i][j][\"weight\"] for i, j in G.edges()}\n    nx.draw_networkx_edge_labels(\n        G, pos, edge_labels=edge_labels, label_pos=1 / 3, font_size=10\n    )\n    # Out stuff\n    if outfile is not None:\n        plt.savefig(outfile)\n    else:\n        plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.get_condorcet_cycles","title":"<code>get_condorcet_cycles()</code>  <code>cached</code>","text":"<p>Returns a list of condorcet cycles in the graph, which we define as any cycle of length     greater than 2.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of condorcet cycles sorted by length.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>@cache\ndef get_condorcet_cycles(self) -&gt; list:\n    \"\"\"\n    Returns a list of condorcet cycles in the graph, which we define as any cycle of length\n        greater than 2.\n\n    Returns:\n        List of condorcet cycles sorted by length.\n    \"\"\"\n\n    G = self.pairwise_graph\n    list_of_cycles = nx.recursive_simple_cycles(G)\n    return sorted(list_of_cycles, key=lambda x: len(x))\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.get_condorcet_winner","title":"<code>get_condorcet_winner()</code>","text":"<p>Returns the condorcet winner. Raises a ValueError if no condorcet winner.</p> <p>Returns:</p> Type Description <code>str</code> <p>The condorcet winner.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def get_condorcet_winner(self) -&gt; str:\n    \"\"\"\n    Returns the condorcet winner. Raises a ValueError if no condorcet winner.\n\n    Returns:\n        The condorcet winner.\n    \"\"\"\n\n    if self.has_condorcet_winner():\n        return list(self.dominating_tiers()[0])[0]\n\n    else:\n        raise ValueError(\"There is no condorcet winner.\")\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.has_condorcet_cycles","title":"<code>has_condorcet_cycles()</code>","text":"<p>Checks if graph has any condorcet cycles, which we define as any cycle of length     greater than 2 in the graph.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if condorcet cycles exists, False otherwise.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def has_condorcet_cycles(self) -&gt; bool:\n    \"\"\"\n    Checks if graph has any condorcet cycles, which we define as any cycle of length\n        greater than 2 in the graph.\n\n    Returns:\n        True if condorcet cycles exists, False otherwise.\n    \"\"\"\n\n    if len(self.get_condorcet_cycles()) &gt; 0:\n        return True\n\n    else:\n        return False\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.has_condorcet_winner","title":"<code>has_condorcet_winner()</code>","text":"<p>Checks if graph has a condorcet winner.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if condorcet winner exists, False otherwise.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def has_condorcet_winner(self) -&gt; bool:\n    \"\"\"\n    Checks if graph has a condorcet winner.\n\n    Returns:\n        True if condorcet winner exists, False otherwise.\n    \"\"\"\n    dominating_tiers = self.dominating_tiers()\n    if len(dominating_tiers[0]) == 1:\n        return True\n    return False\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.head2head_count","title":"<code>head2head_count(cand1, cand2)</code>","text":"<p>Counts head to head comparisons between two candidates. Note that the given order of the candidates matters here.</p> <p>Parameters:</p> Name Type Description Default <code>cand1</code> <code>str</code> <p>The first candidate to compare.</p> required <code>cand2</code> <code>str</code> <p>The second candidate to compare.</p> required <p>Returns:</p> Type Description <code>Fraction</code> <p>A count of the number of times cand1 is preferred to cand2.</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def head2head_count(self, cand1, cand2) -&gt; Fraction:\n    \"\"\"\n    Counts head to head comparisons between two candidates. Note that the given order\n    of the candidates matters here.\n\n    Args:\n        cand1 (str): The first candidate to compare.\n        cand2 (str): The second candidate to compare.\n\n    Returns:\n        A count of the number of times cand1 is preferred to cand2.\n    \"\"\"\n    count = 0\n    ballots_list = self.profile.get_ballots()\n    for ballot in ballots_list:\n        rank_list = ballot.ranking\n        for s in rank_list:\n            if cand1 in s:\n                count += ballot.weight\n                break\n            elif cand2 in s:\n                break\n    return Fraction(count)\n</code></pre>"},{"location":"api/#cvr-loaders","title":"CVR Loaders","text":""},{"location":"api/#votekit.cvr_loaders.load_csv","title":"<code>load_csv(fpath, rank_cols=[], *, weight_col=None, delimiter=None, id_col=None)</code>","text":"<p>Given a file path, loads cast vote records (cvr) with ranks as columns and voters as rows. Empty cells are treated as None.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>Path to cvr file.</p> required <code>rank_cols</code> <code>list[int]</code> <p>List of column indexes that contain rankings. Indexing starts from 0,         in order from top to bottom rank.         Default implies that all columns contain rankings.</p> <code>[]</code> <code>weight_col</code> <code>Optional[int]</code> <p>The column position for ballot weights.</p> <code>None</code> <code>delimiter</code> <code>Optional[str]</code> <p>The character that breaks up rows.</p> <code>None</code> <code>id_col</code> <code>Optional[int]</code> <p>Index for the column with voter ids.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If fpath is invalid.</p> <code>EmptyDataError</code> <p>If dataset is empty.</p> <code>ValueError</code> <p>If the voter id column has missing values.</p> <code>DataError</code> <p>If the voter id column has duplicate values.</p> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A PreferenceProfile that represents all the ballots in the election.</p> Source code in <code>src/votekit/cvr_loaders.py</code> <pre><code>def load_csv(\n    fpath: str,\n    rank_cols: list[int] = [],\n    *,\n    weight_col: Optional[int] = None,\n    delimiter: Optional[str] = None,\n    id_col: Optional[int] = None,\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a file path, loads cast vote records (cvr) with ranks as columns and voters as rows.\n    Empty cells are treated as None.\n\n    Args:\n        fpath: Path to cvr file.\n        rank_cols: List of column indexes that contain rankings. Indexing starts from 0,\n                    in order from top to bottom rank.\n                    Default implies that all columns contain rankings.\n        weight_col: The column position for ballot weights.\n        delimiter: The character that breaks up rows.\n        id_col: Index for the column with voter ids.\n\n    Raises:\n        FileNotFoundError: If fpath is invalid.\n        EmptyDataError: If dataset is empty.\n        ValueError: If the voter id column has missing values.\n        DataError: If the voter id column has duplicate values.\n\n    Returns:\n        A PreferenceProfile that represents all the ballots in the election.\n    \"\"\"\n    if not os.path.isfile(fpath):\n        raise FileNotFoundError(f\"File with path {fpath} cannot be found\")\n\n    cvr_path = pathlib.Path(fpath)\n    df = pd.read_csv(\n        cvr_path,\n        on_bad_lines=\"error\",\n        encoding=\"utf8\",\n        index_col=False,\n        delimiter=delimiter,\n    )\n\n    if df.empty:\n        raise EmptyDataError(\"Dataset cannot be empty\")\n    if id_col is not None and df.iloc[:, id_col].isnull().values.any():  # type: ignore\n        raise ValueError(f\"Missing value(s) in column at index {id_col}\")\n    if id_col is not None and not df.iloc[:, id_col].is_unique:\n        raise DataError(f\"Duplicate value(s) in column at index {id_col}\")\n\n    if rank_cols:\n        if id_col is not None:\n            df = df.iloc[:, rank_cols + [id_col]]\n        else:\n            df = df.iloc[:, rank_cols]\n\n    ranks = list(df.columns)\n    if id_col is not None:\n        ranks.remove(df.columns[id_col])\n    grouped = df.groupby(ranks, dropna=False)\n    ballots = []\n\n    for group, group_df in grouped:\n        ranking = tuple(\n            [frozenset({None}) if pd.isnull(c) else frozenset({c}) for c in group]\n        )\n\n        voter_set = None\n        if id_col is not None:\n            voter_set = set(group_df.iloc[:, id_col])\n        weight = len(group_df)\n        if weight_col is not None:\n            weight = sum(group_df.iloc[:, weight_col])\n        b = Ballot(ranking=ranking, weight=Fraction(weight), voter_set=voter_set)\n        ballots.append(b)\n\n    return PreferenceProfile(ballots=ballots)\n</code></pre>"},{"location":"api/#votekit.cvr_loaders.load_scottish","title":"<code>load_scottish(fpath)</code>","text":"<p>Given a file path, loads cvr from format used for Scottish election data.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>Path to cvr file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If fpath is invalid.</p> <code>EmptyDataError</code> <p>If dataset is empty.</p> <code>DataError</code> <p>If there is missing or incorrect metadata or candidate data.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple (PreferenceProfile, seats) representing the election and the     number of seats in the election.</p> Source code in <code>src/votekit/cvr_loaders.py</code> <pre><code>def load_scottish(fpath: str) -&gt; tuple[PreferenceProfile, int]:\n    \"\"\"\n    Given a file path, loads cvr from format used for Scottish election data.\n\n    Args:\n        fpath: Path to cvr file.\n\n    Raises:\n        FileNotFoundError: If fpath is invalid.\n        EmptyDataError: If dataset is empty.\n        DataError: If there is missing or incorrect metadata or candidate data.\n\n    Returns:\n        (tuple): A tuple (PreferenceProfile, seats) representing the election and the\n                number of seats in the election.\n    \"\"\"\n    ballots = []\n    names = []\n    name_map = {}\n    numbers = True\n    cands_included = False\n\n    if not os.path.isfile(fpath):\n        raise FileNotFoundError(f\"File with path {fpath} cannot be found\")\n    if os.path.getsize(fpath) == 0:\n        raise EmptyDataError(\"Dataset cannot be empty\")\n\n    with open(fpath, \"r\") as file:\n        for i, line in enumerate(file):\n            s = line.rstrip(\"\\n\").rstrip()\n            if i == 0:\n                # first number is number of candidates, second is number of seats to elect\n                metadata = [int(data) for data in s.split(\" \")]\n                if len(metadata) != 2:\n                    raise DataError(\n                        \"metadata (first line) should have two parameters\"\n                        \" (number of candidates, number of seats)\"\n                    )\n                seats = metadata[1]\n            # read in ballots, cleaning out rankings labeled '0' (designating end of line)\n            elif numbers:\n                ballot = [int(vote) for vote in s.split(\" \")]\n                num_votes = ballot[0]\n                # ballots terminate with a single row with the character '0'\n                if num_votes == 0:\n                    numbers = False\n                else:\n                    ranking = [rank for rank in list(ballot[1:]) if rank != 0]\n                    b = (ranking, num_votes)\n                    ballots.append(b)  # this is converted to the PP format later\n            # read in candidates\n            elif \"(\" in s:\n                cands_included = True\n                name_parts = s.strip('\"').split(\" \")\n                first_name = \" \".join(name_parts[:-2])\n                last_name = name_parts[-2]\n                party = name_parts[-1].strip(\"(\").strip(\")\")\n                names.append(str((first_name, last_name, party)))\n            else:\n                if len(names) != metadata[0]:\n                    err_message = (\n                        f\"Number of candidates listed, {len(names)},\" + f\" differs from\"\n                        f\"number of candidates recorded in metadata, {metadata[0]}\"\n                    )\n                    raise DataError(err_message)\n                # read in election location (do we need this?)\n                # location = s.strip(\"\\\"\")\n                if not cands_included:\n                    raise DataError(\"Candidates missing from file\")\n                # map candidate numbers onto their names and convert ballots to PP format\n                for i, name in enumerate(names):\n                    name_map[i + 1] = name\n                clean_ballots = [\n                    Ballot(\n                        ranking=tuple(\n                            [frozenset({name_map[cand]}) for cand in ballot[0]]\n                        ),\n                        weight=Fraction(ballot[1]),\n                    )\n                    for ballot in ballots\n                ]\n\n        return PreferenceProfile(ballots=clean_ballots, candidates=names), seats\n</code></pre>"},{"location":"api/#ballot-generators","title":"Ballot Generators","text":""},{"location":"api/#votekit.ballot_generator.BallotGenerator","title":"<code>BallotGenerator</code>","text":"<p>Base class for ballot generation models that use the candidate simplex (e.g. Plackett-Luce, Bradley-Terry, etc.).</p> <p>Attributes</p> <p><code>candidates</code> :   list of candidates in the election.</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries mapping of bloc to cohesion parameters.     (ex. {bloc_1: {bloc_1: .7, bloc_2: .2, bloc_3:.1}})</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: voter proportion}).</p> Note <ul> <li>Voter proportion for blocs must sum to 1.</li> <li>Preference interval for candidates must sum to 1.</li> <li>Must have same blocs in <code>pref_intervals_by_bloc</code> and <code>bloc_voter_prop</code>.</li> </ul> <p>Methods</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class BallotGenerator:\n    \"\"\"\n    Base class for ballot generation models that use the candidate simplex\n    (e.g. Plackett-Luce, Bradley-Terry, etc.).\n\n    **Attributes**\n\n    `candidates`\n    :   list of candidates in the election.\n\n    `cohesion_parameters`\n    : dictionary of dictionaries mapping of bloc to cohesion parameters.\n        (ex. {bloc_1: {bloc_1: .7, bloc_2: .2, bloc_3:.1}})\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: voter proportion}).\n\n\n    ???+ note\n        * Voter proportion for blocs must sum to 1.\n        * Preference interval for candidates must sum to 1.\n        * Must have same blocs in `pref_intervals_by_bloc` and `bloc_voter_prop`.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        **kwargs,\n    ):\n        if \"candidates\" not in kwargs and \"slate_to_candidates\" not in kwargs:\n            raise ValueError(\n                \"At least one of candidates or slate_to_candidates must be provided.\"\n            )\n\n        if \"candidates\" in kwargs:\n            self.candidates = kwargs[\"candidates\"]\n\n        if \"slate_to_candidates\" in kwargs:\n            self.slate_to_candidates = kwargs[\"slate_to_candidates\"]\n            self.candidates = [\n                c for c_list in self.slate_to_candidates.values() for c in c_list\n            ]\n\n        nec_parameters = [\n            \"pref_intervals_by_bloc\",\n            \"cohesion_parameters\",\n            \"bloc_voter_prop\",\n        ]\n\n        if any(x in kwargs for x in nec_parameters):\n            if not all(x in kwargs for x in nec_parameters):\n                raise ValueError(\n                    f\"If one of {nec_parameters} is provided, all must be provided.\"\n                )\n\n            bloc_voter_prop = kwargs[\"bloc_voter_prop\"]\n            pref_intervals_by_bloc = kwargs[\"pref_intervals_by_bloc\"]\n            cohesion_parameters = kwargs[\"cohesion_parameters\"]\n\n            if round(sum(bloc_voter_prop.values()), 8) != 1.0:\n                raise ValueError(\"Voter proportion for blocs must sum to 1\")\n\n            if bloc_voter_prop.keys() != pref_intervals_by_bloc.keys():\n                raise ValueError(\n                    \"Blocs are not the same between bloc_voter_prop and pref_intervals_by_bloc.\"\n                )\n\n            if bloc_voter_prop.keys() != cohesion_parameters.keys():\n                raise ValueError(\n                    \"Blocs are not the same between bloc_voter_prop and cohesion_parameters.\"\n                )\n\n            if pref_intervals_by_bloc.keys() != cohesion_parameters.keys():\n                raise ValueError(\n                    \"Blocs are not the same between pref_intervals_by_bloc and cohesion_parameters.\"\n                )\n\n            for bloc, cohesion_parameter_dict in cohesion_parameters.items():\n                if round(sum(cohesion_parameter_dict.values()), 8) != 1.0:\n                    raise ValueError(\n                        f\"Cohesion parameters for bloc {bloc} must sum to 1.\"\n                    )\n\n            self.pref_intervals_by_bloc = pref_intervals_by_bloc\n            self.bloc_voter_prop = bloc_voter_prop\n            self.blocs = list(self.bloc_voter_prop.keys())\n            self.cohesion_parameters = cohesion_parameters\n\n    @classmethod\n    def from_params(\n        cls,\n        slate_to_candidates: dict,\n        bloc_voter_prop: dict,\n        cohesion_parameters: dict,\n        alphas: dict,\n        **data,\n    ):\n        \"\"\"\n        Initializes a BallotGenerator by constructing a preference interval\n        from parameters; the prior parameters (if inputted) will be overwritten.\n\n        Args:\n            slate_to_candidates (dict): A mapping of blocs to candidates\n                (ex. {bloc: [candidate]})\n            bloc_voter_prop (dict): A mapping of the percentage of total voters\n                 per bloc (ex. {bloc: 0.7})\n            cohesion_parameters (dict): Cohension factors for each bloc (ex. {bloc_1: {bloc_1: .9,\n                                                                                        bloc_2:.1})\n            alphas (dict): Alpha for the Dirichlet distribution of each bloc\n                            (ex. {bloc: {bloc: 1, opposing_bloc: 1/2}}).\n\n        Raises:\n            ValueError: If the voter proportion for blocs don't sum to 1.\n            ValueError: Blocs are not the same.\n\n        Returns:\n            (BallotGenerator): Initialized ballot generator.\n\n        ???+ note\n            * Voter proportion for blocs must sum to 1.\n            * Each cohesion parameter must be in the interval [0,1].\n            * Dirichlet parameters are in the interval $(0,\\infty)$.\n        \"\"\"\n        if round(sum(bloc_voter_prop.values()), 8) != 1.0:\n            raise ValueError(\"Voter proportion for blocs must sum to 1\")\n\n        if slate_to_candidates.keys() != bloc_voter_prop.keys():\n            raise ValueError(\"Blocs are not the same\")\n\n        pref_intervals_by_bloc = {}\n        for current_bloc in bloc_voter_prop:\n            intervals = {}\n            for b in bloc_voter_prop:\n                interval = PreferenceInterval.from_dirichlet(\n                    candidates=slate_to_candidates[b], alpha=alphas[current_bloc][b]\n                )\n                intervals[b] = interval\n\n            pref_intervals_by_bloc[current_bloc] = intervals\n\n        if \"candidates\" not in data:\n            cands = [cand for cands in slate_to_candidates.values() for cand in cands]\n            data[\"candidates\"] = cands\n\n        data[\"pref_intervals_by_bloc\"] = pref_intervals_by_bloc\n        data[\"bloc_voter_prop\"] = bloc_voter_prop\n        data[\"cohesion_parameters\"] = cohesion_parameters\n\n        if cls in [\n            AlternatingCrossover,\n            slate_PlackettLuce,\n            slate_BradleyTerry,\n            CambridgeSampler,\n        ]:\n            generator = cls(\n                slate_to_candidates=slate_to_candidates,\n                **data,\n            )\n\n        else:\n            generator = cls(**data)\n\n        return generator\n\n    @abstractmethod\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple, dict]:\n        \"\"\"\n        Generates a `PreferenceProfile`.\n\n        Args:\n            number_of_ballots (int): Number of ballots to generate.\n            by_bloc (bool): True if you want a tuple (pp_by_bloc, pp), which is a dictionary of\n                            PreferenceProfiles with keys = blocs and the aggregated profile.\n                    False if you want the aggregated profile. Defaults to False.\n\n        Returns:\n            (PreferenceProfile): A generated `PreferenceProfile`.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def _round_num(num: float) -&gt; int:\n        \"\"\"\n        Rounds up or down a float randomly.\n\n        Args:\n            num (float): Number to round.\n\n        Returns:\n            int: A whole number.\n        \"\"\"\n        rand = np.random.random()\n        return math.ceil(num) if rand &gt; 0.5 else math.floor(num)\n\n    @staticmethod\n    def ballot_pool_to_profile(ballot_pool, candidates) -&gt; PreferenceProfile:\n        \"\"\"\n        Given a list of ballots and candidates, convert them into a `PreferenceProfile.`\n\n        Args:\n            ballot_pool (list of tuple): A list of ballots, where each ballot is a tuple\n                    of candidates indicating their ranking from top to bottom.\n            candidates (list): A list of candidates.\n\n        Returns:\n            (PreferenceProfile): A PreferenceProfile representing the ballots in the election.\n        \"\"\"\n        ranking_counts: dict[tuple, int] = {}\n        ballot_list: list[Ballot] = []\n\n        for ranking in ballot_pool:\n            tuple_rank = tuple(ranking)\n            ranking_counts[tuple_rank] = (\n                ranking_counts[tuple_rank] + 1 if tuple_rank in ranking_counts else 1\n            )\n\n        for ranking, count in ranking_counts.items():\n            rank = tuple([frozenset([cand]) for cand in ranking])\n            b = Ballot(ranking=rank, weight=Fraction(count))\n            ballot_list.append(b)\n\n        return PreferenceProfile(ballots=ballot_list, candidates=candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.ballot_pool_to_profile","title":"<code>ballot_pool_to_profile(ballot_pool, candidates)</code>  <code>staticmethod</code>","text":"<p>Given a list of ballots and candidates, convert them into a <code>PreferenceProfile.</code></p> <p>Parameters:</p> Name Type Description Default <code>ballot_pool</code> <code>list of tuple</code> <p>A list of ballots, where each ballot is a tuple     of candidates indicating their ranking from top to bottom.</p> required <code>candidates</code> <code>list</code> <p>A list of candidates.</p> required <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A PreferenceProfile representing the ballots in the election.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@staticmethod\ndef ballot_pool_to_profile(ballot_pool, candidates) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a list of ballots and candidates, convert them into a `PreferenceProfile.`\n\n    Args:\n        ballot_pool (list of tuple): A list of ballots, where each ballot is a tuple\n                of candidates indicating their ranking from top to bottom.\n        candidates (list): A list of candidates.\n\n    Returns:\n        (PreferenceProfile): A PreferenceProfile representing the ballots in the election.\n    \"\"\"\n    ranking_counts: dict[tuple, int] = {}\n    ballot_list: list[Ballot] = []\n\n    for ranking in ballot_pool:\n        tuple_rank = tuple(ranking)\n        ranking_counts[tuple_rank] = (\n            ranking_counts[tuple_rank] + 1 if tuple_rank in ranking_counts else 1\n        )\n\n    for ranking, count in ranking_counts.items():\n        rank = tuple([frozenset([cand]) for cand in ranking])\n        b = Ballot(ranking=rank, weight=Fraction(count))\n        ballot_list.append(b)\n\n    return PreferenceProfile(ballots=ballot_list, candidates=candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.from_params","title":"<code>from_params(slate_to_candidates, bloc_voter_prop, cohesion_parameters, alphas, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a BallotGenerator by constructing a preference interval from parameters; the prior parameters (if inputted) will be overwritten.</p> <p>Parameters:</p> Name Type Description Default <code>slate_to_candidates</code> <code>dict</code> <p>A mapping of blocs to candidates (ex. {bloc: [candidate]})</p> required <code>bloc_voter_prop</code> <code>dict</code> <p>A mapping of the percentage of total voters  per bloc (ex. {bloc: 0.7})</p> required <code>cohesion_parameters</code> <code>dict</code> <p>Cohension factors for each bloc (ex. {bloc_1: {bloc_1: .9,                                                                         bloc_2:.1})</p> required <code>alphas</code> <code>dict</code> <p>Alpha for the Dirichlet distribution of each bloc             (ex. {bloc: {bloc: 1, opposing_bloc: 1/2}}).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the voter proportion for blocs don't sum to 1.</p> <code>ValueError</code> <p>Blocs are not the same.</p> <p>Returns:</p> Type Description <code>BallotGenerator</code> <p>Initialized ballot generator.</p> Note <ul> <li>Voter proportion for blocs must sum to 1.</li> <li>Each cohesion parameter must be in the interval [0,1].</li> <li>Dirichlet parameters are in the interval \\((0,\\infty)\\).</li> </ul> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_params(\n    cls,\n    slate_to_candidates: dict,\n    bloc_voter_prop: dict,\n    cohesion_parameters: dict,\n    alphas: dict,\n    **data,\n):\n    \"\"\"\n    Initializes a BallotGenerator by constructing a preference interval\n    from parameters; the prior parameters (if inputted) will be overwritten.\n\n    Args:\n        slate_to_candidates (dict): A mapping of blocs to candidates\n            (ex. {bloc: [candidate]})\n        bloc_voter_prop (dict): A mapping of the percentage of total voters\n             per bloc (ex. {bloc: 0.7})\n        cohesion_parameters (dict): Cohension factors for each bloc (ex. {bloc_1: {bloc_1: .9,\n                                                                                    bloc_2:.1})\n        alphas (dict): Alpha for the Dirichlet distribution of each bloc\n                        (ex. {bloc: {bloc: 1, opposing_bloc: 1/2}}).\n\n    Raises:\n        ValueError: If the voter proportion for blocs don't sum to 1.\n        ValueError: Blocs are not the same.\n\n    Returns:\n        (BallotGenerator): Initialized ballot generator.\n\n    ???+ note\n        * Voter proportion for blocs must sum to 1.\n        * Each cohesion parameter must be in the interval [0,1].\n        * Dirichlet parameters are in the interval $(0,\\infty)$.\n    \"\"\"\n    if round(sum(bloc_voter_prop.values()), 8) != 1.0:\n        raise ValueError(\"Voter proportion for blocs must sum to 1\")\n\n    if slate_to_candidates.keys() != bloc_voter_prop.keys():\n        raise ValueError(\"Blocs are not the same\")\n\n    pref_intervals_by_bloc = {}\n    for current_bloc in bloc_voter_prop:\n        intervals = {}\n        for b in bloc_voter_prop:\n            interval = PreferenceInterval.from_dirichlet(\n                candidates=slate_to_candidates[b], alpha=alphas[current_bloc][b]\n            )\n            intervals[b] = interval\n\n        pref_intervals_by_bloc[current_bloc] = intervals\n\n    if \"candidates\" not in data:\n        cands = [cand for cands in slate_to_candidates.values() for cand in cands]\n        data[\"candidates\"] = cands\n\n    data[\"pref_intervals_by_bloc\"] = pref_intervals_by_bloc\n    data[\"bloc_voter_prop\"] = bloc_voter_prop\n    data[\"cohesion_parameters\"] = cohesion_parameters\n\n    if cls in [\n        AlternatingCrossover,\n        slate_PlackettLuce,\n        slate_BradleyTerry,\n        CambridgeSampler,\n    ]:\n        generator = cls(\n            slate_to_candidates=slate_to_candidates,\n            **data,\n        )\n\n    else:\n        generator = cls(**data)\n\n    return generator\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.generate_profile","title":"<code>generate_profile(number_of_ballots, by_bloc=False)</code>  <code>abstractmethod</code>","text":"<p>Generates a <code>PreferenceProfile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_ballots</code> <code>int</code> <p>Number of ballots to generate.</p> required <code>by_bloc</code> <code>bool</code> <p>True if you want a tuple (pp_by_bloc, pp), which is a dictionary of             PreferenceProfiles with keys = blocs and the aggregated profile.     False if you want the aggregated profile. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A generated <code>PreferenceProfile</code>.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@abstractmethod\ndef generate_profile(\n    self, number_of_ballots: int, by_bloc: bool = False\n) -&gt; Union[PreferenceProfile, Tuple, dict]:\n    \"\"\"\n    Generates a `PreferenceProfile`.\n\n    Args:\n        number_of_ballots (int): Number of ballots to generate.\n        by_bloc (bool): True if you want a tuple (pp_by_bloc, pp), which is a dictionary of\n                        PreferenceProfiles with keys = blocs and the aggregated profile.\n                False if you want the aggregated profile. Defaults to False.\n\n    Returns:\n        (PreferenceProfile): A generated `PreferenceProfile`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex","title":"<code>BallotSimplex</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Base class for ballot generation models that use the ballot simplex (e.g. ImpartialCulture, ImpartialAnonymousCulture).</p> <p>Attributes</p> <p><code>alpha</code> :   (float) alpha parameter for ballot simplex. Defaults to None.</p> <p><code>point</code> :   dictionary representing a point in the ballot simplex with candidate as     keys and electoral support as values. Defaults to None.</p> Note <p>Point or alpha arguments must be included to initialize.</p> <p>Methods</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class BallotSimplex(BallotGenerator):\n    \"\"\"\n    Base class for ballot generation models that use the ballot simplex\n    (e.g. ImpartialCulture, ImpartialAnonymousCulture).\n\n    **Attributes**\n\n    `alpha`\n    :   (float) alpha parameter for ballot simplex. Defaults to None.\n\n    `point`\n    :   dictionary representing a point in the ballot simplex with candidate as\n        keys and electoral support as values. Defaults to None.\n\n    ???+ note\n\n        Point or alpha arguments must be included to initialize.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self, alpha: Optional[float] = None, point: Optional[dict] = None, **data\n    ):\n        if alpha is None and point is None:\n            raise AttributeError(\"point or alpha must be initialized\")\n        self.alpha = alpha\n        if alpha == float(\"inf\"):\n            self.alpha = 1e20\n        if alpha == 0:\n            self.alpha = 1e-10\n        self.point = point\n        super().__init__(**data)\n\n    @classmethod\n    def from_point(cls, point: dict, **data):\n        \"\"\"\n        Initializes a Ballot Simplex model from a point in the Dirichlet distribution.\n\n        Args:\n            point (dict): A mapping of candidate to candidate support.\n\n        Raises:\n            ValueError: If the candidate support does not sum to 1.\n\n        Returns:\n            (BallotSimplex): Initialized from point.\n        \"\"\"\n        if sum(point.values()) != 1.0:\n            raise ValueError(\n                f\"probability distribution from point ({point.values()}) does not sum to 1\"\n            )\n        return cls(point=point, **data)\n\n    @classmethod\n    def from_alpha(cls, alpha: float, **data):\n        \"\"\"\n        Initializes a Ballot Simplex model from an alpha value for the Dirichlet\n        distribution.\n\n        Args:\n            alpha (float): An alpha parameter for the Dirichlet distribution.\n\n        Returns:\n            (BallotSimplex): Initialized from alpha.\n        \"\"\"\n\n        return cls(alpha=alpha, **data)\n\n    def generate_profile(\n        self, number_of_ballots, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, dict]:\n        \"\"\"\n        Generates a PreferenceProfile from the ballot simplex.\n        \"\"\"\n\n        perm_set = it.permutations(self.candidates, len(self.candidates))\n\n        perm_rankings = [list(value) for value in perm_set]\n\n        if self.alpha is not None:\n            draw_probabilities = list(\n                np.random.default_rng().dirichlet([self.alpha] * len(perm_rankings))\n            )\n\n        elif self.point:\n            # calculates probabilities for each ranking\n            # using probability distribution for candidate support\n            draw_probabilities = [\n                reduce(\n                    lambda prod, cand: prod * self.point[cand] if self.point else 0,\n                    ranking,\n                    1.0,\n                )\n                for ranking in perm_rankings\n            ]\n            draw_probabilities = [\n                prob / sum(draw_probabilities) for prob in draw_probabilities\n            ]\n\n        indices = np.random.choice(\n            a=len(perm_rankings), size=number_of_ballots, p=draw_probabilities\n        )\n        ballot_pool = [perm_rankings[indices[i]] for i in range(number_of_ballots)]\n\n        return self.ballot_pool_to_profile(ballot_pool, self.candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex.from_alpha","title":"<code>from_alpha(alpha, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a Ballot Simplex model from an alpha value for the Dirichlet distribution.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>An alpha parameter for the Dirichlet distribution.</p> required <p>Returns:</p> Type Description <code>BallotSimplex</code> <p>Initialized from alpha.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_alpha(cls, alpha: float, **data):\n    \"\"\"\n    Initializes a Ballot Simplex model from an alpha value for the Dirichlet\n    distribution.\n\n    Args:\n        alpha (float): An alpha parameter for the Dirichlet distribution.\n\n    Returns:\n        (BallotSimplex): Initialized from alpha.\n    \"\"\"\n\n    return cls(alpha=alpha, **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex.from_point","title":"<code>from_point(point, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a Ballot Simplex model from a point in the Dirichlet distribution.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>dict</code> <p>A mapping of candidate to candidate support.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the candidate support does not sum to 1.</p> <p>Returns:</p> Type Description <code>BallotSimplex</code> <p>Initialized from point.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_point(cls, point: dict, **data):\n    \"\"\"\n    Initializes a Ballot Simplex model from a point in the Dirichlet distribution.\n\n    Args:\n        point (dict): A mapping of candidate to candidate support.\n\n    Raises:\n        ValueError: If the candidate support does not sum to 1.\n\n    Returns:\n        (BallotSimplex): Initialized from point.\n    \"\"\"\n    if sum(point.values()) != 1.0:\n        raise ValueError(\n            f\"probability distribution from point ({point.values()}) does not sum to 1\"\n        )\n    return cls(point=point, **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex.generate_profile","title":"<code>generate_profile(number_of_ballots, by_bloc=False)</code>","text":"<p>Generates a PreferenceProfile from the ballot simplex.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>def generate_profile(\n    self, number_of_ballots, by_bloc: bool = False\n) -&gt; Union[PreferenceProfile, dict]:\n    \"\"\"\n    Generates a PreferenceProfile from the ballot simplex.\n    \"\"\"\n\n    perm_set = it.permutations(self.candidates, len(self.candidates))\n\n    perm_rankings = [list(value) for value in perm_set]\n\n    if self.alpha is not None:\n        draw_probabilities = list(\n            np.random.default_rng().dirichlet([self.alpha] * len(perm_rankings))\n        )\n\n    elif self.point:\n        # calculates probabilities for each ranking\n        # using probability distribution for candidate support\n        draw_probabilities = [\n            reduce(\n                lambda prod, cand: prod * self.point[cand] if self.point else 0,\n                ranking,\n                1.0,\n            )\n            for ranking in perm_rankings\n        ]\n        draw_probabilities = [\n            prob / sum(draw_probabilities) for prob in draw_probabilities\n        ]\n\n    indices = np.random.choice(\n        a=len(perm_rankings), size=number_of_ballots, p=draw_probabilities\n    )\n    ballot_pool = [perm_rankings[indices[i]] for i in range(number_of_ballots)]\n\n    return self.ballot_pool_to_profile(ballot_pool, self.candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.slate_PlackettLuce","title":"<code>slate_PlackettLuce</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots using a slate-PlackettLuce model. This model first samples a ballot type by flipping a cohesion parameter weighted coin. It then fills out the ballot type via sampling with out replacement from the interval.</p> <p>Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>slate_to_candidates</code> :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class slate_PlackettLuce(BallotGenerator):\n    \"\"\"\n    Class for generating ballots using a slate-PlackettLuce model.\n    This model first samples a ballot type by flipping a cohesion parameter weighted coin.\n    It then fills out the ballot type via sampling with out replacement from the interval.\n\n    Can be initialized with an interval or can be\n    constructed with the Dirichlet distribution using the `from_params` method in the\n    `BallotGenerator` class.\n\n    **Attributes**\n\n    `slate_to_candidates`\n    :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, cohesion_parameters: dict, **data):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        \"\"\"\n        Args:\n        `number_of_ballots`: The number of ballots to generate.\n\n        `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                    False if you want the full, aggregated PreferenceProfile.\n        \"\"\"\n        bloc_props = list(self.bloc_voter_prop.values())\n        ballots_per_block = dict(\n            zip(\n                self.blocs,\n                apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n            )\n        )\n\n        pref_profile_by_bloc = {}\n\n        for i, bloc in enumerate(self.blocs):\n            # number of voters in this bloc\n            num_ballots = ballots_per_block[bloc]\n            ballot_pool = [Ballot()] * num_ballots\n            pref_intervals = self.pref_intervals_by_bloc[bloc]\n            zero_cands = set(\n                it.chain(*[pi.zero_cands for pi in pref_intervals.values()])\n            )\n\n            slate_to_non_zero_candidates = {\n                s: [c for c in c_list if c not in zero_cands]\n                for s, c_list in self.slate_to_candidates.items()\n            }\n\n            ballot_types = sample_cohesion_ballot_types(\n                slate_to_non_zero_candidates=slate_to_non_zero_candidates,\n                num_ballots=num_ballots,\n                cohesion_parameters_for_bloc=self.cohesion_parameters[bloc],\n            )\n\n            for j, bt in enumerate(ballot_types):\n                cand_ordering_by_bloc = {}\n\n                for b in self.blocs:\n                    # create a pref interval dict of only this blocs candidates\n                    bloc_cand_pref_interval = pref_intervals[b].interval\n                    cands = pref_intervals[b].non_zero_cands\n\n                    # if there are no non-zero candidates, skip this bloc\n                    if len(cands) == 0:\n                        continue\n\n                    distribution = [bloc_cand_pref_interval[c] for c in cands]\n\n                    # sample\n                    cand_ordering = np.random.choice(\n                        a=list(cands), size=len(cands), p=distribution, replace=False\n                    )\n                    cand_ordering_by_bloc[b] = list(cand_ordering)\n\n                ranking = [frozenset({-1})] * len(bt)\n                for i, b in enumerate(bt):\n                    # append the current first candidate, then remove them from the ordering\n                    ranking[i] = frozenset({cand_ordering_by_bloc[b][0]})\n                    cand_ordering_by_bloc[b].pop(0)\n\n                if len(zero_cands) &gt; 0:\n                    ranking.append(frozenset(zero_cands))\n                ballot_pool[j] = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pref_profile_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pref_profile_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pref_profile_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.slate_PlackettLuce.generate_profile","title":"<code>generate_profile(number_of_ballots, by_bloc=False)</code>","text":"<p>Args: <code>number_of_ballots</code>: The number of ballots to generate.</p> <p><code>by_bloc</code>: True if you want to return a dictionary of PreferenceProfiles by bloc.             False if you want the full, aggregated PreferenceProfile.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>def generate_profile(\n    self, number_of_ballots: int, by_bloc: bool = False\n) -&gt; Union[PreferenceProfile, Tuple]:\n    \"\"\"\n    Args:\n    `number_of_ballots`: The number of ballots to generate.\n\n    `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                False if you want the full, aggregated PreferenceProfile.\n    \"\"\"\n    bloc_props = list(self.bloc_voter_prop.values())\n    ballots_per_block = dict(\n        zip(\n            self.blocs,\n            apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n        )\n    )\n\n    pref_profile_by_bloc = {}\n\n    for i, bloc in enumerate(self.blocs):\n        # number of voters in this bloc\n        num_ballots = ballots_per_block[bloc]\n        ballot_pool = [Ballot()] * num_ballots\n        pref_intervals = self.pref_intervals_by_bloc[bloc]\n        zero_cands = set(\n            it.chain(*[pi.zero_cands for pi in pref_intervals.values()])\n        )\n\n        slate_to_non_zero_candidates = {\n            s: [c for c in c_list if c not in zero_cands]\n            for s, c_list in self.slate_to_candidates.items()\n        }\n\n        ballot_types = sample_cohesion_ballot_types(\n            slate_to_non_zero_candidates=slate_to_non_zero_candidates,\n            num_ballots=num_ballots,\n            cohesion_parameters_for_bloc=self.cohesion_parameters[bloc],\n        )\n\n        for j, bt in enumerate(ballot_types):\n            cand_ordering_by_bloc = {}\n\n            for b in self.blocs:\n                # create a pref interval dict of only this blocs candidates\n                bloc_cand_pref_interval = pref_intervals[b].interval\n                cands = pref_intervals[b].non_zero_cands\n\n                # if there are no non-zero candidates, skip this bloc\n                if len(cands) == 0:\n                    continue\n\n                distribution = [bloc_cand_pref_interval[c] for c in cands]\n\n                # sample\n                cand_ordering = np.random.choice(\n                    a=list(cands), size=len(cands), p=distribution, replace=False\n                )\n                cand_ordering_by_bloc[b] = list(cand_ordering)\n\n            ranking = [frozenset({-1})] * len(bt)\n            for i, b in enumerate(bt):\n                # append the current first candidate, then remove them from the ordering\n                ranking[i] = frozenset({cand_ordering_by_bloc[b][0]})\n                cand_ordering_by_bloc[b].pop(0)\n\n            if len(zero_cands) &gt; 0:\n                ranking.append(frozenset(zero_cands))\n            ballot_pool[j] = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n\n        pp = PreferenceProfile(ballots=ballot_pool)\n        pp = pp.condense_ballots()\n        pref_profile_by_bloc[bloc] = pp\n\n    # combine the profiles\n    pp = PreferenceProfile(ballots=[])\n    for profile in pref_profile_by_bloc.values():\n        pp += profile\n\n    if by_bloc:\n        return (pref_profile_by_bloc, pp)\n\n    # else return the combined profiles\n    else:\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.name_PlackettLuce","title":"<code>name_PlackettLuce</code>","text":"<p>             Bases: <code>short_name_PlackettLuce</code></p> <p>Class for generating full ballots with name-PlackettLuce. This model samples without replacement from a preference interval. Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>candidates</code> : a list of candidates.</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class name_PlackettLuce(short_name_PlackettLuce):\n    \"\"\"\n    Class for generating full ballots with name-PlackettLuce. This model samples without\n    replacement from a preference interval. Can be initialized with an interval or can be\n    constructed with the Dirichlet distribution using the `from_params` method in the\n    `BallotGenerator` class.\n\n    **Attributes**\n\n    `candidates`\n    : a list of candidates.\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).\n\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, cohesion_parameters: dict, **data):\n        if \"candidates\" in data:\n            ballot_length = len(data[\"candidates\"])\n        elif \"slate_to_candidates\" in data:\n            ballot_length = sum(\n                len(c_list) for c_list in data[\"slate_to_candidates\"].values()\n            )\n        else:\n            raise ValueError(\"One of candidates or slate_to_candidates must be passed.\")\n\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(\n            ballot_length=ballot_length, cohesion_parameters=cohesion_parameters, **data\n        )\n</code></pre>"},{"location":"api/#votekit.ballot_generator.slate_BradleyTerry","title":"<code>slate_BradleyTerry</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots using a slate-BradleyTerry model. It presamples ballot types by checking all pairwise comparisons, then fills out candidate ordering by sampling without replacement from preference intervals.</p> <p>Only works with 2 blocs at the moment.</p> <p>Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>slate_to_candidates</code> :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class slate_BradleyTerry(BallotGenerator):\n    \"\"\"\n    Class for generating ballots using a slate-BradleyTerry model. It\n    presamples ballot types by checking all pairwise comparisons, then fills out candidate\n    ordering by sampling without replacement from preference intervals.\n\n    Only works with 2 blocs at the moment.\n\n    Can be initialized with an interval or can be\n    constructed with the Dirichlet distribution using the `from_params` method in the\n    `BallotGenerator` class.\n\n    **Attributes**\n\n    `slate_to_candidates`\n    :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, cohesion_parameters: dict, **data):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n\n        if len(self.slate_to_candidates.keys()) &gt; 2:\n            raise UserWarning(\n                f\"This model currently only supports at most two blocs, but you \\\n                              passed {len(self.slate_to_candidates.keys())}\"\n            )\n\n        self.ballot_type_pdf = {\n            b: self._compute_ballot_type_dist(b, self.blocs[(i + 1) % 2])\n            for i, b in enumerate(self.blocs)\n        }\n\n    def _compute_ballot_type_dist(self, bloc, opp_bloc):\n        \"\"\"\n        Return a dictionary with keys ballot types and values equal to probability of sampling.\n        \"\"\"\n        blocs_to_sample = [\n            b for b in self.blocs for _ in range(len(self.slate_to_candidates[b]))\n        ]\n        total_comparisons = np.prod(\n            [len(l_of_c) for l_of_c in self.slate_to_candidates.values()]\n        )\n        cohesion = self.cohesion_parameters[bloc][bloc]\n\n        def prob_of_type(b_type):\n            success = sum(\n                b_type[i + 1 :].count(opp_bloc)\n                for i, b in enumerate(b_type)\n                if b == bloc\n            )\n            return pow(cohesion, success) * pow(\n                1 - cohesion, total_comparisons - success\n            )\n\n        pdf = {\n            b: prob_of_type(b)\n            for b in set(it.permutations(blocs_to_sample, len(blocs_to_sample)))\n        }\n\n        summ = sum(pdf.values())\n        return {b: v / summ for b, v in pdf.items()}\n\n    def _sample_ballot_types_deterministic(\n        self, bloc: str, opp_bloc: str, num_ballots: int\n    ):\n        \"\"\"\n        Used to generate bloc orderings for deliberative.\n\n        Returns a list of lists, where each sublist contains the bloc names in order they appear\n        on the ballot.\n        \"\"\"\n        # pdf = self._compute_ballot_type_dist(bloc=bloc, opp_bloc=opp_bloc)\n        pdf = self.ballot_type_pdf[bloc]\n        b_types = list(pdf.keys())\n        probs = list(pdf.values())\n\n        sampled_indices = np.random.choice(len(b_types), size=num_ballots, p=probs)\n\n        return [b_types[i] for i in sampled_indices]\n\n    def _sample_ballot_types_MCMC(\n        self, bloc: str, num_ballots: int, verbose: bool = False\n    ):\n        \"\"\"\n        Generate ballot types using MCMC that has desired stationary distribution.\n        \"\"\"\n\n        seed_ballot_type = [\n            b for b in self.blocs for _ in range(len(self.slate_to_candidates[b]))\n        ]\n\n        ballots = [[-1]] * num_ballots\n        accept = 0\n        current_ranking = seed_ballot_type\n\n        cohesion = self.cohesion_parameters[bloc][bloc]\n\n        # presample swap indices\n        swap_indices = [\n            (j1, j1 + 1)\n            for j1 in np.random.choice(len(seed_ballot_type) - 1, size=num_ballots)\n        ]\n\n        odds = (1 - cohesion) / cohesion\n        # generate MCMC sample\n        for i in range(num_ballots):\n            # choose adjacent pair to propose a swap\n            j1, j2 = swap_indices[i]\n\n            # if swap reduces number of voters bloc above opposing bloc\n            if (\n                current_ranking[j1] != current_ranking[j2]\n                and current_ranking[j1] == bloc\n            ):\n                acceptance_prob = odds\n\n            # if swap increases number of voters bloc above opposing or swaps two of same bloc\n            else:\n                acceptance_prob = 1\n\n            # if you accept, make the swap\n            if random.random() &lt; acceptance_prob:\n                current_ranking[j1], current_ranking[j2] = (\n                    current_ranking[j2],\n                    current_ranking[j1],\n                )\n                accept += 1\n\n            ballots[i] = current_ranking.copy()\n\n        if verbose:\n            print(\n                f\"Acceptance ratio as number accepted / total steps: {accept/num_ballots:.2}\"\n            )\n\n        if -1 in ballots:\n            raise ValueError(\"Some element of ballots list is not a ballot.\")\n\n        return ballots\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False, deterministic: bool = True\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        \"\"\"\n        Args:\n        `number_of_ballots`: The number of ballots to generate.\n\n        `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                    False if you want the full, aggregated PreferenceProfile.\n\n        `deterministic`: True if you want to use the computed pdf for the slate-BT model,\n                        False if you want to use MCMC approximation. Defaults to True.\n        \"\"\"\n        # the number of ballots per bloc is determined by Huntington-Hill apportionment\n        bloc_props = list(self.bloc_voter_prop.values())\n        ballots_per_block = dict(\n            zip(\n                self.blocs,\n                apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n            )\n        )\n\n        pref_profile_by_bloc = {}\n\n        for i, bloc in enumerate(self.blocs):\n            # number of voters in this bloc\n            num_ballots = ballots_per_block[bloc]\n            ballot_pool = [Ballot()] * num_ballots\n            pref_intervals = self.pref_intervals_by_bloc[bloc]\n            zero_cands = set(\n                it.chain(*[pi.zero_cands for pi in pref_intervals.values()])\n            )\n\n            if deterministic:\n                ballot_types = self._sample_ballot_types_deterministic(\n                    bloc=bloc, opp_bloc=self.blocs[(i + 1) % 2], num_ballots=num_ballots\n                )\n            else:\n                ballot_types = self._sample_ballot_types_MCMC(\n                    bloc=bloc, num_ballots=num_ballots\n                )\n\n            for j, bt in enumerate(ballot_types):\n                cand_ordering_by_bloc = {}\n\n                for b in self.blocs:\n                    # create a pref interval dict of only this blocs candidates\n                    bloc_cand_pref_interval = pref_intervals[b].interval\n                    cands = pref_intervals[b].non_zero_cands\n\n                    # if there are no non-zero candidates, skip this bloc\n                    if len(cands) == 0:\n                        continue\n\n                    distribution = [bloc_cand_pref_interval[c] for c in cands]\n\n                    # sample\n                    cand_ordering = np.random.choice(\n                        a=list(cands), size=len(cands), p=distribution, replace=False\n                    )\n\n                    cand_ordering_by_bloc[b] = list(cand_ordering)\n\n                ranking = [frozenset({-1})] * len(bt)\n                for i, b in enumerate(bt):\n                    # append the current first candidate, then remove them from the ordering\n                    ranking[i] = frozenset({cand_ordering_by_bloc[b][0]})\n                    cand_ordering_by_bloc[b].pop(0)\n\n                if len(zero_cands) &gt; 0:\n                    ranking.append(frozenset(zero_cands))\n                ballot_pool[j] = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pref_profile_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pref_profile_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pref_profile_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.slate_BradleyTerry.generate_profile","title":"<code>generate_profile(number_of_ballots, by_bloc=False, deterministic=True)</code>","text":"<p>Args: <code>number_of_ballots</code>: The number of ballots to generate.</p> <p><code>by_bloc</code>: True if you want to return a dictionary of PreferenceProfiles by bloc.             False if you want the full, aggregated PreferenceProfile.</p> <p><code>deterministic</code>: True if you want to use the computed pdf for the slate-BT model,                 False if you want to use MCMC approximation. Defaults to True.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>def generate_profile(\n    self, number_of_ballots: int, by_bloc: bool = False, deterministic: bool = True\n) -&gt; Union[PreferenceProfile, Tuple]:\n    \"\"\"\n    Args:\n    `number_of_ballots`: The number of ballots to generate.\n\n    `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                False if you want the full, aggregated PreferenceProfile.\n\n    `deterministic`: True if you want to use the computed pdf for the slate-BT model,\n                    False if you want to use MCMC approximation. Defaults to True.\n    \"\"\"\n    # the number of ballots per bloc is determined by Huntington-Hill apportionment\n    bloc_props = list(self.bloc_voter_prop.values())\n    ballots_per_block = dict(\n        zip(\n            self.blocs,\n            apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n        )\n    )\n\n    pref_profile_by_bloc = {}\n\n    for i, bloc in enumerate(self.blocs):\n        # number of voters in this bloc\n        num_ballots = ballots_per_block[bloc]\n        ballot_pool = [Ballot()] * num_ballots\n        pref_intervals = self.pref_intervals_by_bloc[bloc]\n        zero_cands = set(\n            it.chain(*[pi.zero_cands for pi in pref_intervals.values()])\n        )\n\n        if deterministic:\n            ballot_types = self._sample_ballot_types_deterministic(\n                bloc=bloc, opp_bloc=self.blocs[(i + 1) % 2], num_ballots=num_ballots\n            )\n        else:\n            ballot_types = self._sample_ballot_types_MCMC(\n                bloc=bloc, num_ballots=num_ballots\n            )\n\n        for j, bt in enumerate(ballot_types):\n            cand_ordering_by_bloc = {}\n\n            for b in self.blocs:\n                # create a pref interval dict of only this blocs candidates\n                bloc_cand_pref_interval = pref_intervals[b].interval\n                cands = pref_intervals[b].non_zero_cands\n\n                # if there are no non-zero candidates, skip this bloc\n                if len(cands) == 0:\n                    continue\n\n                distribution = [bloc_cand_pref_interval[c] for c in cands]\n\n                # sample\n                cand_ordering = np.random.choice(\n                    a=list(cands), size=len(cands), p=distribution, replace=False\n                )\n\n                cand_ordering_by_bloc[b] = list(cand_ordering)\n\n            ranking = [frozenset({-1})] * len(bt)\n            for i, b in enumerate(bt):\n                # append the current first candidate, then remove them from the ordering\n                ranking[i] = frozenset({cand_ordering_by_bloc[b][0]})\n                cand_ordering_by_bloc[b].pop(0)\n\n            if len(zero_cands) &gt; 0:\n                ranking.append(frozenset(zero_cands))\n            ballot_pool[j] = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n\n        pp = PreferenceProfile(ballots=ballot_pool)\n        pp = pp.condense_ballots()\n        pref_profile_by_bloc[bloc] = pp\n\n    # combine the profiles\n    pp = PreferenceProfile(ballots=[])\n    for profile in pref_profile_by_bloc.values():\n        pp += profile\n\n    if by_bloc:\n        return (pref_profile_by_bloc, pp)\n\n    # else return the combined profiles\n    else:\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.name_BradleyTerry","title":"<code>name_BradleyTerry</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots using a name-BradleyTerry model. The probability of sampling the ranking \\(X&gt;Y&gt;Z\\) is proportional to \\(P(X&gt;Y)*P(X&gt;Z)*P(Y&gt;Z)\\). These individual probabilities are based on the preference interval: \\(P(X&gt;Y) = x/(x+y)\\). Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>candidates</code> : a list of candidates.</p> <p><code>pref_intervals_by_bloc</code> : dictionary of dictionaries mapping of bloc to preference intervals or dictionary of PIs.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions (ex. {race: voter proportion}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class name_BradleyTerry(BallotGenerator):\n    \"\"\"\n    Class for generating ballots using a name-BradleyTerry model. The probability of sampling\n    the ranking $X&gt;Y&gt;Z$ is proportional to $P(X&gt;Y)*P(X&gt;Z)*P(Y&gt;Z)$.\n    These individual probabilities are based on the preference interval: $P(X&gt;Y) = x/(x+y)$.\n    Can be initialized with an interval or can be constructed with the Dirichlet distribution using\n    the `from_params` method in the `BallotGenerator` class.\n\n    **Attributes**\n\n    `candidates`\n    : a list of candidates.\n\n    `pref_intervals_by_bloc`\n    : dictionary of dictionaries mapping of bloc to preference intervals or dictionary of PIs.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions (ex. {race: voter proportion}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    **Methods**\n\n    See `BallotGenerator` base class.\n    \"\"\"\n\n    def __init__(self, cohesion_parameters: dict, **data):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n\n        # if dictionary of pref intervals\n        if isinstance(\n            list(self.pref_intervals_by_bloc.values())[0], PreferenceInterval\n        ):\n            self.pref_interval_by_bloc = self.pref_intervals_by_bloc\n\n        # if nested dictionary of pref intervals, combine by cohesion\n        else:\n            self.pref_interval_by_bloc = {\n                bloc: combine_preference_intervals(\n                    [self.pref_intervals_by_bloc[bloc][b] for b in self.blocs],\n                    [self.cohesion_parameters[bloc][b] for b in self.blocs],\n                )\n                for bloc in self.blocs\n            }\n\n        if len(self.candidates) &lt; 12:\n            # precompute pdfs for sampling\n            self.pdfs_by_bloc = {\n                bloc: self._BT_pdf(self.pref_interval_by_bloc[bloc].interval)\n                for bloc in self.blocs\n            }\n        else:\n            warnings.warn(\n                \"For 12 or more candidates, exact sampling is computationally infeasible. \\\n                    Please only use the built in generate_profile_MCMC method.\"\n            )\n\n    def _calc_prob(self, permutations: list[tuple], cand_support_dict: dict) -&gt; dict:\n        \"\"\"\n        given a list of (possibly incomplete) rankings and the preference interval, \\\n        calculates the probability of observing each ranking\n\n        Args:\n            permutations (list[tuple]): a list of permuted rankings\n            cand_support_dict (dict): a mapping from candidate to their \\\n            support (preference interval)\n\n        Returns:\n            dict: a mapping of the rankings to their probability\n        \"\"\"\n        ranking_to_prob = {}\n        for ranking in permutations:\n            prob = 1\n            for i in range(len(ranking)):\n                cand_i = ranking[i]\n                greater_cand_support = cand_support_dict[cand_i]\n                for j in range(i + 1, len(ranking)):\n                    cand_j = ranking[j]\n                    cand_support = cand_support_dict[cand_j]\n                    prob *= greater_cand_support / (greater_cand_support + cand_support)\n            ranking_to_prob[ranking] = prob\n        return ranking_to_prob\n\n    def _make_pow(self, lst):\n        \"\"\"\n        Helper method for _BT_pdf.\n        Takes is a list representing the preference lengths of each candidate\n        in a permutation.\n        Computes the numerator of BT probability.\n        \"\"\"\n        ret = 1\n        m = len(lst)\n        for i, val in enumerate(lst):\n            if i &lt; m - 1:\n                ret *= val ** (m - i - 1)\n        return ret\n\n    def _BT_pdf(self, dct):\n        \"\"\"\n        Construct the BT pdf as a dictionary (ballot, probability) given a preference\n        interval as a dictionary (candidate, preference).\n        \"\"\"\n\n        # gives PI lengths for each candidate in permutation\n        def pull_perm(lst):\n            nonlocal dct\n            return [dct[i] for i in lst]\n\n        new_dct = {\n            perm: self._make_pow(pull_perm(perm))\n            for perm in it.permutations(dct.keys(), len(dct))\n        }\n        summ = sum(new_dct.values())\n        return {key: value / summ for key, value in new_dct.items()}\n\n    def generate_profile(\n        self, number_of_ballots, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        # the number of ballots per bloc is determined by Huntington-Hill apportionment\n\n        bloc_props = list(self.bloc_voter_prop.values())\n        ballots_per_block = dict(\n            zip(\n                self.blocs,\n                apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n            )\n        )\n\n        pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n        for bloc in self.blocs:\n            num_ballots = ballots_per_block[bloc]\n\n            # Directly initialize the list using good memory trick\n            ballot_pool = [Ballot()] * num_ballots\n            zero_cands = self.pref_interval_by_bloc[bloc].zero_cands\n            pdf_dict = self.pdfs_by_bloc[bloc]\n\n            # Directly use the keys and values from the dictionary for sampling\n            rankings, probs = zip(*pdf_dict.items())\n\n            # The return of this will be a numpy array, so we don't need to make it into a list\n            sampled_indices = np.array(\n                np.random.choice(\n                    a=len(rankings),\n                    size=num_ballots,\n                    p=probs,\n                ),\n                ndmin=1,\n            )\n\n            for j, index in enumerate(sampled_indices):\n                ranking = [frozenset({cand}) for cand in rankings[index]]\n\n                # Add any zero candidates as ties only if they exist\n                if zero_cands:\n                    ranking.append(frozenset(zero_cands))\n\n                ballot_pool[j] = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pp_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pp_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pp_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n\n    def _BT_mcmc(\n        self, num_ballots, pref_interval, seed_ballot, zero_cands={}, verbose=False\n    ):\n        \"\"\"\n        Sample from BT distribution for a given preference interval using MCMC.\n\n        num_ballots (int): the number of ballots to sample\n        pref_interval (dict): the preference interval to determine BT distribution\n        sub_sample_length (int): how many attempts at swaps to make before saving ballot\n        seed_ballot: Ballot, the seed ballot for the Markov chain\n        verbose: bool, if True, print the acceptance ratio of the chain\n        \"\"\"\n\n        # check that seed ballot has no ties\n        for s in seed_ballot.ranking:\n            if len(s) &gt; 1:\n                raise ValueError(\"Seed ballot contains ties\")\n\n        ballots = [-1] * num_ballots\n        accept = 0\n        current_ranking = list(seed_ballot.ranking)\n        num_candidates = len(current_ranking)\n\n        # presample swap indices\n        swap_indices = [\n            (j1, j1 + 1)\n            for j1 in random.choices(range(num_candidates - 1), k=num_ballots)\n        ]\n\n        # generate MCMC sample\n        for i in range(num_ballots):\n            # choose adjacent pair to propose a swap\n            j1, j2 = swap_indices[i]\n            acceptance_prob = min(\n                1,\n                pref_interval[next(iter(current_ranking[j2]))]\n                / pref_interval[next(iter(current_ranking[j1]))],\n            )\n\n            # if you accept, make the swap\n            if random.random() &lt; acceptance_prob:\n                current_ranking[j1], current_ranking[j2] = (\n                    current_ranking[j2],\n                    current_ranking[j1],\n                )\n                accept += 1\n\n            if len(zero_cands) &gt; 0:\n                ballots[i] = Ballot(ranking=current_ranking + [zero_cands])\n            else:\n                ballots[i] = Ballot(ranking=current_ranking)\n\n        if verbose:\n            print(\n                f\"Acceptance ratio as number accepted / total steps: {accept/num_ballots:.2}\"\n            )\n\n        if -1 in ballots:\n            raise ValueError(\"Some element of ballots list is not a ballot.\")\n\n        pp = PreferenceProfile(ballots=ballots)\n        pp = pp.condense_ballots()\n        return pp\n\n    def generate_profile_MCMC(\n        self, number_of_ballots: int, verbose=False, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        \"\"\"\n        Sample from the BT distribution using Markov Chain Monte Carlo. `number_of_ballots` should\n        be sufficiently large to allow for convergence of the chain.\n\n        Args:\n            number_of_ballots (int): Number of ballots to generate.\n            verbose (bool, optional): If True, print the acceptance ratio of the chain. Default\n                                        is False.\n            by_bloc (bool, optional): True if you want a tuple (pp_by_bloc, pp), which is a\n                                    dictionary of  PreferenceProfiles with keys = blocs and the\n                                    aggregated profile. False if you want the aggregated profile.\n                                    Defaults to False.\n\n        Returns:\n            Generated ballots as a PreferenceProfile or tuple (dict, PreferenceProfile).\n        \"\"\"\n\n        # the number of ballots per bloc is determined by Huntington-Hill apportionment\n        bloc_props = list(self.bloc_voter_prop.values())\n        ballots_per_block = dict(\n            zip(\n                self.blocs,\n                apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n            )\n        )\n\n        pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n        for bloc in self.blocs:\n            num_ballots = ballots_per_block[bloc]\n            pref_interval = self.pref_interval_by_bloc[bloc]\n            pref_interval_dict = pref_interval.interval\n            non_zero_cands = pref_interval.non_zero_cands\n            zero_cands = pref_interval.zero_cands\n\n            seed_ballot = Ballot(\n                ranking=tuple([frozenset({c}) for c in non_zero_cands])\n            )\n            pp = self._BT_mcmc(\n                num_ballots,\n                pref_interval_dict,\n                seed_ballot,\n                zero_cands=zero_cands,\n                verbose=verbose,\n            )\n\n            pp_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pp_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pp_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.name_BradleyTerry.generate_profile_MCMC","title":"<code>generate_profile_MCMC(number_of_ballots, verbose=False, by_bloc=False)</code>","text":"<p>Sample from the BT distribution using Markov Chain Monte Carlo. <code>number_of_ballots</code> should be sufficiently large to allow for convergence of the chain.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_ballots</code> <code>int</code> <p>Number of ballots to generate.</p> required <code>verbose</code> <code>bool</code> <p>If True, print the acceptance ratio of the chain. Default                         is False.</p> <code>False</code> <code>by_bloc</code> <code>bool</code> <p>True if you want a tuple (pp_by_bloc, pp), which is a                     dictionary of  PreferenceProfiles with keys = blocs and the                     aggregated profile. False if you want the aggregated profile.                     Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[PreferenceProfile, Tuple]</code> <p>Generated ballots as a PreferenceProfile or tuple (dict, PreferenceProfile).</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>def generate_profile_MCMC(\n    self, number_of_ballots: int, verbose=False, by_bloc: bool = False\n) -&gt; Union[PreferenceProfile, Tuple]:\n    \"\"\"\n    Sample from the BT distribution using Markov Chain Monte Carlo. `number_of_ballots` should\n    be sufficiently large to allow for convergence of the chain.\n\n    Args:\n        number_of_ballots (int): Number of ballots to generate.\n        verbose (bool, optional): If True, print the acceptance ratio of the chain. Default\n                                    is False.\n        by_bloc (bool, optional): True if you want a tuple (pp_by_bloc, pp), which is a\n                                dictionary of  PreferenceProfiles with keys = blocs and the\n                                aggregated profile. False if you want the aggregated profile.\n                                Defaults to False.\n\n    Returns:\n        Generated ballots as a PreferenceProfile or tuple (dict, PreferenceProfile).\n    \"\"\"\n\n    # the number of ballots per bloc is determined by Huntington-Hill apportionment\n    bloc_props = list(self.bloc_voter_prop.values())\n    ballots_per_block = dict(\n        zip(\n            self.blocs,\n            apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n        )\n    )\n\n    pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n    for bloc in self.blocs:\n        num_ballots = ballots_per_block[bloc]\n        pref_interval = self.pref_interval_by_bloc[bloc]\n        pref_interval_dict = pref_interval.interval\n        non_zero_cands = pref_interval.non_zero_cands\n        zero_cands = pref_interval.zero_cands\n\n        seed_ballot = Ballot(\n            ranking=tuple([frozenset({c}) for c in non_zero_cands])\n        )\n        pp = self._BT_mcmc(\n            num_ballots,\n            pref_interval_dict,\n            seed_ballot,\n            zero_cands=zero_cands,\n            verbose=verbose,\n        )\n\n        pp_by_bloc[bloc] = pp\n\n    # combine the profiles\n    pp = PreferenceProfile(ballots=[])\n    for profile in pp_by_bloc.values():\n        pp += profile\n\n    if by_bloc:\n        return (pp_by_bloc, pp)\n\n    # else return the combined profiles\n    else:\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.AlternatingCrossover","title":"<code>AlternatingCrossover</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for Alternating Crossover style of generating ballots. AC assumes that voters either rank all of their own blocs candidates above the other bloc, or the voters \"crossover\" and rank a candidate from the other bloc first, then alternate between candidates from their own bloc and the opposing. Should only be used when there are two blocs.</p> <p>Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions (ex. {bloc: voter proportion}).</p> <p><code>slate_to_candidates</code> :   dictionary mapping of slate to candidates (ex. {bloc: [candidate1, candidate2]}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class AlternatingCrossover(BallotGenerator):\n    \"\"\"\n    Class for Alternating Crossover style of generating ballots.\n    AC assumes that voters either rank all of their own blocs candidates above the other bloc,\n    or the voters \"crossover\" and rank a candidate from the other bloc first, then alternate\n    between candidates from their own bloc and the opposing.\n    Should only be used when there are two blocs.\n\n    Can be initialized with an interval or can be\n    constructed with the Dirichlet distribution using the `from_params` method in the\n    `BallotGenerator` class.\n\n    **Attributes**\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions (ex. {bloc: voter proportion}).\n\n    `slate_to_candidates`\n    :   dictionary mapping of slate to candidates (ex. {bloc: [candidate1, candidate2]}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    **Methods**\n\n    See `BallotGenerator` base class.\n    \"\"\"\n\n    def __init__(\n        self,\n        cohesion_parameters: dict,\n        **data,\n    ):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        # compute the number of bloc and crossover voters in each bloc using Huntington Hill\n        cohesion_parameters = {\n            b: self.cohesion_parameters[b][b] for b in self.cohesion_parameters\n        }\n\n        voter_types = [(b, type) for b in self.blocs for type in [\"bloc\", \"cross\"]]\n\n        voter_props = [\n            cohesion_parameters[b] * self.bloc_voter_prop[b]\n            if t == \"bloc\"\n            else (1 - cohesion_parameters[b]) * self.bloc_voter_prop[b]\n            for b, t in voter_types\n        ]\n\n        ballots_per_type = dict(\n            zip(\n                voter_types,\n                apportion.compute(\"huntington\", voter_props, number_of_ballots),\n            )\n        )\n\n        pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n        for i, bloc in enumerate(self.blocs):\n            ballot_pool = []\n            num_bloc_ballots = ballots_per_type[(bloc, \"bloc\")]\n            num_cross_ballots = ballots_per_type[(bloc, \"cross\")]\n\n            pref_interval_dict = self.pref_intervals_by_bloc[bloc]\n\n            opposing_slate = self.blocs[(i + 1) % 2]\n\n            opposing_cands = list(pref_interval_dict[opposing_slate].interval.keys())\n            bloc_cands = list(pref_interval_dict[bloc].interval.keys())\n\n            pref_for_opposing = list(\n                pref_interval_dict[opposing_slate].interval.values()\n            )\n            pref_for_bloc = list(pref_interval_dict[bloc].interval.values())\n\n            for i in range(num_cross_ballots + num_bloc_ballots):\n                bloc_cands = list(\n                    np.random.choice(\n                        bloc_cands,\n                        p=pref_for_bloc,\n                        size=len(bloc_cands),\n                        replace=False,\n                    )\n                )\n                opposing_cands = list(\n                    np.random.choice(\n                        opposing_cands,\n                        p=pref_for_opposing,\n                        size=len(opposing_cands),\n                        replace=False,\n                    )\n                )\n\n                if i &lt; num_cross_ballots:\n                    # alternate the bloc and opposing bloc candidates to create crossover ballots\n                    ranking = [\n                        frozenset({cand})\n                        for pair in zip(opposing_cands, bloc_cands)\n                        for cand in pair\n                    ]\n                else:\n                    ranking = [frozenset({c}) for c in bloc_cands] + [\n                        frozenset({c}) for c in opposing_cands\n                    ]\n\n                ballot = Ballot(ranking=tuple(ranking), weight=Fraction(1, 1))\n                ballot_pool.append(ballot)\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pp_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pp_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pp_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.CambridgeSampler","title":"<code>CambridgeSampler</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots based on historical RCV elections occurring in Cambridge. Alternative election data can be used if specified. Assumes that there are two blocs, a majority and a minority bloc, and determines this based on the bloc_voter_prop attr.</p> <p>Based on cohesion parameters, decides if a voter casts their top choice within their bloc or in the opposing bloc. Then uses historical data; given their first choice, choose a ballot type from the historical distribution.</p> <p>Attributes</p> <p><code>slate_to_candidates</code> :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: voter proportion}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>historical_majority</code> : name of majority bloc in historical data, defaults to W for Cambridge.</p> <p><code>historical_minority</code> : name of minority bloc in historical data, defaults to C for Cambridge.</p> <p><code>path</code> :   file path to an election data file to sample from. Defaults to Cambridge elections.</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class CambridgeSampler(BallotGenerator):\n    \"\"\"\n    Class for generating ballots based on historical RCV elections occurring\n    in Cambridge. Alternative election data can be used if specified. Assumes that there are two\n    blocs, a majority and a minority bloc, and determines this based on the bloc_voter_prop attr.\n\n    Based on cohesion parameters, decides if a voter casts their top choice within their bloc\n    or in the opposing bloc. Then uses historical data; given their first choice, choose a\n    ballot type from the historical distribution.\n\n\n    **Attributes**\n\n    `slate_to_candidates`\n    :   dictionary mapping of slate to candidates (ex. {bloc: [candidate]}).\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: voter proportion}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `historical_majority`\n    : name of majority bloc in historical data, defaults to W for Cambridge.\n\n    `historical_minority`\n    : name of minority bloc in historical data, defaults to C for Cambridge.\n\n    `path`\n    :   file path to an election data file to sample from. Defaults to Cambridge elections.\n\n    **Methods**\n\n    See `BallotGenerator` base class.\n    \"\"\"\n\n    def __init__(\n        self,\n        cohesion_parameters: dict,\n        path: Optional[Path] = None,\n        historical_majority: Optional[str] = \"W\",\n        historical_minority: Optional[str] = \"C\",\n        **data,\n    ):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n\n        self.historical_majority = historical_majority\n        self.historical_minority = historical_minority\n\n        if len(self.slate_to_candidates.keys()) &gt; 2:\n            raise UserWarning(\n                f\"This model currently only supports at two blocs, but you \\\n                              passed {len(self.slate_to_candidates.keys())}\"\n            )\n\n        self.majority_bloc = [\n            bloc for bloc, prop in self.bloc_voter_prop.items() if prop &gt;= 0.5\n        ][0]\n\n        self.minority_bloc = [\n            bloc for bloc in self.bloc_voter_prop.keys() if bloc != self.majority_bloc\n        ][0]\n\n        self.bloc_to_historical = {\n            self.majority_bloc: self.historical_majority,\n            self.minority_bloc: self.historical_minority,\n        }\n\n        # # changing names to match historical data, if statement handles generating from_params\n        # # only want to run this now if generating from init\n        # if len(self.cohesion_parameters) &gt; 0:\n        #     self._rename_blocs()\n\n        if path:\n            self.path = path\n        else:\n            BASE_DIR = Path(__file__).resolve().parent\n            DATA_DIR = BASE_DIR / \"data/\"\n            self.path = Path(DATA_DIR, \"Cambridge_09to17_ballot_types.p\")\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        with open(self.path, \"rb\") as pickle_file:\n            ballot_frequencies = pickle.load(pickle_file)\n\n        cohesion_parameters = {b: self.cohesion_parameters[b][b] for b in self.blocs}\n\n        # compute the number of bloc and crossover voters in each bloc using Huntington Hill\n        voter_types = [\n            (b, t) for b in list(self.bloc_voter_prop.keys()) for t in [\"bloc\", \"cross\"]\n        ]\n\n        voter_props = [\n            cohesion_parameters[b] * self.bloc_voter_prop[b]\n            if t == \"bloc\"\n            else (1 - cohesion_parameters[b]) * self.bloc_voter_prop[b]\n            for b, t in voter_types\n        ]\n\n        ballots_per_type = dict(\n            zip(\n                voter_types,\n                apportion.compute(\"huntington\", voter_props, number_of_ballots),\n            )\n        )\n\n        pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n        for i, bloc in enumerate(self.blocs):\n            bloc_voters = ballots_per_type[(bloc, \"bloc\")]\n            cross_voters = ballots_per_type[(bloc, \"cross\")]\n            ballot_pool = [Ballot()] * (bloc_voters + cross_voters)\n\n            # store the opposition bloc\n            opp_bloc = self.blocs[(i + 1) % 2]\n\n            # find total number of ballots that start with bloc and opp_bloc\n            bloc_first_count = sum(\n                [\n                    freq\n                    for ballot, freq in ballot_frequencies.items()\n                    if ballot[0] == self.bloc_to_historical[bloc]\n                ]\n            )\n\n            opp_bloc_first_count = sum(\n                [\n                    freq\n                    for ballot, freq in ballot_frequencies.items()\n                    if ballot[0] == self.bloc_to_historical[opp_bloc]\n                ]\n            )\n\n            # Compute the pref interval for this bloc\n            pref_interval_dict = combine_preference_intervals(\n                list(self.pref_intervals_by_bloc[bloc].values()),\n                [cohesion_parameters[bloc], 1 - cohesion_parameters[bloc]],\n            )\n\n            # compute the relative probabilities of each ballot\n            # sorted by ones where the ballot lists the bloc first\n            # and those that list the opp first\n            prob_ballot_given_bloc_first = {\n                ballot: freq / bloc_first_count\n                for ballot, freq in ballot_frequencies.items()\n                if ballot[0] == self.bloc_to_historical[bloc]\n            }\n\n            prob_ballot_given_opp_first = {\n                ballot: freq / opp_bloc_first_count\n                for ballot, freq in ballot_frequencies.items()\n                if ballot[0] == self.bloc_to_historical[opp_bloc]\n            }\n\n            bloc_voter_ordering = random.choices(\n                list(prob_ballot_given_bloc_first.keys()),\n                weights=list(prob_ballot_given_bloc_first.values()),\n                k=bloc_voters,\n            )\n            cross_voter_ordering = random.choices(\n                list(prob_ballot_given_opp_first.keys()),\n                weights=list(prob_ballot_given_opp_first.values()),\n                k=cross_voters,\n            )\n\n            # Generate ballots\n            for i in range(bloc_voters + cross_voters):\n                # Based on first choice, randomly choose\n                # ballots weighted by Cambridge frequency\n                if i &lt; bloc_voters:\n                    bloc_ordering = bloc_voter_ordering[i]\n                else:\n                    bloc_ordering = cross_voter_ordering[i - bloc_voters]\n\n                # Now turn bloc ordering into candidate ordering\n                pl_ordering = list(\n                    np.random.choice(\n                        list(pref_interval_dict.interval.keys()),\n                        len(pref_interval_dict.interval),\n                        p=list(pref_interval_dict.interval.values()),\n                        replace=False,\n                    )\n                )\n                ordered_bloc_slate = [\n                    c for c in pl_ordering if c in self.slate_to_candidates[bloc]\n                ]\n                ordered_opp_slate = [\n                    c for c in pl_ordering if c in self.slate_to_candidates[opp_bloc]\n                ]\n\n                # Fill in the bloc slots as determined\n                # With the candidate ordering generated with PL\n                full_ballot = []\n                for b in bloc_ordering:\n                    if b == self.bloc_to_historical[bloc]:\n                        if ordered_bloc_slate:\n                            full_ballot.append(ordered_bloc_slate.pop(0))\n                    else:\n                        if ordered_opp_slate:\n                            full_ballot.append(ordered_opp_slate.pop(0))\n\n                ranking = tuple([frozenset({cand}) for cand in full_ballot])\n                ballot_pool[i] = Ballot(ranking=ranking, weight=Fraction(1, 1))\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pp_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pp_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pp_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.OneDimSpatial","title":"<code>OneDimSpatial</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>1-D spatial model for ballot generation. Assumes the candidates are normally distributed on the real line. Then voters are also normally distributed, and vote based on Euclidean distance to the candidates.</p> <p>Attributes <code>candidates</code>     : a list of candidates.</p> <p>See <code>BallotGenerator</code> base class.</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class OneDimSpatial(BallotGenerator):\n    \"\"\"\n    1-D spatial model for ballot generation. Assumes the candidates are normally distributed on\n    the real line. Then voters are also normally distributed, and vote based on Euclidean distance\n    to the candidates.\n\n    **Attributes**\n    `candidates`\n        : a list of candidates.\n\n    See `BallotGenerator` base class.\n\n    **Methods**\n\n    See `BallotGenerator` base class.\n    \"\"\"\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        candidate_position_dict = {c: np.random.normal(0, 1) for c in self.candidates}\n        voter_positions = np.random.normal(0, 1, number_of_ballots)\n\n        ballot_pool = []\n\n        for vp in voter_positions:\n            distance_dict = {\n                c: abs(v - vp) for c, v, in candidate_position_dict.items()\n            }\n            candidate_order = sorted(distance_dict, key=distance_dict.__getitem__)\n            ballot_pool.append(candidate_order)\n\n        return self.ballot_pool_to_profile(ballot_pool, self.candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.ImpartialCulture","title":"<code>ImpartialCulture</code>","text":"<p>             Bases: <code>BallotSimplex</code></p> <p>Impartial Culture model with an alpha value of 1e10 (should be infinity theoretically). This model is uniform on all linear rankings.</p> <p>Attributes</p> <p><code>candidates</code> : (list) a list of candidates</p> <p><code>alpha</code> :   (float) alpha parameter for ballot simplex. Defaults to None.</p> <p><code>point</code> :   dictionary representing a point in the ballot simplex with candidate as     keys and electoral support as values. Defaults to None.</p> <p>Methods</p> <p>See <code>BallotSimplex</code> object.</p> Note <p>Point or alpha arguments must be included to initialize. For details see <code>BallotSimplex</code> and <code>BallotGenerator</code> object.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class ImpartialCulture(BallotSimplex):\n    \"\"\"\n    Impartial Culture model with an alpha value of 1e10 (should be infinity theoretically).\n    This model is uniform on all linear rankings.\n\n\n    **Attributes**\n\n    `candidates`\n    : (list) a list of candidates\n\n    `alpha`\n    :   (float) alpha parameter for ballot simplex. Defaults to None.\n\n    `point`\n    :   dictionary representing a point in the ballot simplex with candidate as\n        keys and electoral support as values. Defaults to None.\n\n\n\n    **Methods**\n\n    See `BallotSimplex` object.\n\n    ???+ note\n\n        Point or alpha arguments must be included to initialize. For details see\n        `BallotSimplex` and `BallotGenerator` object.\n    \"\"\"\n\n    def __init__(self, **data):\n        super().__init__(alpha=float(\"inf\"), **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.ImpartialAnonymousCulture","title":"<code>ImpartialAnonymousCulture</code>","text":"<p>             Bases: <code>BallotSimplex</code></p> <p>Impartial Anonymous Culture model with an alpha value of 1. This model choose uniformly     from among all distributions on full linear rankings, and then draws according to the     chosen distribution.</p> <p>Attributes</p> <p><code>candidates</code> : (list) a list of candidates</p> <p><code>alpha</code> :   (float) alpha parameter for ballot simplex. Defaults to None.</p> <p><code>point</code> :   dictionary representing a point in the ballot simplex with candidate as     keys and electoral support as values. Defaults to None.</p> <p>Methods</p> <p>See <code>BallotSimplex</code> base class.</p> Note <p>Point or alpha arguments must be included to initialize. For details see <code>BallotSimplex</code> and <code>BallotGenerator</code> object.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class ImpartialAnonymousCulture(BallotSimplex):\n    \"\"\"\n    Impartial Anonymous Culture model with an alpha value of 1. This model choose uniformly\n        from among all distributions on full linear rankings, and then draws according to the\n        chosen distribution.\n\n    **Attributes**\n\n    `candidates`\n    : (list) a list of candidates\n\n    `alpha`\n    :   (float) alpha parameter for ballot simplex. Defaults to None.\n\n    `point`\n    :   dictionary representing a point in the ballot simplex with candidate as\n        keys and electoral support as values. Defaults to None.\n\n    **Methods**\n\n    See `BallotSimplex` base class.\n\n    ???+ note\n\n        Point or alpha arguments must be included to initialize. For details see\n        `BallotSimplex` and `BallotGenerator` object.\n    \"\"\"\n\n    def __init__(self, **data):\n        super().__init__(alpha=1, **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.name_Cumulative","title":"<code>name_Cumulative</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating cumulative ballots. This model samples with replacement from a combined preference interval and counts candidates with multiplicity. Can be initialized with an interval or can be constructed with the Dirichlet distribution using the <code>from_params</code> method in the <code>BallotGenerator</code> class.</p> <p>Attributes</p> <p><code>candidates</code> : a list of candidates.</p> <p><code>pref_intervals_by_bloc</code> :   dictionary of dictionaries mapping of bloc to preference intervals.     (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).</p> <p><code>cohesion_parameters</code> : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).</p> <p><code>num_votes</code> : the number of votes allowed per ballot.</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class name_Cumulative(BallotGenerator):\n    \"\"\"\n    Class for generating cumulative ballots. This model samples with\n    replacement from a combined preference interval and counts candidates with multiplicity.\n    Can be initialized with an interval or can be constructed with the Dirichlet distribution\n    using the `from_params` method in the `BallotGenerator` class.\n\n    **Attributes**\n\n    `candidates`\n    : a list of candidates.\n\n    `pref_intervals_by_bloc`\n    :   dictionary of dictionaries mapping of bloc to preference intervals.\n        (ex. {bloc_1: {bloc_1 : PI, bloc_2: PI}}).\n\n    `cohesion_parameters`\n    : dictionary of dictionaries of cohesion parameters (ex. {bloc_1: {bloc_1:.7, bloc_2: .3}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of bloc to voter proportions (ex. {bloc: proportion}).\n\n    `num_votes`\n    : the number of votes allowed per ballot.\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, cohesion_parameters: dict, num_votes: int, **data):\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(cohesion_parameters=cohesion_parameters, **data)\n        self.num_votes = num_votes\n\n        # if dictionary of pref intervals is passed\n        if isinstance(\n            list(self.pref_intervals_by_bloc.values())[0], PreferenceInterval\n        ):\n            self.pref_interval_by_bloc = self.pref_intervals_by_bloc\n\n        # if nested dictionary of pref intervals, combine by cohesion\n        else:\n            self.pref_interval_by_bloc = {\n                bloc: combine_preference_intervals(\n                    [self.pref_intervals_by_bloc[bloc][b] for b in self.blocs],\n                    [self.cohesion_parameters[bloc][b] for b in self.blocs],\n                )\n                for bloc in self.blocs\n            }\n\n    def generate_profile(\n        self, number_of_ballots: int, by_bloc: bool = False\n    ) -&gt; Union[PreferenceProfile, Tuple]:\n        \"\"\"\n        Args:\n        `number_of_ballots`: The number of ballots to generate.\n\n        `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                    False if you want the full, aggregated PreferenceProfile.\n        \"\"\"\n        # the number of ballots per bloc is determined by Huntington-Hill apportionment\n        bloc_props = list(self.bloc_voter_prop.values())\n        ballots_per_block = dict(\n            zip(\n                self.blocs,\n                apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n            )\n        )\n\n        pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n        for bloc in self.bloc_voter_prop.keys():\n            ballot_pool = []\n            # number of voters in this bloc\n            num_ballots = ballots_per_block[bloc]\n            pref_interval = self.pref_interval_by_bloc[bloc]\n\n            # finds candidates with non-zero preference\n            non_zero_cands = list(pref_interval.non_zero_cands)\n            # creates the interval of probabilities for candidates supported by this block\n            cand_support_vec = [pref_interval.interval[cand] for cand in non_zero_cands]\n\n            for _ in range(num_ballots):\n                # generates ranking based on probability distribution of non zero candidate support\n                list_ranking = list(\n                    np.random.choice(\n                        non_zero_cands,\n                        self.num_votes,\n                        p=cand_support_vec,\n                        replace=True,\n                    )\n                )\n\n                ranking = tuple([frozenset({cand}) for cand in list_ranking])\n\n                ballot_pool.append(Ballot(ranking=ranking, weight=Fraction(1, 1)))\n\n            pp = PreferenceProfile(ballots=ballot_pool)\n            pp = pp.condense_ballots()\n            pp_by_bloc[bloc] = pp\n\n        # combine the profiles\n        pp = PreferenceProfile(ballots=[])\n        for profile in pp_by_bloc.values():\n            pp += profile\n\n        if by_bloc:\n            return (pp_by_bloc, pp)\n\n        # else return the combined profiles\n        else:\n            return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.name_Cumulative.generate_profile","title":"<code>generate_profile(number_of_ballots, by_bloc=False)</code>","text":"<p>Args: <code>number_of_ballots</code>: The number of ballots to generate.</p> <p><code>by_bloc</code>: True if you want to return a dictionary of PreferenceProfiles by bloc.             False if you want the full, aggregated PreferenceProfile.</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>def generate_profile(\n    self, number_of_ballots: int, by_bloc: bool = False\n) -&gt; Union[PreferenceProfile, Tuple]:\n    \"\"\"\n    Args:\n    `number_of_ballots`: The number of ballots to generate.\n\n    `by_bloc`: True if you want to return a dictionary of PreferenceProfiles by bloc.\n                False if you want the full, aggregated PreferenceProfile.\n    \"\"\"\n    # the number of ballots per bloc is determined by Huntington-Hill apportionment\n    bloc_props = list(self.bloc_voter_prop.values())\n    ballots_per_block = dict(\n        zip(\n            self.blocs,\n            apportion.compute(\"huntington\", bloc_props, number_of_ballots),\n        )\n    )\n\n    pp_by_bloc = {b: PreferenceProfile() for b in self.blocs}\n\n    for bloc in self.bloc_voter_prop.keys():\n        ballot_pool = []\n        # number of voters in this bloc\n        num_ballots = ballots_per_block[bloc]\n        pref_interval = self.pref_interval_by_bloc[bloc]\n\n        # finds candidates with non-zero preference\n        non_zero_cands = list(pref_interval.non_zero_cands)\n        # creates the interval of probabilities for candidates supported by this block\n        cand_support_vec = [pref_interval.interval[cand] for cand in non_zero_cands]\n\n        for _ in range(num_ballots):\n            # generates ranking based on probability distribution of non zero candidate support\n            list_ranking = list(\n                np.random.choice(\n                    non_zero_cands,\n                    self.num_votes,\n                    p=cand_support_vec,\n                    replace=True,\n                )\n            )\n\n            ranking = tuple([frozenset({cand}) for cand in list_ranking])\n\n            ballot_pool.append(Ballot(ranking=ranking, weight=Fraction(1, 1)))\n\n        pp = PreferenceProfile(ballots=ballot_pool)\n        pp = pp.condense_ballots()\n        pp_by_bloc[bloc] = pp\n\n    # combine the profiles\n    pp = PreferenceProfile(ballots=[])\n    for profile in pp_by_bloc.values():\n        pp += profile\n\n    if by_bloc:\n        return (pp_by_bloc, pp)\n\n    # else return the combined profiles\n    else:\n        return pp\n</code></pre>"},{"location":"api/#elections","title":"Elections","text":""},{"location":"api/#votekit.elections.election_types.Bloc","title":"<code>Bloc</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects m candidates with the highest m-approval scores. The m-approval score of a candidate is equal to the number of voters who rank this candidate among their m top ranked candidates.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Bloc(Election):\n    \"\"\"\n    Elects m candidates with the highest m-approval scores. The m-approval\n    score of a candidate is equal to the number of voters who rank this\n    candidate among their m top ranked candidates.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a Limited election to elect m-candidates.\n\n        Returns:\n           An ElectionState object for a Limited election.\n        \"\"\"\n        limited_equivalent = Limited(\n            profile=self.state.profile,\n            seats=self.seats,\n            k=self.seats,\n            tiebreak=self.tiebreak,\n        )\n        outcome = limited_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete Bloc election.\n\n        Returns:\n            An ElectionState object with results for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Bloc.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Runs complete Bloc election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete Bloc election.\n\n    Returns:\n        An ElectionState object with results for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Bloc.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a Limited election to elect m-candidates.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a Limited election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a Limited election to elect m-candidates.\n\n    Returns:\n       An ElectionState object for a Limited election.\n    \"\"\"\n    limited_equivalent = Limited(\n        profile=self.state.profile,\n        seats=self.seats,\n        k=self.seats,\n        tiebreak=self.tiebreak,\n    )\n    outcome = limited_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda","title":"<code>Borda</code>","text":"<p>             Bases: <code>Election</code></p> <p>Positional voting system that assigns a decreasing number of points to candidates based on order and a score vector. The conventional score vector is \\((n, n-1, \\dots, 1)\\), where \\(n\\) is the number of candidates. If a ballot is incomplete, the remaining points of the score vector are evenly distributed to the unlisted candidates (see <code>borda_scores</code> function in <code>utils</code>).</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>score_vector</code> :   (optional) weights assigned to candidate ranking, should be a list of <code>Fractions</code>.                 Defaults to \\((n,n-1,\\dots,1)\\).</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Borda(Election):\n    \"\"\"\n    Positional voting system that assigns a decreasing number of points to\n    candidates based on order and a score vector. The conventional score\n    vector is $(n, n-1, \\dots, 1)$, where $n$ is the number of candidates.\n    If a ballot is incomplete, the remaining points of the score vector\n    are evenly distributed to the unlisted candidates (see `borda_scores` function in `utils`).\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `score_vector`\n    :   (optional) weights assigned to candidate ranking, should be a list of `Fractions`.\n                    Defaults to $(n,n-1,\\dots,1)$.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        score_vector: Optional[list[Fraction]] = None,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.score_vector = score_vector\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Borda contest as Borda is not a round-by-round\n        system.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        borda_dict = borda_scores(\n            profile=self.state.profile, score_vector=self.score_vector\n        )\n\n        ranking = scores_into_set_list(borda_dict)\n\n        if isinstance(self.tiebreak, str):\n            ranking = tie_broken_ranking(\n                ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n            )\n        else:\n            ranking = self.tiebreak(ranking=ranking, profile=self.state.profile)\n\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated_cands=eliminated,\n            remaining=list(),\n            scores=borda_dict,\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return new_state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Borda contest.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete Borda contest.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Borda contest.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda.run_step","title":"<code>run_step()</code>","text":"<p>Simulates a complete Borda contest as Borda is not a round-by-round system.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Borda contest as Borda is not a round-by-round\n    system.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    borda_dict = borda_scores(\n        profile=self.state.profile, score_vector=self.score_vector\n    )\n\n    ranking = scores_into_set_list(borda_dict)\n\n    if isinstance(self.tiebreak, str):\n        ranking = tie_broken_ranking(\n            ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n        )\n    else:\n        ranking = self.tiebreak(ranking=ranking, profile=self.state.profile)\n\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated_cands=eliminated,\n        remaining=list(),\n        scores=borda_dict,\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda","title":"<code>CondoBorda</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects candidates ordered by dominating set, but breaks ties between candidates with Borda.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.             Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class CondoBorda(Election):\n    \"\"\"\n    Elects candidates ordered by dominating set, but breaks ties\n    between candidates with Borda.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a complete Conda-Borda election as it is not a round-by-round\n        system.\n\n        Returns:\n            An `ElectionState` object for a complete election.\n        \"\"\"\n        pwc_graph = PairwiseComparisonGraph(self.state.profile)\n        dominating_tiers = pwc_graph.dominating_tiers()\n\n        if isinstance(self.tiebreak, str):\n            ranking = tie_broken_ranking(\n                ranking=dominating_tiers, profile=self.state.profile, tiebreak=\"borda\"\n            )\n        else:\n            ranking = self.tiebreak(\n                ranking=dominating_tiers, profile=self.state.profile\n            )\n\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated_cands=eliminated,\n            remaining=list(),\n            scores=pwc_graph.pairwise_dict,\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return new_state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Conda-Borda election.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete Conda-Borda election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Conda-Borda election.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a complete Conda-Borda election as it is not a round-by-round system.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An <code>ElectionState</code> object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a complete Conda-Borda election as it is not a round-by-round\n    system.\n\n    Returns:\n        An `ElectionState` object for a complete election.\n    \"\"\"\n    pwc_graph = PairwiseComparisonGraph(self.state.profile)\n    dominating_tiers = pwc_graph.dominating_tiers()\n\n    if isinstance(self.tiebreak, str):\n        ranking = tie_broken_ranking(\n            ranking=dominating_tiers, profile=self.state.profile, tiebreak=\"borda\"\n        )\n    else:\n        ranking = self.tiebreak(\n            ranking=dominating_tiers, profile=self.state.profile\n        )\n\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated_cands=eliminated,\n        remaining=list(),\n        scores=pwc_graph.pairwise_dict,\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Cumulative","title":"<code>Cumulative</code>","text":"<p>             Bases: <code>HighestScore</code></p> <p>Voting system where voters are allowed to vote for candidates with multiplicity. Each ranking position should have one candidate, and every candidate ranked will receive one point, i.e., the score vector is \\((1,\\dots,1)\\). Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Cumulative(HighestScore):\n    \"\"\"\n    Voting system where voters are allowed to vote for candidates with multiplicity.\n    Each ranking position should have one candidate, and every candidate ranked will receive\n    one point, i.e., the score vector is $(1,\\dots,1)$.\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[str, Callable] = \"random\",\n    ):\n        longest_ballot = 0\n        for ballot in profile.ballots:\n            if len(ballot.ranking) &gt; longest_ballot:\n                longest_ballot = len(ballot.ranking)\n\n        score_vector = [1.0 for _ in range(longest_ballot)]\n        super().__init__(\n            profile=profile,\n            ballot_ties=ballot_ties,\n            score_vector=score_vector,\n            seats=seats,\n            tiebreak=tiebreak,\n        )\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets","title":"<code>DominatingSets</code>","text":"<p>             Bases: <code>Election</code></p> <p>Finds tiers of candidates by dominating set, which is a set of candidates such that every candidate in the set wins head to head comparisons against candidates outside of it.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class DominatingSets(Election):\n    \"\"\"\n    Finds tiers of candidates by dominating set, which is a set of candidates\n    such that every candidate in the set wins head to head comparisons against\n    candidates outside of it.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n\n    **Methods**\n    \"\"\"\n\n    def __init__(self, profile: PreferenceProfile, ballot_ties: bool = True):\n        super().__init__(profile, ballot_ties)\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a complete DominatingSets election as it is not a round-by-round\n        system.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        pwc_graph = PairwiseComparisonGraph(self.state.profile)\n        dominating_tiers = pwc_graph.dominating_tiers()\n        if len(dominating_tiers) == 1:\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=list(),\n                eliminated_cands=dominating_tiers,\n                remaining=list(),\n                scores=pwc_graph.pairwise_dict,\n                profile=PreferenceProfile(),\n                previous=self.state,\n            )\n        else:\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=[set(dominating_tiers[0])],\n                eliminated_cands=dominating_tiers[1:],\n                remaining=list(),\n                scores=pwc_graph.pairwise_dict,\n                profile=PreferenceProfile(),\n                previous=self.state,\n            )\n        self.state = new_state\n        return new_state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete DominatingSets election.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete DominatingSets election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete DominatingSets election.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a complete DominatingSets election as it is not a round-by-round system.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a complete DominatingSets election as it is not a round-by-round\n    system.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    pwc_graph = PairwiseComparisonGraph(self.state.profile)\n    dominating_tiers = pwc_graph.dominating_tiers()\n    if len(dominating_tiers) == 1:\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=list(),\n            eliminated_cands=dominating_tiers,\n            remaining=list(),\n            scores=pwc_graph.pairwise_dict,\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n    else:\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=[set(dominating_tiers[0])],\n            eliminated_cands=dominating_tiers[1:],\n            remaining=list(),\n            scores=pwc_graph.pairwise_dict,\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.HighestScore","title":"<code>HighestScore</code>","text":"<p>             Bases: <code>Election</code></p> <p>Conducts an election based on points from score vector. Chooses the m candidates with highest scores. Ties are broken by randomly permuting the tied candidates.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>score_vector</code> : list of floats where ith entry denotes the number of points given to candidates     ranked in position i.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p><code>ballot_ties</code> (optional) : resolves ties in ballots. Should only be set to True if you want ballots     to have full linear rankings.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class HighestScore(Election):\n    \"\"\"\n    Conducts an election based on points from score vector.\n    Chooses the m candidates with highest scores.\n    Ties are broken by randomly permuting the tied candidates.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected\n\n    `score_vector`\n    : list of floats where ith entry denotes the number of points given to candidates\n        ranked in position i.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    `ballot_ties` (optional)\n    : resolves ties in ballots. Should only be set to True if you want ballots\n        to have full linear rankings.\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        score_vector: list[float],\n        tiebreak: Union[Callable, str] = \"random\",\n        ballot_ties: bool = False,\n    ):\n        super().__init__(profile, ballot_ties)\n        # check for valid score vector\n        validate_score_vector(score_vector)\n\n        self.seats = seats\n        self.score_vector = score_vector\n        self.tiebreak = tiebreak\n\n    def run_step(self):\n        # a dictionary whose keys are candidates and values are scores\n        vote_tallies = compute_scores_from_vector(\n            profile=self.state.profile, score_vector=self.score_vector\n        )\n\n        # translate scores into ranking of candidates, tie break\n        ranking = scores_into_set_list(score_dict=vote_tallies)\n\n        if isinstance(self.tiebreak, str):\n            untied_ranking = tie_broken_ranking(\n                ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n            )\n        else:\n            untied_ranking = self.tiebreak(ranking=ranking, profile=self.state.profile)\n\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=untied_ranking, seats=self.seats\n        )\n\n        self.state = ElectionState(\n            curr_round=1,\n            elected=elected,\n            eliminated_cands=eliminated,\n            remaining=[],\n            profile=self.state.profile,\n            previous=self.state,\n        )\n        return self.state\n\n    @lru_cache\n    def run_election(self):\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.IRV","title":"<code>IRV</code>","text":"<p>             Bases: <code>STV</code></p> <p>A class for conducting IRV elections, which are mathematically equivalent to STV for one seat.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>quota</code> :   formula to calculate quota (defaults to droop).</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class IRV(STV):\n    \"\"\"\n    A class for conducting IRV elections, which are mathematically equivalent to STV for one seat.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n\n    `quota`\n    :   formula to calculate quota (defaults to droop).\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        quota: str = \"droop\",\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        # let parent class handle the construction\n        super().__init__(\n            profile=profile,\n            ballot_ties=ballot_ties,\n            seats=1,\n            tiebreak=tiebreak,\n            quota=quota,\n            transfer=fractional_transfer,\n        )\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited","title":"<code>Limited</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects m candidates with the highest k-approval scores. The k-approval score of a candidate is equal to the number of voters who rank this candidate among their k top ranked candidates.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>k</code> :   value of an approval score.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Limited(Election):\n    \"\"\"\n    Elects m candidates with the highest k-approval scores.\n    The k-approval score of a candidate is equal to the number of voters who\n    rank this candidate among their k top ranked candidates.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `k`\n    :   value of an approval score.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        k: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.k = k\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts Limited election in which m candidates are elected based\n        on approval scores.\n\n        Returns:\n           An ElectionState object for a Limited election.\n        \"\"\"\n        profile = self.state.profile\n        candidates = profile.get_candidates()\n        candidate_approvals = {c: Fraction(0) for c in candidates}\n\n        for ballot in profile.get_ballots():\n            # First we have to determine which candidates are approved\n            # i.e. in first k ranks on a ballot\n            approvals = []\n            for i, cand_set in enumerate(ballot.ranking):\n                # If list of total candidates before and including current set\n                # are less than seat count, all candidates are approved\n                if len(list(it.chain(*ballot.ranking[: i + 1]))) &lt; self.k:\n                    approvals.extend(list(cand_set))\n                # If list of total candidates before current set\n                # are greater than seat count, no candidates are approved\n                elif len(list(it.chain(*ballot.ranking[:i]))) &gt; self.k:\n                    approvals.extend([])\n                # Else we know the cutoff is in the set, we compute and randomly\n                # select the number of candidates we can select\n                else:\n                    accepted = len(list(it.chain(*ballot.ranking[:i])))\n                    num_to_allow = self.k - accepted\n                    approvals.extend(\n                        np.random.choice(list(cand_set), num_to_allow, replace=False)\n                    )\n\n            # Add approval votes equal to ballot weight (i.e. number of voters with this ballot)\n            for cand in approvals:\n                candidate_approvals[cand] += ballot.weight\n\n        # Order candidates by number of approval votes received\n        ranking = scores_into_set_list(candidate_approvals)\n\n        if isinstance(self.tiebreak, str):\n            ranking = tie_broken_ranking(\n                ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n            )\n        else:\n            ranking = self.tiebreak(ranking=ranking, profile=self.state.profile)\n\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated_cands=eliminated,\n            remaining=list(),\n            scores=candidate_approvals,\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return self.state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Limited election.\n\n        Returns:\n            An ElectionState object with results for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete Limited election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Limited election.\n\n    Returns:\n        An ElectionState object with results for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited.run_step","title":"<code>run_step()</code>","text":"<p>Conducts Limited election in which m candidates are elected based on approval scores.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a Limited election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts Limited election in which m candidates are elected based\n    on approval scores.\n\n    Returns:\n       An ElectionState object for a Limited election.\n    \"\"\"\n    profile = self.state.profile\n    candidates = profile.get_candidates()\n    candidate_approvals = {c: Fraction(0) for c in candidates}\n\n    for ballot in profile.get_ballots():\n        # First we have to determine which candidates are approved\n        # i.e. in first k ranks on a ballot\n        approvals = []\n        for i, cand_set in enumerate(ballot.ranking):\n            # If list of total candidates before and including current set\n            # are less than seat count, all candidates are approved\n            if len(list(it.chain(*ballot.ranking[: i + 1]))) &lt; self.k:\n                approvals.extend(list(cand_set))\n            # If list of total candidates before current set\n            # are greater than seat count, no candidates are approved\n            elif len(list(it.chain(*ballot.ranking[:i]))) &gt; self.k:\n                approvals.extend([])\n            # Else we know the cutoff is in the set, we compute and randomly\n            # select the number of candidates we can select\n            else:\n                accepted = len(list(it.chain(*ballot.ranking[:i])))\n                num_to_allow = self.k - accepted\n                approvals.extend(\n                    np.random.choice(list(cand_set), num_to_allow, replace=False)\n                )\n\n        # Add approval votes equal to ballot weight (i.e. number of voters with this ballot)\n        for cand in approvals:\n            candidate_approvals[cand] += ballot.weight\n\n    # Order candidates by number of approval votes received\n    ranking = scores_into_set_list(candidate_approvals)\n\n    if isinstance(self.tiebreak, str):\n        ranking = tie_broken_ranking(\n            ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n        )\n    else:\n        ranking = self.tiebreak(ranking=ranking, profile=self.state.profile)\n\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated_cands=eliminated,\n        remaining=list(),\n        scores=candidate_approvals,\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Plurality","title":"<code>Plurality</code>","text":"<p>             Bases: <code>SNTV</code></p> <p>Simulates a single or multi-winner plurality election. Inherits methods from <code>SNTV</code> to run election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Plurality(SNTV):\n    \"\"\"\n    Simulates a single or multi-winner plurality election. Inherits\n    methods from `SNTV` to run election.\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV","title":"<code>SNTV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Single nontransferable vote (SNTV): Elects k candidates with the highest Plurality scores.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SNTV(Election):\n    \"\"\"\n    Single nontransferable vote (SNTV): Elects k candidates with the highest\n    Plurality scores.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts an SNTV election to elect candidates.\n\n        Returns:\n           An ElectionState object for a SNTV election.\n        \"\"\"\n        limited_equivalent = Limited(\n            profile=self.state.profile, seats=self.seats, k=1, tiebreak=self.tiebreak\n        )\n        outcome = limited_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete SNTV election.\n\n        Returns:\n            An ElectionState object with results for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Runs complete SNTV election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete SNTV election.\n\n    Returns:\n        An ElectionState object with results for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV.run_step","title":"<code>run_step()</code>","text":"<p>Conducts an SNTV election to elect candidates.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a SNTV election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts an SNTV election to elect candidates.\n\n    Returns:\n       An ElectionState object for a SNTV election.\n    \"\"\"\n    limited_equivalent = Limited(\n        profile=self.state.profile, seats=self.seats, k=1, tiebreak=self.tiebreak\n    )\n    outcome = limited_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid","title":"<code>SNTV_STV_Hybrid</code>","text":"<p>             Bases: <code>Election</code></p> <p>Election method that first runs SNTV to a cutoff, then runs STV to pick a committee with a given number of seats.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>transfer</code> :   transfer method (e.g. fractional transfer).</p> <p><code>r1_cutoff</code> :   first-round cutoff value.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SNTV_STV_Hybrid(Election):\n    \"\"\"\n    Election method that first runs SNTV to a cutoff, then runs STV to\n    pick a committee with a given number of seats.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `transfer`\n    :   transfer method (e.g. fractional transfer).\n\n    `r1_cutoff`\n    :   first-round cutoff value.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        transfer: Callable,\n        r1_cutoff: int,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.transfer = transfer\n        self.r1_cutoff = r1_cutoff\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.stage = \"SNTV\"  # SNTV, switches to STV, then Complete\n\n    def run_step(self, stage: str) -&gt; ElectionState:\n        \"\"\"\n        Simulates one round an SNTV_STV election.\n\n        Args:\n            stage: Stage of the hybrid election, can be SNTV or STV.\n\n        Returns:\n           An ElectionState object for a given round.\n        \"\"\"\n        profile = self.state.profile\n\n        new_state = None\n        if stage == \"SNTV\":\n            round_state = SNTV(\n                profile=profile, seats=self.r1_cutoff, tiebreak=self.tiebreak\n            ).run_election()\n\n            # The STV election will be run on the new election state\n            # Therefore we should not add any winners, but rather\n            # set the SNTV winners as remaining candidates and update pref profiles\n            new_profile = PreferenceProfile(\n                ballots=remove_cand(\n                    set().union(*round_state.eliminated_cands), profile.get_ballots()\n                )\n            )\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=list(),\n                eliminated_cands=round_state.eliminated_cands,\n                remaining=[set(new_profile.get_candidates())],\n                profile=new_profile,\n                scores=round_state.get_scores(round_state.curr_round),\n                previous=self.state,\n            )\n        elif stage == \"STV\":\n            round_state = STV(\n                profile=profile,\n                transfer=self.transfer,\n                seats=self.seats,\n                tiebreak=self.tiebreak,\n            ).run_election()\n\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=round_state.winners(),\n                eliminated_cands=round_state.eliminated(),\n                remaining=round_state.remaining,\n                scores=round_state.get_scores(round_state.curr_round),\n                profile=round_state.profile,\n                previous=self.state,\n            )\n\n        # Update election stage to cue next run step\n        if stage == \"SNTV\":\n            self.stage = \"STV\"\n        elif stage == \"STV\":\n            self.stage = \"Complete\"\n\n        self.state = new_state  # type: ignore\n        return new_state  # type: ignore\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete SNTV_STV election.\n\n        Returns:\n            An ElectionState object with results for a complete election.\n        \"\"\"\n        while self.stage != \"Complete\":\n            self.run_step(self.stage)\n        return self.state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Runs complete SNTV_STV election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete SNTV_STV election.\n\n    Returns:\n        An ElectionState object with results for a complete election.\n    \"\"\"\n    while self.stage != \"Complete\":\n        self.run_step(self.stage)\n    return self.state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid.run_step","title":"<code>run_step(stage)</code>","text":"<p>Simulates one round an SNTV_STV election.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>Stage of the hybrid election, can be SNTV or STV.</p> required <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a given round.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self, stage: str) -&gt; ElectionState:\n    \"\"\"\n    Simulates one round an SNTV_STV election.\n\n    Args:\n        stage: Stage of the hybrid election, can be SNTV or STV.\n\n    Returns:\n       An ElectionState object for a given round.\n    \"\"\"\n    profile = self.state.profile\n\n    new_state = None\n    if stage == \"SNTV\":\n        round_state = SNTV(\n            profile=profile, seats=self.r1_cutoff, tiebreak=self.tiebreak\n        ).run_election()\n\n        # The STV election will be run on the new election state\n        # Therefore we should not add any winners, but rather\n        # set the SNTV winners as remaining candidates and update pref profiles\n        new_profile = PreferenceProfile(\n            ballots=remove_cand(\n                set().union(*round_state.eliminated_cands), profile.get_ballots()\n            )\n        )\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=list(),\n            eliminated_cands=round_state.eliminated_cands,\n            remaining=[set(new_profile.get_candidates())],\n            profile=new_profile,\n            scores=round_state.get_scores(round_state.curr_round),\n            previous=self.state,\n        )\n    elif stage == \"STV\":\n        round_state = STV(\n            profile=profile,\n            transfer=self.transfer,\n            seats=self.seats,\n            tiebreak=self.tiebreak,\n        ).run_election()\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=round_state.winners(),\n            eliminated_cands=round_state.eliminated(),\n            remaining=round_state.remaining,\n            scores=round_state.get_scores(round_state.curr_round),\n            profile=round_state.profile,\n            previous=self.state,\n        )\n\n    # Update election stage to cue next run step\n    if stage == \"SNTV\":\n        self.stage = \"STV\"\n    elif stage == \"STV\":\n        self.stage = \"Complete\"\n\n    self.state = new_state  # type: ignore\n    return new_state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV","title":"<code>STV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Class for single-winner IRV and multi-winner STV elections.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>transfer</code> :   transfer method (e.g. fractional transfer).</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>quota</code> :   formula to calculate quota (defaults to droop).</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class STV(Election):\n    \"\"\"\n    Class for single-winner IRV and multi-winner STV elections.\n\n     **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `transfer`\n    :   transfer method (e.g. fractional transfer).\n\n    `seats`\n    :   number of seats to be elected.\n\n    `quota`\n    :   formula to calculate quota (defaults to droop).\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        transfer: Callable,\n        seats: int,\n        quota: str = \"droop\",\n        ballot_ties: bool = True,\n        tiebreak: Union[str, Callable] = \"random\",\n    ):\n        # let parent class handle the og profile and election state\n        super().__init__(profile, ballot_ties)\n\n        self.transfer = transfer\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.quota = quota.lower()\n        self.threshold = self.get_threshold()\n\n    # can cache since it will not change throughout rounds\n    def get_threshold(self) -&gt; int:\n        \"\"\"\n        Calculates threshold required for election.\n\n        Returns:\n            Value of the threshold.\n        \"\"\"\n        quota = self.quota\n        if quota == \"droop\":\n            return int(self._profile.num_ballots() / (self.seats + 1) + 1)\n        elif quota == \"hare\":\n            return int(self._profile.num_ballots() / self.seats)\n        else:\n            raise ValueError(\"Misspelled or unknown quota type\")\n\n    def next_round(self) -&gt; bool:\n        \"\"\"\n        Determines if the number of seats has been met to call an election.\n\n        Returns:\n            True if number of seats has not been met, False otherwise.\n        \"\"\"\n        cands_elected = 0\n        for s in self.state.winners():\n            cands_elected += len(s)\n        return cands_elected &lt; self.seats\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates one round an STV election.\n\n        Returns:\n           An ElectionState object for a given round.\n        \"\"\"\n        remaining = self.state.profile.get_candidates()\n        ballots = self.state.profile.get_ballots()\n        round_votes, plurality_score = compute_votes(remaining, ballots)\n\n        elected = []\n        eliminated = []\n\n        # if number of remaining candidates equals number of remaining seats,\n        # everyone is elected\n        if len(remaining) == self.seats - len(\n            [c for s in self.state.winners() for c in s]\n        ):\n            elected = [{cand} for cand, _ in round_votes]\n            remaining = []\n            ballots = []\n\n        # elect all candidates who crossed threshold\n        elif round_votes[0].votes &gt;= self.threshold:\n            # partition ballots by first place candidate\n            cand_to_ballot = ballots_by_first_cand(remaining, ballots)\n            new_ballots = []\n            for candidate, votes in round_votes:\n                if votes &gt;= self.threshold:\n                    elected.append({candidate})\n                    remaining.remove(candidate)\n                    # only transfer on ballots where winner is first\n                    new_ballots += self.transfer(\n                        candidate,\n                        cand_to_ballot[candidate],\n                        plurality_score,\n                        self.threshold,\n                    )\n\n            # add in remaining ballots where non-winners are first\n            for cand in remaining:\n                new_ballots += cand_to_ballot[cand]\n\n            # remove winners from all ballots\n            ballots = remove_cand([c for s in elected for c in s], new_ballots)\n\n        # since no one has crossed threshold, eliminate one of the people\n        # with least first place votes\n        else:\n            lp_candidates = [\n                candidate\n                for candidate, votes in round_votes\n                if votes == round_votes[-1].votes\n            ]\n\n            if isinstance(self.tiebreak, str):\n                lp_cand = tie_broken_ranking(\n                    ranking=[set(lp_candidates)],\n                    profile=self.state.profile,\n                    tiebreak=self.tiebreak,\n                )[-1]\n            else:\n                lp_cand = self.tiebreak(\n                    ranking=[set(lp_candidates)], profile=self.state.profile\n                )[-1]\n\n            eliminated.append(lp_cand)\n            ballots = remove_cand(lp_cand, ballots)\n            remaining.remove(next(iter(lp_cand)))\n\n        # sorts remaining based on their current first place votes\n        _, score_dict = compute_votes(remaining, ballots)\n        remaining = scores_into_set_list(score_dict, remaining)\n\n        # sort candidates by vote share if multiple are elected\n        if len(elected) &gt;= 1:\n            elected = scores_into_set_list(\n                plurality_score, [c for s in elected for c in s]\n            )\n\n        # Make sure list-of-sets have non-empty elements\n        elected = [s for s in elected if s != set()]\n        eliminated = [s for s in eliminated if s != set()]\n\n        self.state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated_cands=eliminated,\n            remaining=remaining,\n            scores=score_dict,\n            profile=PreferenceProfile(ballots=ballots),\n            previous=self.state,\n        )\n        return self.state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete STV election.\n\n        Returns:\n            An ElectionState object with results for a complete election.\n        \"\"\"\n        if not self.next_round():\n            raise ValueError(\n                f\"Length of elected set equal to number of seats ({self.seats})\"\n            )\n\n        while self.next_round():\n            self.run_step()\n\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.get_threshold","title":"<code>get_threshold()</code>","text":"<p>Calculates threshold required for election.</p> <p>Returns:</p> Type Description <code>int</code> <p>Value of the threshold.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def get_threshold(self) -&gt; int:\n    \"\"\"\n    Calculates threshold required for election.\n\n    Returns:\n        Value of the threshold.\n    \"\"\"\n    quota = self.quota\n    if quota == \"droop\":\n        return int(self._profile.num_ballots() / (self.seats + 1) + 1)\n    elif quota == \"hare\":\n        return int(self._profile.num_ballots() / self.seats)\n    else:\n        raise ValueError(\"Misspelled or unknown quota type\")\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.next_round","title":"<code>next_round()</code>","text":"<p>Determines if the number of seats has been met to call an election.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if number of seats has not been met, False otherwise.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def next_round(self) -&gt; bool:\n    \"\"\"\n    Determines if the number of seats has been met to call an election.\n\n    Returns:\n        True if number of seats has not been met, False otherwise.\n    \"\"\"\n    cands_elected = 0\n    for s in self.state.winners():\n        cands_elected += len(s)\n    return cands_elected &lt; self.seats\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Runs complete STV election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete STV election.\n\n    Returns:\n        An ElectionState object with results for a complete election.\n    \"\"\"\n    if not self.next_round():\n        raise ValueError(\n            f\"Length of elected set equal to number of seats ({self.seats})\"\n        )\n\n    while self.next_round():\n        self.run_step()\n\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.run_step","title":"<code>run_step()</code>","text":"<p>Simulates one round an STV election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a given round.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates one round an STV election.\n\n    Returns:\n       An ElectionState object for a given round.\n    \"\"\"\n    remaining = self.state.profile.get_candidates()\n    ballots = self.state.profile.get_ballots()\n    round_votes, plurality_score = compute_votes(remaining, ballots)\n\n    elected = []\n    eliminated = []\n\n    # if number of remaining candidates equals number of remaining seats,\n    # everyone is elected\n    if len(remaining) == self.seats - len(\n        [c for s in self.state.winners() for c in s]\n    ):\n        elected = [{cand} for cand, _ in round_votes]\n        remaining = []\n        ballots = []\n\n    # elect all candidates who crossed threshold\n    elif round_votes[0].votes &gt;= self.threshold:\n        # partition ballots by first place candidate\n        cand_to_ballot = ballots_by_first_cand(remaining, ballots)\n        new_ballots = []\n        for candidate, votes in round_votes:\n            if votes &gt;= self.threshold:\n                elected.append({candidate})\n                remaining.remove(candidate)\n                # only transfer on ballots where winner is first\n                new_ballots += self.transfer(\n                    candidate,\n                    cand_to_ballot[candidate],\n                    plurality_score,\n                    self.threshold,\n                )\n\n        # add in remaining ballots where non-winners are first\n        for cand in remaining:\n            new_ballots += cand_to_ballot[cand]\n\n        # remove winners from all ballots\n        ballots = remove_cand([c for s in elected for c in s], new_ballots)\n\n    # since no one has crossed threshold, eliminate one of the people\n    # with least first place votes\n    else:\n        lp_candidates = [\n            candidate\n            for candidate, votes in round_votes\n            if votes == round_votes[-1].votes\n        ]\n\n        if isinstance(self.tiebreak, str):\n            lp_cand = tie_broken_ranking(\n                ranking=[set(lp_candidates)],\n                profile=self.state.profile,\n                tiebreak=self.tiebreak,\n            )[-1]\n        else:\n            lp_cand = self.tiebreak(\n                ranking=[set(lp_candidates)], profile=self.state.profile\n            )[-1]\n\n        eliminated.append(lp_cand)\n        ballots = remove_cand(lp_cand, ballots)\n        remaining.remove(next(iter(lp_cand)))\n\n    # sorts remaining based on their current first place votes\n    _, score_dict = compute_votes(remaining, ballots)\n    remaining = scores_into_set_list(score_dict, remaining)\n\n    # sort candidates by vote share if multiple are elected\n    if len(elected) &gt;= 1:\n        elected = scores_into_set_list(\n            plurality_score, [c for s in elected for c in s]\n        )\n\n    # Make sure list-of-sets have non-empty elements\n    elected = [s for s in elected if s != set()]\n    eliminated = [s for s in eliminated if s != set()]\n\n    self.state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated_cands=eliminated,\n        remaining=remaining,\n        scores=score_dict,\n        profile=PreferenceProfile(ballots=ballots),\n        previous=self.state,\n    )\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV","title":"<code>SequentialRCV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Class to conduct Sequential RCV election, in which votes are not transferred after a candidate has reached threshold, or been elected.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.             Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SequentialRCV(Election):\n    \"\"\"\n    Class to conduct Sequential RCV election, in which votes are not transferred\n    after a candidate has reached threshold, or been elected.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                Defaults to True.\n\n    `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: Union[Callable, str] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self, old_profile: PreferenceProfile) -&gt; ElectionState:\n        \"\"\"\n        Simulates a single step of the sequential RCV contest or a full\n        IRV election run on the current set of candidates.\n\n         Returns:\n           An ElectionState object for a given round.\n        \"\"\"\n        old_election_state = self.state\n\n        IRVrun = STV(\n            old_profile, transfer=seqRCV_transfer, seats=1, tiebreak=self.tiebreak\n        )\n        old_election = IRVrun.run_election()\n        elected_cand = old_election.winners()[0]\n\n        # Removes elected candidate from Ballot List\n        updated_ballots = remove_cand(elected_cand, old_profile.get_ballots())\n\n        # Updates profile with removed candidates\n        updated_profile = PreferenceProfile(ballots=updated_ballots)\n\n        self.state = ElectionState(\n            curr_round=old_election_state.curr_round + 1,\n            elected=[elected_cand],\n            profile=updated_profile,\n            previous=old_election_state,\n            scores=first_place_votes(updated_profile),\n            remaining=old_election.remaining,\n        )\n        return self.state\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete sequential RCV contest.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        old_profile = self._profile\n        elected = []  # type: ignore\n        seqRCV_step = self.state\n\n        while len(elected) &lt; self.seats:\n            seqRCV_step = self.run_step(old_profile)\n            elected.append(seqRCV_step.elected)\n            old_profile = seqRCV_step.profile\n        return seqRCV_step\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete sequential RCV contest.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete sequential RCV contest.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    old_profile = self._profile\n    elected = []  # type: ignore\n    seqRCV_step = self.state\n\n    while len(elected) &lt; self.seats:\n        seqRCV_step = self.run_step(old_profile)\n        elected.append(seqRCV_step.elected)\n        old_profile = seqRCV_step.profile\n    return seqRCV_step\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV.run_step","title":"<code>run_step(old_profile)</code>","text":"<p>Simulates a single step of the sequential RCV contest or a full IRV election run on the current set of candidates.</p> <p>Returns:    An ElectionState object for a given round.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self, old_profile: PreferenceProfile) -&gt; ElectionState:\n    \"\"\"\n    Simulates a single step of the sequential RCV contest or a full\n    IRV election run on the current set of candidates.\n\n     Returns:\n       An ElectionState object for a given round.\n    \"\"\"\n    old_election_state = self.state\n\n    IRVrun = STV(\n        old_profile, transfer=seqRCV_transfer, seats=1, tiebreak=self.tiebreak\n    )\n    old_election = IRVrun.run_election()\n    elected_cand = old_election.winners()[0]\n\n    # Removes elected candidate from Ballot List\n    updated_ballots = remove_cand(elected_cand, old_profile.get_ballots())\n\n    # Updates profile with removed candidates\n    updated_profile = PreferenceProfile(ballots=updated_ballots)\n\n    self.state = ElectionState(\n        curr_round=old_election_state.curr_round + 1,\n        elected=[elected_cand],\n        profile=updated_profile,\n        previous=old_election_state,\n        scores=first_place_votes(updated_profile),\n        remaining=old_election.remaining,\n    )\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo","title":"<code>TopTwo</code>","text":"<p>             Bases: <code>Election</code></p> <p>Eliminates all but the top two plurality vote getters, and then conducts a runoff between them, reallocating other ballots.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on.</p> <p><code>seats</code> :   number of seats to be elected.</p> <p><code>ballot_ties</code> :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.                 Defaults to True.</p> <p><code>tiebreak</code> :   (optional) resolves procedural and final ties by specified tiebreak.                 Can either be a custom tiebreak function or a string. Supported strings are                 given in <code>tie_broken_ranking</code> documentation. The custom function must take as                 input two named parameters; <code>ranking</code>, a list-of-sets ranking of candidates and                 <code>profile</code>, the original <code>PreferenceProfile</code>. It must return a list-of-sets                 ranking of candidates with no ties. Defaults to random tiebreak.</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class TopTwo(Election):\n    \"\"\"\n    Eliminates all but the top two plurality vote getters, and then\n    conducts a runoff between them, reallocating other ballots.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on.\n\n    `seats`\n    :   number of seats to be elected.\n\n    `ballot_ties`\n    :   (optional) resolves input ballot ties if True, else assumes ballots have no ties.\n                    Defaults to True.\n\n     `tiebreak`\n    :   (optional) resolves procedural and final ties by specified tiebreak.\n                    Can either be a custom tiebreak function or a string. Supported strings are\n                    given in `tie_broken_ranking` documentation. The custom function must take as\n                    input two named parameters; `ranking`, a list-of-sets ranking of candidates and\n                    `profile`, the original `PreferenceProfile`. It must return a list-of-sets\n                    ranking of candidates with no ties. Defaults to random tiebreak.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        ballot_ties: bool = True,\n        tiebreak: Union[str, Callable] = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a TopTwo election for one seat with a cutoff of 2 for the runoff.\n\n        Returns:\n            An ElectionState object for the TopTwo election.\n        \"\"\"\n        hybrid_equivalent = SNTV_STV_Hybrid(\n            profile=self.state.profile,\n            transfer=fractional_transfer,\n            r1_cutoff=2,\n            seats=1,\n            tiebreak=self.tiebreak,\n        )\n        outcome = hybrid_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    @lru_cache\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete TopTwo election.\n\n        Returns:\n            An ElectionState object for a complete election.\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo.run_election","title":"<code>run_election()</code>  <code>cached</code>","text":"<p>Simulates a complete TopTwo election.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>@lru_cache\ndef run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete TopTwo election.\n\n    Returns:\n        An ElectionState object for a complete election.\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a TopTwo election for one seat with a cutoff of 2 for the runoff.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for the TopTwo election.</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a TopTwo election for one seat with a cutoff of 2 for the runoff.\n\n    Returns:\n        An ElectionState object for the TopTwo election.\n    \"\"\"\n    hybrid_equivalent = SNTV_STV_Hybrid(\n        profile=self.state.profile,\n        transfer=fractional_transfer,\n        r1_cutoff=2,\n        seats=1,\n        tiebreak=self.tiebreak,\n    )\n    outcome = hybrid_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#cleaning","title":"Cleaning","text":""},{"location":"api/#votekit.cleaning.clean_profile","title":"<code>clean_profile(pp, clean_ballot_func)</code>","text":"<p>Allows user-defined cleaning rules for PreferenceProfile. Input function that applies modification or rule to a single ballot.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>A PreferenceProfile to clean.</p> required <code>clean_ballot_func</code> <code>Callable[[Ballot], Ballot]</code> <p>Function that takes a list of ballots and cleans each ballot.</p> required <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A cleaned PreferenceProfile.</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def clean_profile(\n    pp: PreferenceProfile, clean_ballot_func: Callable[[Ballot], Ballot]\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Allows user-defined cleaning rules for PreferenceProfile. Input function\n    that applies modification or rule to a single ballot.\n\n    Args:\n        pp (PreferenceProfile): A PreferenceProfile to clean.\n        clean_ballot_func (Callable[[Ballot], Ballot]): Function that\n            takes a list of ballots and cleans each ballot.\n\n    Returns:\n        (PreferenceProfile): A cleaned PreferenceProfile.\n    \"\"\"\n\n    # apply cleaning function to clean all ballots\n    if clean_ballot_func is not None:\n        cleaned = map(clean_ballot_func, pp.ballots)\n    # group ballots that have the same ranking after cleaning\n    grouped_ballots = [\n        list(result)\n        for key, result in groupby(cleaned, key=lambda ballot: ballot.ranking)\n    ]\n    # merge ballots in the same groups\n    new_ballots = [merge_ballots(b) for b in grouped_ballots]\n    return PreferenceProfile(ballots=new_ballots)\n</code></pre>"},{"location":"api/#votekit.cleaning.deduplicate_profiles","title":"<code>deduplicate_profiles(pp)</code>","text":"<p>Given a PreferenceProfile, deduplicates its ballots.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>A PreferenceProfile to clean.</p> required <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A cleaned PreferenceProfile without duplicates.</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def deduplicate_profiles(pp: PreferenceProfile) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a PreferenceProfile, deduplicates its ballots.\n\n    Args:\n        pp (PreferenceProfile): A PreferenceProfile to clean.\n\n    Returns:\n        (PreferenceProfile): A cleaned PreferenceProfile without duplicates.\n    \"\"\"\n\n    def deduplicate_ballots(ballot: Ballot) -&gt; Ballot:\n        \"\"\"\n        Takes a ballot and deduplicates its rankings.\n\n        Args:\n            ballot (Ballot): a ballot with duplicates in its ranking.\n\n        Returns:\n            Ballot: a ballot without duplicates.\n        \"\"\"\n        ranking = ballot.ranking\n        dedup_ranking = []\n        for cand in ranking:\n            if cand in ranking and cand not in dedup_ranking:\n                dedup_ranking.append(cand)\n        new_ballot = Ballot(\n            id=ballot.id,\n            weight=Fraction(ballot.weight),\n            ranking=tuple(dedup_ranking),\n            voter_set=ballot.voter_set,\n        )\n        return new_ballot\n\n    pp_clean = clean_profile(pp=pp, clean_ballot_func=deduplicate_ballots)\n    return pp_clean\n</code></pre>"},{"location":"api/#votekit.cleaning.merge_ballots","title":"<code>merge_ballots(ballots)</code>","text":"<p>Takes a list of ballots with the same ranking and merge them into one ballot.</p> <p>Parameters:</p> Name Type Description Default <code>ballots</code> <code>list[Ballot]</code> <p>A list of ballots to deduplicate.</p> required <p>Returns:</p> Type Description <code>Ballot</code> <p>A ballot with the same ranking and aggregated weight and voters.</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def merge_ballots(ballots: list[Ballot]) -&gt; Ballot:\n    \"\"\"\n    Takes a list of ballots with the same ranking and merge them into one ballot.\n\n    Args:\n        ballots (list[Ballot]): A list of ballots to deduplicate.\n\n    Returns:\n        (Ballot): A ballot with the same ranking and aggregated weight and voters.\n    \"\"\"\n    weight = sum(b.weight for b in ballots)\n    ranking = ballots[0].ranking\n    voters_to_merge = [b.voter_set for b in ballots if b.voter_set]\n    voter_set = None\n    if len(voters_to_merge) &gt; 0:\n        voter_set = reduce(lambda b1, b2: b1.union(b2), voters_to_merge)\n        voter_set = set(voter_set)\n    return Ballot(ranking=ranking, voter_set=voter_set, weight=Fraction(weight))\n</code></pre>"},{"location":"api/#votekit.cleaning.remove_empty_ballots","title":"<code>remove_empty_ballots(pp, keep_candidates=False)</code>","text":"<p>Removes empty ballots from a PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>A PreferenceProfile to clean.</p> required <code>keep_candidates</code> <code>bool</code> <p>If True, keep all of the candidates from the original PreferenceProfile in the returned PreferenceProfile, even if they got no votes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A cleaned PreferenceProfile.</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def remove_empty_ballots(\n    pp: PreferenceProfile, keep_candidates: bool = False\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Removes empty ballots from a PreferenceProfile.\n\n    Args:\n        pp (PreferenceProfile): A PreferenceProfile to clean.\n        keep_candidates (bool, optional): If True, keep all of the candidates\n            from the original PreferenceProfile in the returned PreferenceProfile, even if\n            they got no votes. Defaults to False.\n\n    Returns:\n        (PreferenceProfile): A cleaned PreferenceProfile.\n    \"\"\"\n\n    ballots_nonempty = [\n        deepcopy(ballot) for ballot in pp.get_ballots() if ballot.ranking\n    ]\n    if keep_candidates:\n        old_cands = deepcopy(pp.get_candidates())\n        pp_clean = PreferenceProfile(ballots=ballots_nonempty, candidates=old_cands)\n    else:\n        pp_clean = PreferenceProfile(ballots=ballots_nonempty)\n    return pp_clean\n</code></pre>"},{"location":"api/#votekit.cleaning.remove_noncands","title":"<code>remove_noncands(profile, non_cands)</code>","text":"<p>Removes user-assigned non-candidates from ballots, deletes ballots that are empty as a result of the removal.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>A PreferenceProfile to clean.</p> required <code>non_cands</code> <code>list[str]</code> <p>A list of non-candidates to be removed.</p> required <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A profile with non-candidates removed.</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def remove_noncands(\n    profile: PreferenceProfile, non_cands: list[str]\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Removes user-assigned non-candidates from ballots, deletes ballots\n    that are empty as a result of the removal.\n\n    Args:\n        profile (PreferenceProfile): A PreferenceProfile to clean.\n        non_cands (list[str]): A list of non-candidates to be removed.\n\n    Returns:\n        (PreferenceProfile): A profile with non-candidates removed.\n    \"\"\"\n\n    def remove_from_ballots(ballot: Ballot, non_cands: list[str]) -&gt; Ballot:\n        \"\"\"\n        Removes non-candidiates from ballot objects.\n\n        Args:\n            ballot (Ballot): a ballot to be cleaned.\n            non_cands (list[str]): a list of candidates to remove.\n\n        Returns:\n            Ballot: returns a cleaned Ballot.\n        \"\"\"\n        # TODO: adjust so string and list of strings are acceptable inputes\n\n        to_remove = []\n        for item in non_cands:\n            to_remove.append({item})\n\n        ranking = ballot.ranking\n        clean_ranking = []\n        for cand in ranking:\n            if cand not in to_remove and cand not in clean_ranking:\n                clean_ranking.append(cand)\n\n        clean_ballot = Ballot(\n            id=ballot.id,\n            ranking=tuple(clean_ranking),\n            weight=Fraction(ballot.weight),\n            voter_set=ballot.voter_set,\n        )\n\n        return clean_ballot\n\n    cleaned = [\n        remove_from_ballots(ballot, non_cands)\n        for ballot in profile.ballots\n        if remove_from_ballots(ballot, non_cands).ranking\n    ]\n    grouped_ballots = [\n        list(result)\n        for key, result in groupby(cleaned, key=lambda ballot: ballot.ranking)\n    ]\n    # merge ballots in the same groups\n    new_ballots = [merge_ballots(b) for b in grouped_ballots]\n    return PreferenceProfile(ballots=new_ballots)\n</code></pre>"},{"location":"api/#metrics","title":"Metrics","text":""},{"location":"api/#votekit.utils.borda_scores","title":"<code>borda_scores(profile, ballot_length=None, score_vector=None)</code>","text":"<p>Calculates Borda scores for a PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed PreferenceProfile of ballots.</p> required <code>ballot_length</code> <code>Optional[int]</code> <p>Length of a ballot, if None length of longest ballot is used.</p> <code>None</code> <code>score_vector</code> <code>Optional[list]</code> <p>Borda weights, if None, vector is assigned \\((n,n-1,\\dots,1)\\).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and Borda scores (values).</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def borda_scores(\n    profile: PreferenceProfile,\n    ballot_length: Optional[int] = None,\n    score_vector: Optional[list] = None,\n) -&gt; dict:\n    \"\"\"\n    Calculates Borda scores for a PreferenceProfile.\n\n    Args:\n        profile: Inputed PreferenceProfile of ballots.\n        ballot_length: Length of a ballot, if None length of longest ballot is\n            used.\n        score_vector: Borda weights, if None, vector is assigned $(n,n-1,\\dots,1)$.\n\n    Returns:\n        (dict): Dictionary of candidates (keys) and Borda scores (values).\n    \"\"\"\n    candidates = profile.get_candidates()\n    if ballot_length is None:\n        ballot_length = max([len(ballot.ranking) for ballot in profile.ballots])\n    if score_vector is None:\n        score_vector = list(range(ballot_length, 0, -1))\n\n    candidate_borda = {c: Fraction(0) for c in candidates}\n    for ballot in profile.ballots:\n        current_ind = 0\n        candidates_covered = []\n        for s in ballot.ranking:\n            position_size = len(s)\n            local_score_vector = score_vector[current_ind : current_ind + position_size]\n            borda_allocation = sum(local_score_vector) / position_size\n            for c in s:\n                candidate_borda[c] += Fraction(borda_allocation) * ballot.weight\n            current_ind += position_size\n            candidates_covered += list(s)\n\n        # If ballot was incomplete, evenly allocation remaining points\n        if current_ind &lt; len(score_vector):\n            remainder_cands = set(candidates).difference(set(candidates_covered))\n            remainder_score_vector = score_vector[current_ind:]\n            remainder_borda_allocation = sum(remainder_score_vector) / len(\n                remainder_cands\n            )\n            for c in remainder_cands:\n                candidate_borda[c] += (\n                    Fraction(remainder_borda_allocation) * ballot.weight\n                )\n\n    return candidate_borda\n</code></pre>"},{"location":"api/#votekit.utils.first_place_votes","title":"<code>first_place_votes(profile, to_float=False)</code>","text":"<p>Calculates first-place votes for a PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed PreferenceProfile of ballots.</p> required <code>to_float</code> <code>bool</code> <p>If True, compute first place votes as floats instead of Fractions. Defaults to         False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and first place vote totals (values).</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def first_place_votes(profile: PreferenceProfile, to_float: bool = False) -&gt; dict:\n    \"\"\"\n    Calculates first-place votes for a PreferenceProfile.\n\n    Args:\n        profile: Inputed PreferenceProfile of ballots.\n\n        to_float: If True, compute first place votes as floats instead of Fractions. Defaults to\n                    False.\n\n    Returns:\n        Dictionary of candidates (keys) and first place vote totals (values).\n    \"\"\"\n    cands = profile.get_candidates()\n    ballots = profile.get_ballots()\n\n    _, votes_dict = compute_votes(cands, ballots)\n\n    if to_float:\n        votes_dict = {k: float(v) for k, v in votes_dict.items()}\n        return votes_dict\n    else:\n        return votes_dict\n</code></pre>"},{"location":"api/#votekit.utils.mentions","title":"<code>mentions(profile)</code>","text":"<p>Calculates total mentions for a PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed PreferenceProfile of ballots.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and mention totals (values).</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def mentions(profile: PreferenceProfile) -&gt; dict:\n    \"\"\"\n    Calculates total mentions for a PreferenceProfile.\n\n    Args:\n        profile: Inputed PreferenceProfile of ballots.\n\n    Returns:\n        Dictionary of candidates (keys) and mention totals (values).\n    \"\"\"\n    mentions: dict[str, float] = {}\n\n    ballots = profile.get_ballots()\n    for ballot in ballots:\n        for rank in ballot.ranking:\n            for cand in rank:\n                if cand not in mentions:\n                    mentions[cand] = 0\n                if len(rank) &gt; 1:\n                    mentions[cand] += (1 / len(rank)) * int(\n                        ballot.weight\n                    )  # split mentions for candidates that are tied\n                else:\n                    mentions[cand] += float(ballot.weight)\n\n    return mentions\n</code></pre>"},{"location":"api/#votekit.metrics.distances.earth_mover_dist","title":"<code>earth_mover_dist(pp1, pp2)</code>","text":"<p>Computes the earth mover distance between two elections. Assumes both elections share the same candidates.</p> <p>Parameters:</p> Name Type Description Default <code>pp1</code> <code>PreferenceProfile</code> <p>PreferenceProfile for first election.</p> required <code>pp2</code> <code>PreferenceProfile</code> <p>PreferenceProfile for second election.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Earth mover distance between inputted elections.</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def earth_mover_dist(pp1: PreferenceProfile, pp2: PreferenceProfile) -&gt; int:\n    \"\"\"\n    Computes the earth mover distance between two elections.\n    Assumes both elections share the same candidates.\n\n    Args:\n        pp1: PreferenceProfile for first election.\n        pp2: PreferenceProfile for second election.\n\n    Returns:\n        Earth mover distance between inputted elections.\n    \"\"\"\n    # create ballot graph\n    ballot_graph = BallotGraph(source=pp2).graph\n    # ballot_graph = graph.from_profile(profile=pp2, complete=True)\n\n    # Solving Earth Mover Distance\n    electA_distr = np.array(em_array(pp=pp1))\n    electB_distr = np.array(em_array(pp=pp2))\n\n    # Floyd Warshall Shortest Distance alorithm. Returns a dictionary of shortest path for each node\n    fw_dist_dict = nx.floyd_warshall(ballot_graph)\n    keys_list = sorted(fw_dist_dict.keys())\n    cost_matrix = np.zeros((len(keys_list), len(keys_list)))\n    for i in range(len(keys_list)):\n        node_dict = fw_dist_dict[keys_list[i]]\n        cost_col = [value for key, value in sorted(node_dict.items())]\n        cost_matrix[i] = cost_col\n    earth_mover_matrix = ot.emd(electA_distr, electB_distr, cost_matrix)\n\n    # Hadamard Product = Earth mover dist between two matrices\n    earth_mover_dist = np.sum(np.multiply(cost_matrix, earth_mover_matrix))\n    return earth_mover_dist\n</code></pre>"},{"location":"api/#votekit.metrics.distances.lp_dist","title":"<code>lp_dist(pp1, pp2, p_value=1)</code>","text":"<p>Computes the L_p distance between two election distributions. Use 'inf' for infinity norm. Assumes both elections share the same candidates.</p> <p>Parameters:</p> Name Type Description Default <code>pp1</code> <code>PreferenceProfile</code> <p>PreferenceProfile for first election.</p> required <code>pp2</code> <code>PreferenceProfile</code> <p>PreferenceProfile for second election.</p> required <code>p_value</code> <code>Optional[Union[int, str]]</code> <p>Distance parameter, 1 for Manhattan, 2 for Euclidean or 'inf' for Chebyshev distance.</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>Lp distance between two elections.</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def lp_dist(\n    pp1: PreferenceProfile,\n    pp2: PreferenceProfile,\n    p_value: Optional[Union[int, str]] = 1,\n) -&gt; int:\n    \"\"\"\n    Computes the L_p distance between two election distributions.\n    Use 'inf' for infinity norm.\n    Assumes both elections share the same candidates.\n\n    Args:\n        pp1: PreferenceProfile for first election.\n        pp2: PreferenceProfile for second election.\n        p_value: Distance parameter, 1 for Manhattan, 2 for Euclidean\n            or 'inf' for Chebyshev distance.\n\n    Returns:\n        Lp distance between two elections.\n    \"\"\"\n    pp_list = [pp1, pp2]\n    pp_2arry = profiles_to_ndarrys(pp_list)\n    electA = pp_2arry[:, 0]\n    electB = pp_2arry[:, 1]\n\n    if isinstance(p_value, int):\n        sum = 0\n        for i in range(len(electA)):\n            diff = (abs(electA[i] - electB[i])) ** p_value\n            sum += diff\n        lp_dist = sum ** (1 / p_value)\n        return lp_dist\n\n    elif p_value == \"inf\":\n        diff = [abs(x - y) for x, y in zip(electA, electB)]\n        return max(diff)\n\n    else:\n        raise ValueError(\"Unsupported input type\")\n</code></pre>"},{"location":"api/#votekit.metrics.distances.em_array","title":"<code>em_array(pp)</code>","text":"<p>Converts a PreferenceProfile into a distribution using ballot graphs.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>PreferenceProfile for a given election.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Distribution of ballots for an election.</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def em_array(pp: PreferenceProfile) -&gt; list:\n    \"\"\"\n    Converts a PreferenceProfile into a distribution using ballot graphs.\n\n    Args:\n        pp: PreferenceProfile for a given election.\n\n    Returns:\n        Distribution of ballots for an election.\n    \"\"\"\n    ballot_graph = BallotGraph(source=pp)\n    node_cand_map = ballot_graph.label_cands(sorted(pp.get_candidates()))\n    pp_dict = pp.to_dict(True)\n\n    # invert node_cand_map to map to pp_dict\n    # split is used to remove the custom labeling from the ballotgraph\n    inverted = {v.split(\":\")[0]: k for k, v in node_cand_map.items()}\n    combined_dict = {k: 0 for k in node_cand_map}\n\n    # map nodes with weight of corresponding rank\n    # labels on ballotgraph are strings so need to convert key to string\n    node_pp_dict = {inverted[str(key)]: pp_dict[key] for key in pp_dict}\n\n    complete_election_dict = combined_dict | node_pp_dict\n    elect_distr = [\n        float(complete_election_dict[key])\n        for key in sorted(complete_election_dict.keys())\n    ]\n\n    return elect_distr\n</code></pre>"},{"location":"api/#votekit.elections.transfers.fractional_transfer","title":"<code>fractional_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Calculates fractional transfer from winner, then removes winner from the list of ballots.</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from.</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects.</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals.</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value.</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Modified ballots with transfered weights and the winning candidate removed.</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def fractional_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Calculates fractional transfer from winner, then removes winner\n    from the list of ballots.\n\n    Args:\n        winner: Candidate to transfer votes from.\n        ballots: List of Ballot objects.\n        votes: Contains candidates and their corresponding vote totals.\n        threshold: Value required to be elected, used to calculate transfer value.\n\n    Returns:\n        Modified ballots with transfered weights and the winning candidate removed.\n    \"\"\"\n    transfer_value = (votes[winner] - threshold) / votes[winner]\n\n    transfered_ballots = []\n    for ballot in ballots:\n        new_ranking = []\n        if ballot.ranking and ballot.ranking[0] == {winner}:\n            transfered_weight = ballot.weight * transfer_value\n            for cand in ballot.ranking:\n                if cand != {winner}:\n                    new_ranking.append(frozenset(cand))\n            transfered_ballots.append(\n                Ballot(\n                    ranking=tuple(new_ranking),\n                    weight=transfered_weight,\n                    voter_set=ballot.voter_set,\n                    id=ballot.id,\n                )\n            )\n        else:\n            transfered_ballots.append(ballot)\n\n    return remove_cand(winner, transfered_ballots)\n</code></pre>"},{"location":"api/#votekit.elections.transfers.seqRCV_transfer","title":"<code>seqRCV_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Transfer method for Sequential RCV elections.</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from.</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects.</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals.</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value.</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Original list of ballots as Sequential RCV does not transfer votes.</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def seqRCV_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Transfer method for Sequential RCV elections.\n\n    Args:\n        winner: Candidate to transfer votes from.\n        ballots: List of Ballot objects.\n        votes: Contains candidates and their corresponding vote totals.\n        threshold: Value required to be elected, used to calculate transfer value.\n\n    Returns:\n        Original list of ballots as Sequential RCV does not transfer votes.\n    \"\"\"\n    return ballots\n</code></pre>"},{"location":"api/#votekit.elections.transfers.random_transfer","title":"<code>random_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Cambridge-style transfer where transfer ballots are selected randomly.</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from.</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects.</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals.</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value.</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Modified ballots with transferred weights and the winning candidate removed.</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def random_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Cambridge-style transfer where transfer ballots are selected randomly.\n\n    Args:\n        winner: Candidate to transfer votes from.\n        ballots: List of Ballot objects.\n        votes: Contains candidates and their corresponding vote totals.\n        threshold: Value required to be elected, used to calculate transfer value.\n\n    Returns:\n        Modified ballots with transferred weights and the winning candidate removed.\n    \"\"\"\n\n    # turn all of winner's ballots into (multiple) ballots of weight 1\n    weight_1_ballots = []\n    updated_ballots = []\n    for ballot in ballots:\n        if ballot.ranking and ballot.ranking[0] == {winner}:\n            # note: under random transfer, weights should always be integers\n            for _ in range(int(ballot.weight)):\n                weight_1_ballots.append(\n                    Ballot(\n                        id=ballot.id,\n                        ranking=ballot.ranking,\n                        weight=Fraction(1),\n                        voter_set=ballot.voter_set,\n                    )\n                )\n        else:\n            updated_ballots.append(ballot)\n\n    surplus_ballots = random.sample(weight_1_ballots, int(votes[winner]) - threshold)\n    updated_ballots += surplus_ballots\n\n    return remove_cand(winner, updated_ballots)\n</code></pre>"},{"location":"api/#plotting","title":"Plotting","text":""},{"location":"api/#votekit.plots.mds.compute_MDS","title":"<code>compute_MDS(data, distance, random_seed=47, *args, **kwargs)</code>","text":"<p>Computes the coordinates of an MDS plot. This is time intensive, so it is decoupled from <code>plot_mds</code> to allow users to flexibly use the coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, list[PreferenceProfile]]</code> <p>Dictionary with key being a string label and value being list of         PreferenceProfiles. ex: {'PL with alpha = 4': list[PreferenceProfile]}</p> required <code>distance</code> <code>Callable[..., int]</code> <p>Distance function. See distance.py.</p> required <code>random_seed</code> <code>int</code> <p>an integer seed to allow for reproducible MDS plots. Defaults to 47.</p> <code>47</code> <p>Returns:</p> Name Type Description <code>coord_dict</code> <code>dict</code> <p>a dictionary whose keys match <code>data</code> and whose values are tuples of</p> <p>numpy arrays (x_list, y_list) of coordinates for the MDS plot.</p> Source code in <code>src/votekit/plots/mds.py</code> <pre><code>def compute_MDS(\n    data: Dict[str, list[PreferenceProfile]],\n    distance: Callable[..., int],\n    random_seed: int = 47,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Computes the coordinates of an MDS plot. This is time intensive, so it is decoupled from\n    `plot_mds` to allow users to flexibly use the coordinates.\n\n    Args:\n        data: Dictionary with key being a string label and value being list of\n                    PreferenceProfiles. ex: {'PL with alpha = 4': list[PreferenceProfile]}\n        distance: Distance function. See distance.py.\n        random_seed (int): an integer seed to allow for reproducible MDS plots. Defaults to 47.\n\n    Returns:\n        coord_dict (dict): a dictionary whose keys match `data` and whose values are tuples of\n        numpy arrays (x_list, y_list) of coordinates for the MDS plot.\n    \"\"\"\n    # combine all lists to create distance matrix\n    combined_pp = []\n    for pp_list in data.values():\n        combined_pp.extend(pp_list)\n\n    # compute distance matrix\n    dist_matrix = distance_matrix(combined_pp, distance, *args, **kwargs)\n\n    mds = manifold.MDS(\n        n_components=2,\n        max_iter=3000,\n        eps=1e-9,\n        dissimilarity=\"precomputed\",\n        n_jobs=1,\n        normalized_stress=\"auto\",\n        random_state=random_seed,\n    )\n    pos = mds.fit(np.array(dist_matrix)).embedding_\n\n    coord_dict = {}\n    start_pos = 0\n    for key, value_list in data.items():\n        # color, label, marker = key\n        end_pos = start_pos + len(value_list)\n        coord_dict[key] = (pos[start_pos:end_pos, 0], pos[start_pos:end_pos, 1])\n        start_pos += len(value_list)\n\n    return coord_dict\n</code></pre>"},{"location":"api/#votekit.plots.mds.distance_matrix","title":"<code>distance_matrix(pp_arr, distance, *args, **kwargs)</code>","text":"<p>Creates pairwise distance matrix between PreferenceProfile. The \\((i,j)\\) entry is the pairwise distance between \\(i\\)th and the \\(j\\)th PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>pp_arr</code> <code>list[PreferenceProfile]</code> <p>List of PreferenceProfiles.</p> required <code>distance</code> <code>Callable[..., int]</code> <p>Callable distance function type. See distances.py in the metrics module.</p> required <p>Returns:</p> Name Type Description <code>dist_matrix</code> <code>ndarray</code> <p>Distance matrix for an election.</p> Source code in <code>src/votekit/plots/mds.py</code> <pre><code>def distance_matrix(\n    pp_arr: list[PreferenceProfile], distance: Callable[..., int], *args, **kwargs\n):\n    \"\"\"\n    Creates pairwise distance matrix between PreferenceProfile. The $(i,j)$ entry is the pairwise\n    distance between $i$th and the $j$th PreferenceProfile.\n\n    Args:\n        pp_arr: List of PreferenceProfiles.\n        distance: Callable distance function type. See distances.py in the metrics module.\n\n    Returns:\n        dist_matrix (ndarray): Distance matrix for an election.\n    \"\"\"\n    rows = len(pp_arr)\n    dist_matrix = np.zeros((rows, rows))\n\n    for i in range(rows):\n        for j in range(i + 1, rows):\n            dist_matrix[i][j] = distance(pp_arr[i], pp_arr[j], *args, **kwargs)\n            dist_matrix[j][i] = dist_matrix[i][j]\n    return dist_matrix\n</code></pre>"},{"location":"api/#votekit.plots.mds.plot_MDS","title":"<code>plot_MDS(coord_dict, plot_kwarg_dict=None, legend=True, title=True)</code>","text":"<p>Creates an MDS plot from the output of <code>compute_MDS</code> with legend labels matching the keys of <code>coord_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>coord_dict</code> <code>dict</code> <p>Dictionary with key being a string label and value being tuple</p> required <code>plot_kwarg_dict</code> <code>Optional[dict]</code> <p>Dictionary with keys matching coord_dict and values are kwarg dictionaries that will be passed to matplotlib <code>scatter</code>.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>boolean for plotting the legend. Defaults to True.</p> <code>True</code> <code>title</code> <code>bool</code> <p>boolean for plotting the title. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>fig</code> <p>a matplotlib fig</p> Source code in <code>src/votekit/plots/mds.py</code> <pre><code>def plot_MDS(\n    coord_dict: dict,\n    plot_kwarg_dict: Optional[dict] = None,\n    legend: bool = True,\n    title: bool = True,\n):\n    \"\"\"\n    Creates an MDS plot from the output of `compute_MDS` with legend labels matching the keys\n    of `coord_dict`.\n\n    Args:\n        coord_dict: Dictionary with key being a string label and value being tuple\n        (x_list, y_list), coordinates for the MDS plot.\n        Should be piped in from `compute_MDS`.\n\n        plot_kwarg_dict: Dictionary with keys matching coord_dict and values are kwarg dictionaries\n            that will be passed to matplotlib `scatter`.\n\n        legend: boolean for plotting the legend. Defaults to True.\n\n        title: boolean for plotting the title. Defaults to True.\n\n    Returns:\n        fig: a matplotlib fig\n    \"\"\"\n\n    # Plot data\n    fig, ax = plt.subplots()\n\n    for key, value in coord_dict.items():\n        x, y = value\n        if plot_kwarg_dict and key in plot_kwarg_dict:\n            ax.scatter(x, y, label=key, **plot_kwarg_dict[key])\n        else:\n            ax.scatter(x, y, label=key)\n\n    if title:\n        ax.set_title(\"MDS Plot for Pairwise Election Distances\")\n    if legend:\n        ax.legend()\n\n    ax.set_aspect(\"equal\")\n\n    return fig\n</code></pre>"},{"location":"api/#votekit.plots.profile_plots.plot_summary_stats","title":"<code>plot_summary_stats(profile, stat, multi_color=True, title='')</code>","text":"<p>Plots histogram of election summary statistics.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>A PreferenceProfile to visualize.</p> required <code>stat</code> <code>str</code> <p>'first place votes', 'mentions', or 'borda'.</p> required <code>multi_color</code> <code>bool</code> <p>If the bars should be multicolored. Defaults to True.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title for the figure. Defaults to None.</p> <code>''</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A figure with the visualization.</p> Source code in <code>src/votekit/plots/profile_plots.py</code> <pre><code>def plot_summary_stats(\n    profile: PreferenceProfile, stat: str, multi_color: bool = True, title: str = \"\"\n) -&gt; Figure:\n    \"\"\"\n    Plots histogram of election summary statistics.\n\n    Args:\n        profile (PreferenceProfile): A PreferenceProfile to visualize.\n        stat (str): 'first place votes', 'mentions', or 'borda'.\n        multi_color (bool, optional): If the bars should be multicolored. Defaults to True.\n        title (str, optional): Title for the figure. Defaults to None.\n\n    Returns:\n        (Figure): A figure with the visualization.\n    \"\"\"\n    stats = {\n        \"first place votes\": first_place_votes,\n        \"mentions\": mentions,\n        \"borda\": borda_scores,\n    }\n\n    stat_func = stats[stat]\n    data: dict = stat_func(profile)  # type: ignore\n\n    if multi_color:\n        colors = COLOR_LIST[: len(list(data.keys()))]\n    else:\n        colors = [COLOR_LIST[-1]]\n\n    fig, ax = plt.subplots()\n\n    candidates = profile.get_candidates(received_votes=False)\n    y_data = [data[c] for c in candidates]\n\n    ax.bar(candidates, y_data, color=colors, width=0.35)\n    ax.set_xlabel(\"Candidates\")\n    ax.set_ylabel(\"Frequency\")\n\n    if title:\n        ax.set_title(title)\n\n    return fig\n</code></pre>"},{"location":"api/#utils","title":"Utils","text":""},{"location":"api/#votekit.utils.compute_votes","title":"<code>compute_votes(candidates, ballots)</code>","text":"<p>Computes first place votes for all candidates in a PreferenceProfile.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>list</code> <p>List of all candidates in a PreferenceProfile.</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects.</p> required <p>Returns:</p> Type Description <code>tuple[list[CandidateVotes], dict]</code> <p>A tuple (ordered, votes) where ordered is a list of tuples (cand, first place votes) ordered by decreasing first place votes and votes is a dictionary whose keys are candidates and values are first place votes.</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def compute_votes(\n    candidates: list,\n    ballots: list[Ballot],\n) -&gt; tuple[list[CandidateVotes], dict]:\n    \"\"\"\n    Computes first place votes for all candidates in a PreferenceProfile.\n\n    Args:\n        candidates: List of all candidates in a PreferenceProfile.\n        ballots: List of Ballot objects.\n\n    Returns:\n        A tuple (ordered, votes) where ordered is a list of tuples (cand, first place votes)\n            ordered by decreasing first place votes and votes is a dictionary whose keys are\n            candidates and values are first place votes.\n    \"\"\"\n    votes = {cand: Fraction(0) for cand in candidates}\n\n    for ballot in ballots:\n        if not ballot.ranking:\n            continue\n        first_place_cand = unset(ballot.ranking[0])\n        if isinstance(first_place_cand, list):\n            for cand in first_place_cand:\n                votes[cand] += ballot.weight / len(first_place_cand)\n        else:\n            votes[first_place_cand] += ballot.weight\n\n    ordered = [\n        CandidateVotes(cand=key, votes=value)\n        for key, value in sorted(votes.items(), key=lambda x: x[1], reverse=True)\n    ]\n\n    return ordered, votes\n</code></pre>"},{"location":"api/#votekit.utils.remove_cand","title":"<code>remove_cand(removed, ballots)</code>","text":"<p>Removes specified candidate(s) from ballots.</p> <p>Parameters:</p> Name Type Description Default <code>removed</code> <code>Union[str, Iterable]</code> <p>Candidate or set of candidates to be removed.</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballots to remove candidate(s) from.</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Updated list of ballots with candidate(s) removed.</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def remove_cand(removed: Union[str, Iterable], ballots: list[Ballot]) -&gt; list[Ballot]:\n    \"\"\"\n    Removes specified candidate(s) from ballots.\n\n    Args:\n        removed: Candidate or set of candidates to be removed.\n        ballots: List of Ballots to remove candidate(s) from.\n\n    Returns:\n        Updated list of ballots with candidate(s) removed.\n    \"\"\"\n\n    if isinstance(removed, str):\n        remove_set = {removed}\n    elif isinstance(removed, Iterable):\n        remove_set = set(removed)\n\n    update = []\n    for ballot in ballots:\n        new_ranking = []\n        if len(remove_set) == 1 and remove_set in ballot.ranking:\n            for s in ballot.ranking:\n                new_s = s.difference(remove_set)\n                if new_s:\n                    new_ranking.append(new_s)\n            update.append(\n                Ballot(\n                    id=ballot.id,\n                    ranking=tuple(new_ranking),\n                    weight=ballot.weight,\n                    voter_set=ballot.voter_set,\n                )\n            )\n        elif len(remove_set) &gt; 1:\n            for s in ballot.ranking:\n                new_s = s.difference(remove_set)\n                if new_s:\n                    new_ranking.append(new_s)\n            update.append(\n                Ballot(\n                    id=ballot.id,\n                    ranking=tuple(new_ranking),\n                    weight=ballot.weight,\n                    voter_set=ballot.voter_set,\n                )\n            )\n        else:\n            update.append(ballot)\n\n    return update\n</code></pre>"},{"location":"api/#votekit.utils.fix_ties","title":"<code>fix_ties(ballot)</code>","text":"<p>Helper function for recursively_fix_ties. Resolves the first appearing tied rank in the input ballot.</p> <p>Parameters:</p> Name Type Description Default <code>ballot</code> <code>Ballot</code> <p>A Ballot.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of Ballots that are permutations of the tied ballot.</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def fix_ties(ballot: Ballot) -&gt; list[Ballot]:\n    \"\"\"\n    Helper function for recursively_fix_ties. Resolves the first appearing\n    tied rank in the input ballot.\n\n    Args:\n        ballot: A Ballot.\n\n    Returns:\n        (list): List of Ballots that are permutations of the tied ballot.\n    \"\"\"\n\n    ballots = []\n    for idx, rank in enumerate(ballot.ranking):\n        if len(rank) &gt; 1:\n            for order in permutations(rank):\n                resolved = []\n                for cand in order:\n                    resolved.append(frozenset(cand))\n                ballots.append(\n                    Ballot(\n                        id=ballot.id,\n                        ranking=ballot.ranking[:idx]\n                        + tuple(resolved)\n                        + ballot.ranking[idx + 1 :],\n                        weight=ballot.weight / math.factorial(len(rank)),\n                        voter_set=ballot.voter_set,\n                    )\n                )\n\n    return ballots\n</code></pre>"},{"location":"api/#votekit.utils.elect_cands_from_set_ranking","title":"<code>elect_cands_from_set_ranking(ranking, seats)</code>","text":"<p>Splits a ranking into elected and eliminated based on seats, and if a tie set overlaps the desired number of seats raises a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-set ranking of candidates.</p> required <code>seats</code> <code>int</code> <p>Number of seats to fill.</p> required <p>Returns:</p> Type Description <code>tuple[list[set[str]], list[set[str]]]</code> <p>A list-of-sets of elected candidates, a list-of-sets of eliminated candidates.</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def elect_cands_from_set_ranking(\n    ranking: list[set[str]], seats: int\n) -&gt; tuple[list[set[str]], list[set[str]]]:\n    \"\"\"\n    Splits a ranking into elected and eliminated based on seats,\n    and if a tie set overlaps the desired number of seats raises a ValueError.\n\n    Args:\n        ranking: A list-of-set ranking of candidates.\n        seats: Number of seats to fill.\n\n    Returns:\n        A list-of-sets of elected candidates, a list-of-sets of eliminated candidates.\n    \"\"\"\n    cands_elected = 0\n    elected = []\n    eliminated = []\n\n    for i, s in enumerate(ranking):\n        if cands_elected + len(s) &lt;= seats:\n            cands_elected += len(s)\n            elected.append(s)\n        else:\n            eliminated = ranking[i:]\n            break\n\n    if cands_elected != seats:\n        raise ValueError(\n            \"Cannot elect correct number of candidates without breaking ties.\"\n        )\n\n    return elected, eliminated\n</code></pre>"},{"location":"api/#votekit.utils.scores_into_set_list","title":"<code>scores_into_set_list(score_dict, candidate_subset=None)</code>","text":"<p>Sorts candidates based on a scoring dictionary (i.e Borda, First-Place).</p> <p>Parameters:</p> Name Type Description Default <code>score_dict</code> <code>dict</code> <p>Dictionary between candidates (key) and their score (value).</p> required <code>candidate_subset</code> <code>Union[list[str], set[str], None]</code> <p>Relevant candidates to sort.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[set[str]]</code> <p>Candidate rankings in a list-of-sets form.</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def scores_into_set_list(\n    score_dict: dict, candidate_subset: Union[list[str], set[str], None] = None\n) -&gt; list[set[str]]:\n    \"\"\"\n    Sorts candidates based on a scoring dictionary (i.e Borda, First-Place).\n\n    Args:\n        score_dict: Dictionary between candidates (key) and their score (value).\n        candidate_subset: Relevant candidates to sort.\n\n    Returns:\n        Candidate rankings in a list-of-sets form.\n    \"\"\"\n    if isinstance(candidate_subset, list):\n        candidate_subset = set(candidate_subset)\n\n    tier_dict: dict = {}\n    for k, v in score_dict.items():\n        if v in tier_dict.keys():\n            tier_dict[v].add(k)\n        else:\n            tier_dict[v] = {k}\n    tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n    if candidate_subset is not None:\n        tier_list = [\n            t &amp; candidate_subset for t in tier_list if len(t &amp; candidate_subset) &gt; 0\n        ]\n    return tier_list\n</code></pre>"},{"location":"api/#votekit.utils.tie_broken_ranking","title":"<code>tie_broken_ranking(ranking, profile, tiebreak='none')</code>","text":"<p>Breaks ties in a list-of-sets ranking according to a given scheme.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-set ranking of candidates.</p> required <code>profile</code> <code>PreferenceProfile</code> <p>PreferenceProfile.</p> required <code>tiebreak</code> <code>str</code> <p>Method of tiebreak, currently supports 'none', 'random', 'borda', 'firstplace'.</p> <code>'none'</code> <p>Returns:</p> Type Description <code>list[set[str]]</code> <p>A list-of-set ranking of candidates (tie broken down to one candidate sets unless tiebreak = 'none').</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def tie_broken_ranking(\n    ranking: list[set[str]], profile: PreferenceProfile, tiebreak: str = \"none\"\n) -&gt; list[set[str]]:\n    \"\"\"\n    Breaks ties in a list-of-sets ranking according to a given scheme.\n\n    Args:\n        ranking: A list-of-set ranking of candidates.\n        profile: PreferenceProfile.\n        tiebreak: Method of tiebreak, currently supports 'none', 'random', 'borda', 'firstplace'.\n\n    Returns:\n        A list-of-set ranking of candidates (tie broken down to one candidate sets unless\n            tiebreak = 'none').\n    \"\"\"\n\n    new_ranking = []\n    if tiebreak == \"none\":\n        new_ranking = ranking\n    elif tiebreak == \"random\":\n        for s in ranking:\n            shuffled_s = list(np.random.permutation(list(s)))\n            new_ranking += [{c} for c in shuffled_s]\n    elif tiebreak == \"firstplace\":\n        tiebreak_scores = first_place_votes(profile)\n        for s in ranking:\n            ordered_set = scores_into_set_list(tiebreak_scores, s)\n            new_ranking += ordered_set\n    elif tiebreak == \"borda\":\n        tiebreak_scores = borda_scores(profile)\n        for s in ranking:\n            ordered_set = scores_into_set_list(tiebreak_scores, s)\n            new_ranking += ordered_set\n    else:\n        raise ValueError(\"Invalid tiebreak code was provided\")\n\n    if tiebreak != \"none\" and any(len(s) &gt; 1 for s in new_ranking):\n        print(\"Initial tiebreak was unsuccessful, performing random tiebreak\")\n        new_ranking = tie_broken_ranking(\n            ranking=new_ranking, profile=profile, tiebreak=\"random\"\n        )\n\n    return new_ranking\n</code></pre>"},{"location":"api/#votekit.utils.candidate_position_dict","title":"<code>candidate_position_dict(ranking)</code>","text":"<p>Creates a dictionary with the integer ranking of candidates given a set ranking i.e. A &gt; B, C &gt; D returns {A: 1, B: 2, C: 2, D: 4}.</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-sets ranking of candidates.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and integer rankings (values).</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def candidate_position_dict(ranking: list[set[str]]) -&gt; dict:\n    \"\"\"\n    Creates a dictionary with the integer ranking of candidates given a set ranking\n    i.e. A &gt; B, C &gt; D returns {A: 1, B: 2, C: 2, D: 4}.\n\n    Args:\n        ranking: A list-of-sets ranking of candidates.\n\n    Returns:\n        Dictionary of candidates (keys) and integer rankings (values).\n    \"\"\"\n    candidate_positions = {}\n    position = 0\n\n    for tie_set in ranking:\n        for candidate in tie_set:\n            candidate_positions[candidate] = position\n        position += len(tie_set)\n\n    return candidate_positions\n</code></pre>"},{"location":"ballot_graph/","title":"<code>BallotGraph</code>","text":"<p>The ballot graph has vertices=ballots, and edges connecting ballots if they are equivalent by a swap of two adjacently ranked candidates, or by the truncation or addition of a candidate in last place.</p> <p>The <code>BallotGraph</code> object can be created from a <code>PreferenceProfile</code> object, a number of candidates, or a list of candidates. It has an <code>allow_partial</code> parameter that says whether or not the graph will be constructed using partial ballots, or only full linear orderings. If being created from a <code>PreferenceProfile</code>, this parameter defaults to <code>True</code> to allow for any kind of ballot from a voter.</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.graphs import BallotGraph\n</code></pre> <pre><code>candidates = [\"A\", \"B\", \"C\"]\n\nballot_graph = BallotGraph(candidates, allow_partial=True)\nballot_graph.draw(labels= False)\n</code></pre> <p></p> <p>Why are there no ballots of length 2? Since the number of candidates was 3, any ballot of length 2 is equivalent to a ballot of length 3.</p> <p>We can change the <code>allow_partial</code> parameter to <code>False</code> to only see full linear rankings, and we can also ask the <code>draw</code> method to display the labels of the candidates and how many votes a particular ballot received.</p> <pre><code>ballot_graph = BallotGraph(candidates, allow_partial = False)\nballot_graph.draw(labels = True)\n</code></pre> <p></p> <p>Check for understanding: why are all of the votes 0?</p> <p>The BallotGraph has an underlying <code>graph</code> attribute which stores a NetworkX graph.</p> <pre><code>for node, data in ballot_graph.graph.nodes(data = True):\n    print(node,data)\n</code></pre> <pre><code>(1, 2, 3) {'weight': 0, 'cast': False}\n(1, 3, 2) {'weight': 0, 'cast': False}\n(2, 3, 1) {'weight': 0, 'cast': False}\n(2, 1, 3) {'weight': 0, 'cast': False}\n(3, 1, 2) {'weight': 0, 'cast': False}\n(3, 2, 1) {'weight': 0, 'cast': False}\n</code></pre> <p>This is a bit of a boring example; since the <code>BallotGraph</code> was generated from a list of candidates, none of the ballots have any weight and none of the ballots were \"cast,\" (i.e., 0 people voted with that ballot).</p> <p>If we generate the <code>BallotGraph</code> from a <code>PreferenceProfile</code>, we should get more interesting results here.</p> <pre><code>ic = bg.ImpartialCulture(candidates=candidates)\nnum_ballots = 60\nprofile = ic.generate_profile(number_of_ballots = num_ballots)\nprint(profile)\n\nballot_graph = BallotGraph(profile)\nballot_graph.draw(labels = True)\n</code></pre> <pre><code>  Ballots Weight\n(A, C, B)     12\n(B, A, C)     11\n(C, A, B)     11\n(C, B, A)     10\n(A, B, C)      9\n(B, C, A)      7\n</code></pre> <p></p> <p>Let's dig into the node atttributes of the graph to see how the voting information was captured.</p> <pre><code>for node, data in ballot_graph.graph.nodes(data = True):\n    print(node,data)\n</code></pre> <pre><code>(1,) {'weight': 0, 'cast': False}\n(1, 2, 3) {'weight': Fraction(7, 1), 'cast': True}\n(1, 3, 2) {'weight': Fraction(11, 1), 'cast': True}\n(2,) {'weight': 0, 'cast': False}\n(2, 3, 1) {'weight': Fraction(11, 1), 'cast': True}\n(2, 1, 3) {'weight': Fraction(10, 1), 'cast': True}\n(3,) {'weight': 0, 'cast': False}\n(3, 1, 2) {'weight': Fraction(9, 1), 'cast': True}\n(3, 2, 1) {'weight': Fraction(12, 1), 'cast': True}\n</code></pre> <p>Check for understanding: only ballots that were in the <code>PreferenceProfile</code> should have 'cast'= True, and their 'weight' attribute should correspond to the number of ballots cast.</p> <p>If we wanted to visualize only the nodes corresponding to cast ballots, we use the <code>show_cast</code> parameter in the <code>draw</code> method.</p> <pre><code>ballot_graph.draw(labels = True, show_cast=True)\n</code></pre> <p></p> <p>We can also write custom functions for displaying nodes. We require these functions to take as input the underlying graph and a node, and return <code>True</code> if the node is to be displayed. Suppose we only wanted to see </p> <pre><code>def show_big_weight(graph, node):\n    # display nodes with more than 10 votes\n    if graph.nodes[node][\"weight\"] &gt;= 10:\n        return True\n\n    return False\n</code></pre> <pre><code>ballot_graph.draw(labels=True, to_display=show_big_weight)\n</code></pre> <p></p> <p>What if we wanted to explore a particular neighborhood of a ballot? Let's look at the radius 1 neighborhood around the ballot (3,2,1).</p> <pre><code># first draw the entire graph so we know what to look for\nballot_graph = BallotGraph(3)\nballot_graph.draw()\n</code></pre> <p></p> <pre><code># the neighborhoods parameter takes a list of tuples (node, radius)\n# and displays the corresponding neighborhoods\nballot_graph.draw(neighborhoods=[((3,2,1), 1)])\n</code></pre> <p></p> <p>Check for understanding: is this picture what you expected?</p> <p>We can also draw multiple neighborhoods.</p> <pre><code>ballot_graph.draw(neighborhoods=[((3,2,1), 1),\n                                 ((2,), 1)])\n</code></pre> <p></p>"},{"location":"bg_from_params/","title":"Ballot Generators from Parameters: the Dirichlet Distribution","text":"<p>In the VoteKit world of ballot generating, there are usually 4 parameters that need to be chosen. - Bloc proportions - Cohesion parameters - Preference intervals - Candidates per bloc</p> <p>Instead of choosing a preference interval, VoteKit also makes it possible to generate a preference interval using the Dirichlet distribution. The Dirichlet distribution samples a point from a simplex, in this case the candidate simplex. For three candidates, the candidate simplex is a triangle, where each corner represents a candidate. A point in the triangle is a vector of length 3 whose entries are non-negative and sum to 1 (exactly what a preference interval is!). A point that is close to a vertex is a preference interval with high support for one candidate. A point near the center of the triangle is a preference interval with near equal support for all three.</p> <p>The Dirichlet distribution is parameterized by a parameter \\(\\alpha \\in (0,\\infty)\\).  As \\(\\alpha\\to\\infty\\), the distribution's mass moves towards the center of the simplex, so we get preference intervals that have more equal support for all candidates. As \\(\\alpha\\to 0\\), the distribution's mass moves towards the corners, so we get preference intervals that have strong support for one candidate. When \\(\\alpha=1\\), all bets are off and could produce any preference interval.</p> <p>By using the Dirichlet distribution instead of a fixed preference interval, you can study how the behavior of voters impacts elections. - What happens in STV elections when voters have a strong preference for one candidate? A diffuse preference for all?</p> <p>Let's see an example of how to construct ballots using the Dirichlet parameters.</p> <pre><code>import votekit.ballot_generator as bg\n</code></pre> <pre><code># the slate-Plackett-Luce model\n\nbloc_proportions = {\"A\": .8, \"B\": .2}\ncohesion_parameters = {\"A\":{\"A\": .9, \"B\":.1},\n                       \"B\":{ \"B\": .9, \"A\":.1}}\ndirichlet_alphas = {\"A\": {\"A\":1, \"B\":1},\n                    \"B\": {\"A\":1, \"B\":1}}\n\nslate_to_candidates = {\"A\": [\"A1\", \"A2\"],\n                        \"B\": [\"B1\", \"B2\"]}\n</code></pre> <p>We need four different Dirichlet parameter's; \\(\\alpha_{AA}\\) generates the \\(A\\) voters preference interval for \\(A\\) candidates and \\(\\alpha_{AB}\\) generates the \\(A\\) voters preference interval for \\(B\\) candidates. Likewise for the \\(B\\) voters.</p> <p>Also notice that we need a bit more information in this case than if we gave the PL model a preference interval; we must specify the cohesion parameters and which candidates are in which bloc.</p> <pre><code>pl = bg.slate_PlackettLuce.from_params(slate_to_candidates=slate_to_candidates,\n                                 bloc_voter_prop=bloc_proportions,\n                                 cohesion_parameters=cohesion_parameters,\n                                 alphas=dirichlet_alphas)\n\nprofile = pl.generate_profile(number_of_ballots=1000)\nprint(profile)\n</code></pre> <pre><code>PreferenceProfile too long, only showing 15 out of 34 rows.\n         Ballots Weight\n(A1, A2, B2, B1)    298\n(A2, A1, B2, B1)    222\n(B1, B2, A2, A1)    136\n(A1, A2, B1, B2)     72\n(A2, A1, B1, B2)     42\n(B2, A1, A2, B1)     30\n(A1, B2, A2, B1)     30\n(B2, A2, A1, B1)     27\n(A2, B2, A1, B1)     18\n(B1, A2, B2, A1)     18\n(B1, B2, A1, A2)     16\n(B1, A1, A2, B2)     14\n(A2, B1, B2, A1)     13\n(B2, B1, A2, A1)     11\n(B2, A2, B1, A1)      8\n</code></pre> <p>We can see what preference intervals were generated. Check for understanding; are these intervals what you would expect given the choices of parameter above?</p> <pre><code>pl.pref_intervals_by_bloc\n</code></pre> <pre><code>{'A': {'A': {'A1': 0.586, 'A2': 0.414}, 'B': {'B1': 0.1574, 'B2': 0.8426}},\n 'B': {'A': {'A1': 0.0915, 'A2': 0.9085}, 'B': {'B1': 0.9184, 'B2': 0.0816}}}\n</code></pre> <p>Let's fiddle with the Dirichlet parameter's to see how they impact things. By lowering \\(\\alpha_{AB}\\), we expect to see that \\(A\\) voters have a strong preference for a particular \\(B\\) candidate. By raising \\(\\alpha_{BB}\\), we expect \\(B\\) voters to have relatively uniform preferences for \\(B\\) candidates.</p> <pre><code># the slate-Plackett-Luce model\n\nbloc_proportions = {\"A\": .8, \"B\": .2}\ncohesion_parameters = {\"A\":{\"A\": .9, \"B\":.1},\n                       \"B\":{ \"B\": .9, \"A\":.1}}\ndirichlet_alphas = {\"A\": {\"A\":1, \"B\":.1},\n                    \"B\": {\"A\":1, \"B\":1000}}\n\nslate_to_candidates = {\"A\": [\"A1\", \"A2\"],\n                        \"B\": [\"B1\", \"B2\"]}\n\npl = bg.slate_PlackettLuce.from_params(slate_to_candidates=slate_to_candidates,\n                                 bloc_voter_prop=bloc_proportions,\n                                 cohesion_parameters=cohesion_parameters,\n                                 alphas=dirichlet_alphas)\n\nprint(\"A preference interval\", pl.pref_intervals_by_bloc[\"A\"])\nprint(\"B preference interval\", pl.pref_intervals_by_bloc[\"B\"], \"\\n\")\n\nprofile_dict, pp = pl.generate_profile(number_of_ballots=1000, by_bloc=True)\nprint(\"A ballots\\n\", profile_dict[\"A\"])\nprint()\nprint(\"B ballots\\n\", profile_dict[\"B\"])\n</code></pre> <pre><code>A preference interval {'A': {'A1': 0.3228, 'A2': 0.6772}, 'B': {'B1': 0.0702, 'B2': 0.9298}}\nB preference interval {'A': {'A1': 0.5083, 'A2': 0.4917}, 'B': {'B1': 0.4888, 'B2': 0.5112}}\n\nA ballots\n PreferenceProfile too long, only showing 15 out of 19 rows.\n         Ballots Weight\n(A2, A1, B2, B1)    419\n(A1, A2, B2, B1)    206\n(A2, B2, A1, B1)     35\n(B2, A2, A1, B1)     34\n(A1, A2, B1, B2)     20\n(A1, B2, A2, B1)     19\n(A2, A1, B1, B2)     16\n(B2, A1, A2, B1)     15\n(B2, B1, A2, A1)      6\n(A2, B1, A1, B2)      6\n(B2, A2, B1, A1)      5\n(B2, A1, B1, A2)      5\n(B2, B1, A1, A2)      3\n(B1, A2, A1, B2)      3\n(A1, B1, A2, B2)      2\n\nB ballots\n PreferenceProfile too long, only showing 15 out of 16 rows.\n         Ballots Weight\n(B2, B1, A1, A2)     46\n(B2, B1, A2, A1)     42\n(B1, B2, A1, A2)     40\n(B1, B2, A2, A1)     37\n(B2, A1, B1, A2)      8\n(A2, B1, B2, A1)      6\n(A1, B1, B2, A2)      4\n(A1, B2, B1, A2)      4\n(A2, B2, B1, A1)      3\n(B1, A2, B2, A1)      3\n(B2, A2, B1, A1)      2\n(A2, B2, A1, B1)      1\n(A1, A2, B1, B2)      1\n(B1, A2, A1, B2)      1\n(A2, A1, B2, B1)      1\n</code></pre> <p>Check for understanding; are the intervals and ballots what you'd expect?</p> <p>Any of our other ballot generating models that rely on preference intervals can be generated from the Dirichlet distribution in a similar way.</p>"},{"location":"bg_models_1/","title":"Ballot Generators: Generating <code>PreferenceProfiles</code>","text":"<p>We have already seen the use of a  <code>PreferenceProfile</code> generator (the Impartial Culture Model) in the Plotting and Ballot Graph tutorials. Now, let's dive into the rest that are included in <code>votekit</code>. This tutorial will cover - Impartial Culture - Impartial Anonymous Culture - name-Plackett Luce - name-Bradley Terry - name-Cumulative</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.pref_interval import PreferenceInterval\n</code></pre> <p>The two simplest to use are the Impartial Culture and Impartial Anonymous Culture. For \\(m\\) candidates and \\(n\\) voters, the Impartial Culture model generates <code>PreferenceProfiles</code> uniformly at random out of the \\((m!)^n\\) possible profiles. Remember, a <code>PreferenceProfile</code> is a tuple of length \\(n\\) that stores a linear ranking \\(m\\) in each slot.</p> <p>The Impartial Anonymous Culture model works a little bit differently. When it generates ballots, it chooses a candidate support vector uniformly at random from among all possible support vectors, and then generates ballots according to that vector.</p> <pre><code>candidates = [\"A\", \"B\", \"C\"]\nnumber_of_ballots = 50\n#Impartial Culture\nic = bg.ImpartialCulture(candidates = candidates)\nic_profile = ic.generate_profile(number_of_ballots)\n\n#Impartial Anonymous Culture\niac = bg.ImpartialAnonymousCulture(candidates = candidates)\niac_profile = iac.generate_profile(number_of_ballots)\n</code></pre> <p>The 1-D Spatial model assigns each candidate a random point on the real line according to the standard normal distribution. It then does the same for each voter, and then a voter ranks candidates by their distance from the voter.</p> <pre><code>one_d = bg.OneDimSpatial(candidates = candidates)\none_d_profile = one_d.generate_profile(number_of_ballots)\n</code></pre>"},{"location":"bg_models_1/#ballots-generated-using-intervals","title":"Ballots Generated Using Intervals","text":"<p>The following generative models all depend on preference intervals.</p> <p>The name-Plackett-Luce, name-Bradley-Terry, and name-Cumulative models all use the interval \\([0,1]\\). To use these models, we need a bit more information than just the candidates. Suppose for now that there is one type of voter (or bloc \\(Q\\)) in the state (these models can be generalized to more than one bloc, but we will start simple for now). We record the proportion of voters in this bloc in a dictionary.</p>"},{"location":"bg_models_1/#name-pl-and-name-bt","title":"Name-PL and Name-BT","text":"<p>In the upcoming election, there are three candidates, \\(A\\), \\(B\\), and \\(C\\). In general, the bloc \\(Q\\) prefers \\(A\\) 1/2  of the time, \\(B\\) 1/3 of the time, and \\(C\\) 1/6 of the time. We can visualize this as the line segment \\([0,1]\\), with the segment \\([0,1/2]\\) labeled \\(A\\), \\([1/2, 5/6]\\) labeled \\(B\\), and \\([5/6,1]\\) labeled \\(C\\). Note the slight abuse of notation in using the same name for the candidates and their intervals. We store this information in a <code>PreferenceInterval</code> object.</p> <pre><code>candidates = [\"A\", \"B\", \"C\"]\nnumber_of_ballots = 50\n\nbloc_voter_prop = {\"Q\":1}\n\npref_intervals_by_bloc = {\"Q\" : {\"Q\": \n                                 PreferenceInterval({\"A\": 1/2,  \"B\": 1/3, \"C\": 1/6})\n                                 }\n                                 }\n</code></pre> <p>For each voter, the name-Plackett-Luce (PL) model samples from the list of candidates without replacement according to the distribution defined by the preference intervals. The first candidate it samples is in first place, then second, etc. Visualizing this as the line segment, the PL model uniformly at random selects a point in \\([0,1]\\). Whichever candidate's interval that point lies in is listed first in the ballot. It then removes that candidate's preference interval from \\([0,1]\\), rescales so the segment has length 1 again, and then samples a second candidate. Repeat until all candidates have been sampled. We will discuss the <code>cohesion_parameters</code> argument later.</p> <pre><code># Plackett-Luce\npl = bg.name_PlackettLuce(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     candidates=candidates,\n                     cohesion_parameters={\"Q\":{\"Q\":1}})\n\npl_profile = pl.generate_profile(number_of_ballots)\nprint(pl_profile)\n</code></pre> <pre><code>  Ballots Weight\n(A, B, C)     21\n(B, A, C)     12\n(C, A, B)      7\n(A, C, B)      4\n(C, B, A)      3\n(B, C, A)      3\n</code></pre> <p>The name-Bradley-Terry (BT) model also fundamentally relies on these preference intervals. The probability that BT samples the ballot \\((A&gt;B&gt;C)\\) is proportional to the the product of the pairwise probabilities \\((A&gt;B), (A&gt;C),\\) and \\((B&gt;C)\\). Using our preference intervals, the probability that \\(A&gt;B\\) is \\(\\frac{A}{A+B}\\); out of a line segment of length \\(A+B\\), this is the probability that a uniform random point lies in the \\(A\\) portion. The other probabilities are computed similarly.</p> <pre><code># Bradley-Terry\nbt = bg.name_BradleyTerry(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     candidates=candidates,\n                     cohesion_parameters = {\"Q\":{\"Q\":1}})\n\nbt_profile = bt.generate_profile(number_of_ballots)\n\nprint(bt_profile)\n</code></pre> <pre><code>  Ballots Weight\n(A, B, C)     22\n(B, A, C)     11\n(A, C, B)     10\n(B, C, A)      5\n(C, A, B)      1\n(C, B, A)      1\n</code></pre> <p>We can do a more complicated example of PL and BT. Consider an election where there are 2 blocs of voters, \\(Q\\) and \\(R\\). There are two candidates from the \\(Q\\) bloc, and two from the \\(R\\) bloc. The \\(R\\) block is more insular, and expresses no interest in any of the \\(Q\\) candidates, while the \\(Q\\) bloc does have some preference for \\(R\\)'s candidates. We express this using <code>cohesion_parameters</code>, which stores the preference of each slate for the other slate's candidates.</p> <pre><code>candidates = [\"Q1\", \"Q2\", \"R1\", \"R2\"]\nnumber_of_ballots = 50\n\nbloc_voter_prop = {\"Q\": 0.7, \"R\": 0.3}\n\npref_intervals_by_bloc = {\n    \"Q\": {\"Q\":PreferenceInterval({\"Q1\": 0.4, \"Q2\": 0.3}),\n          \"R\":PreferenceInterval({\"R1\": 0.2, \"R2\": 0.1})},\n    \"R\": {\"Q\":PreferenceInterval({\"Q1\": 0.3, \"Q2\": 0.7}),\n          \"R\":PreferenceInterval({\"R1\": 0.4, \"R2\": 0.6})}\n}\n\ncohesion_parameters = {\"Q\": {\"Q\": .8, \"R\":.2},\n                       \"R\": {\"R\":1, \"Q\":0}}\n</code></pre> <pre><code>pl = bg.name_PlackettLuce(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     candidates=candidates,\n                     cohesion_parameters=cohesion_parameters)\n\npl_profile = pl.generate_profile(number_of_ballots)\n\nprint(\"Number of ballots:\", pl_profile.num_ballots())\nprint(pl_profile)\n</code></pre> <pre><code>Number of ballots: 50\nPreferenceProfile too long, only showing 15 out of 15 rows.\n                                Ballots Weight\n                       (Q1, Q2, R1, R2)     11\n(R2, R1, frozenset({'Q1', 'Q2'}) (Tie))     11\n                       (R1, Q2, Q1, R2)      6\n                       (Q2, Q1, R1, R2)      5\n(R1, R2, frozenset({'Q1', 'Q2'}) (Tie))      4\n                       (Q1, R1, Q2, R2)      2\n                       (Q2, R1, Q1, R2)      2\n                       (Q1, Q2, R2, R1)      2\n                       (Q1, R1, R2, Q2)      1\n                       (Q2, R2, Q1, R1)      1\n                       (Q2, R2, R1, Q1)      1\n                       (R1, R2, Q2, Q1)      1\n                       (Q2, R1, R2, Q1)      1\n                       (Q1, R2, Q2, R1)      1\n                       (R2, Q2, Q1, R1)      1\n</code></pre> <p>Notice that for the first time we have ties on the ballots! The notation <code>{'Q1', 'Q2'} (Tie)</code> means that these two candidates are tied for third place.</p> <pre><code># Bradley-Terry\nbt = bg.name_BradleyTerry(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     candidates=candidates,\n                     cohesion_parameters=cohesion_parameters)\n\nbt_profile = bt.generate_profile(number_of_ballots)\nprint(\"Number of ballots:\", bt_profile.num_ballots())\nprint(bt_profile)\n</code></pre> <pre><code>Number of ballots: 50\n                                Ballots Weight\n                       (Q1, Q2, R1, R2)      9\n(R1, R2, frozenset({'Q1', 'Q2'}) (Tie))      9\n                       (Q1, R1, Q2, R2)      7\n                       (Q2, Q1, R1, R2)      6\n(R2, R1, frozenset({'Q1', 'Q2'}) (Tie))      6\n                       (Q2, Q1, R2, R1)      3\n                       (Q1, Q2, R2, R1)      3\n                       (R1, Q1, Q2, R2)      3\n                       (Q2, R1, Q1, R2)      3\n                       (R1, Q2, Q1, R2)      1\n</code></pre>"},{"location":"bg_models_1/#name-cumulative","title":"Name-Cumulative","text":"<p>Cumulative voting is a method in which voters are allowed to put candidates on the ballot with multiplicity.</p> <pre><code>candidates = [\"Q1\", \"Q2\", \"R1\", \"R2\"]\nnumber_of_ballots = 50\n\nbloc_voter_prop = {\"Q\": 0.7, \"R\": 0.3}\n\npref_intervals_by_bloc = {\n    \"Q\": {\"Q\":PreferenceInterval({\"Q1\": 0.4, \"Q2\": 0.3}),\n          \"R\":PreferenceInterval({\"R1\": 0.2, \"R2\": 0.1})},\n    \"R\": {\"Q\":PreferenceInterval({\"Q1\": 0.3, \"Q2\": 0.7}),\n          \"R\":PreferenceInterval({\"R1\": 0.4, \"R2\": 0.6})}\n}\n\ncohesion_parameters = {\"Q\": {\"Q\": .8, \"R\":.2},\n                       \"R\": {\"R\":1, \"Q\":0}}\n\nnum_votes_per_ballot = 3\n</code></pre> <p>We will also take this chance to introduce the <code>by_bloc</code> parameter to the <code>generate_profile</code> method, which when set to <code>True</code> returns a tuple. The first entry is a dictionary, which records the ballots cast by each bloc. The second entry is the full profile, i.e. what you would get if you just ran <code>generate_profile</code> with <code>by_bloc=False</code>.</p> <pre><code>c  = bg.name_Cumulative(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     candidates=candidates,\n                     cohesion_parameters=cohesion_parameters,\n                     num_votes=num_votes_per_ballot)\n\nc_profile_dict, agg_profile = c.generate_profile(number_of_ballots=100, by_bloc=True)\n</code></pre> <pre><code>c_profile_dict[\"Q\"]\n</code></pre> <pre><code>PreferenceProfile too long, only showing 15 out of 31 rows.\n\n\n\n\n\n     Ballots Weight\n(Q1, Q1, Q1)      6\n(Q1, Q1, R1)      6\n(Q1, Q2, Q1)      6\n(Q2, Q2, Q1)      4\n(Q1, R1, Q1)      4\n(Q1, Q1, Q2)      4\n(Q1, Q2, R1)      3\n(Q2, Q2, Q2)      3\n(Q2, Q1, Q1)      3\n(R2, Q2, Q2)      3\n(R1, Q1, Q2)      2\n(Q1, Q2, Q2)      2\n(Q2, Q2, R1)      2\n(Q2, Q1, R1)      2\n(R2, Q2, Q1)      2\n</code></pre> <pre><code>c_profile_dict[\"R\"]\n</code></pre> <pre><code>     Ballots Weight\n(R2, R2, R2)     12\n(R1, R1, R2)      4\n(R1, R2, R1)      3\n(R1, R1, R1)      3\n(R2, R1, R2)      3\n(R2, R1, R1)      2\n(R2, R2, R1)      2\n(R1, R2, R2)      1\n</code></pre> <pre><code>agg_profile\n</code></pre> <pre><code>PreferenceProfile too long, only showing 15 out of 39 rows.\n\n\n\n\n\n     Ballots Weight\n(R2, R2, R2)     12\n(Q1, Q1, R1)      6\n(Q1, Q2, Q1)      6\n(Q1, Q1, Q1)      6\n(Q1, R1, Q1)      4\n(Q2, Q2, Q1)      4\n(Q1, Q1, Q2)      4\n(R1, R1, R2)      4\n(R2, Q2, Q2)      3\n(Q2, Q2, Q2)      3\n(R1, R2, R1)      3\n(Q2, Q1, Q1)      3\n(R1, R1, R1)      3\n(Q1, Q2, R1)      3\n(R2, R1, R2)      3\n</code></pre> <p>Observe the multiplicity of candidates, as well as the fact that no voter in the <code>R</code> bloc cast a vote for <code>Q</code> candidates. To make the <code>Ballot</code> object as flexible as possible over different methods of election, we have implemented cumulative voting ballots as follows. The ranking on the ballot holds no meaning; all that matters is the multiplicity. That is, the ballot (R1, R1, R2) is the same as (R2, R1, R1). The <code>PreferenceProfile</code> object does not know that and thus displays them as different ballots, but our cumulative election class will handle tallying results for you.</p> <p>We will discuss the slate models, as well as AC and CS in a later tutorial.</p> <pre><code>\n</code></pre>"},{"location":"bg_models_2/","title":"More Ballot Generators: Slate, AC, and CS","text":"<p>We now turn to the remaining models of ballot generator. - slate-Plackett Luce - slate-Bradley Terry - Alternating Crossover - Cambridge Sampler</p>"},{"location":"bg_models_2/#slate-models","title":"Slate Models","text":"<p>The slate-Plackett Luce and slate-Bradley Terry models function very similarly to their name counterparts. In the name models, ballots were constructed directly from preference intervals and candidate names. In the slate models, we will first construct a ballot type where each entry of the ballot is the name of a slate, then fill in the candidate names separately. See our social choice documentation for more information.</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.pref_interval import PreferenceInterval\n</code></pre> <p>In order to properly use the slate models, we must delineate which candidates belong to which slate. We do so with the <code>slate_to_candidates</code> parameter.</p> <pre><code>slate_to_candidates = {\"Q\": [\"Q1\", \"Q2\"],\n                       \"R\":[\"R1\", \"R2\"]}\nnumber_of_ballots = 50\n\nbloc_voter_prop = {\"Q\": 0.7, \"R\": 0.3}\n\npref_intervals_by_bloc = {\n    \"Q\": {\"Q\":PreferenceInterval({\"Q1\": 0.4, \"Q2\": 0.3}),\n          \"R\":PreferenceInterval({\"R1\": 0.2, \"R2\": 0.1})},\n    \"R\": {\"Q\":PreferenceInterval({\"Q1\": 0.3, \"Q2\": 0.7}),\n          \"R\":PreferenceInterval({\"R1\": 0.4, \"R2\": 0.6})}\n}\n\ncohesion_parameters = {\"Q\": {\"Q\": .8, \"R\":.2},\n                       \"R\": {\"R\":.9, \"Q\":.1}}\n\npl = bg.slate_PlackettLuce(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     slate_to_candidates=slate_to_candidates,\n                     cohesion_parameters=cohesion_parameters)\n\nbt = bg.slate_BradleyTerry(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, \n                     slate_to_candidates=slate_to_candidates,\n                     cohesion_parameters=cohesion_parameters)\n</code></pre>"},{"location":"bg_models_2/#alternating-crossover","title":"Alternating Crossover","text":"<p>The Alternating Crossover model was first introduced in Benade et al. \"Ranked Choice Voting and Proportional Representation\" (February 2, 2021). Available at SSRN: https://ssrn.com/abstract=3778021. This model assumes there are two blocs over voters. Within a bloc, voters either vote with the bloc, or \"crossover\" to the other bloc. The proportion of such voters is controlled by the cohesion parameter.</p> <p>Bloc voters rank all of the candidates from their bloc above all of the candidates from the other bloc. They choose their ranking of candidates via the PL model. Crossover voters first rank a candidate from the other bloc, then their bloc, etc, alternating until they run out of candidates from one bloc (at which point they stop.) Note that this means the AC model can generate incomplete ballots. Again, they choose their ranking via the PL model. </p> <p>A note on the preference intervals for this model. In this context, there are really two preference intervals for each bloc: the preference interval for their own candidates, and the preference interval for the opposing candidates. To input this as one preference interval, simply divide every value by 2.</p> <pre><code>candidates = [\"Q1\", \"Q2\", \"R1\", \"R2\"]\n\npref_intervals_by_bloc = {\n    \"Q\": {\"Q\":PreferenceInterval({\"Q1\": 0.4, \"Q2\": 0.3}),\n          \"R\":PreferenceInterval({\"R1\": 0.2, \"R2\": 0.1})},\n    \"R\": {\"Q\":PreferenceInterval({\"Q1\": 0.3, \"Q2\": 0.7}),\n          \"R\":PreferenceInterval({\"R1\": 0.4, \"R2\": 0.6})}\n}\n\nbloc_voter_prop = {\"Q\": .7, \"R\": .3}\nslate_to_candidates = {\"Q\": [\"Q1\", \"Q2\"],\n                       \"R\": [\"R1\", \"R2\"]}\n\ncohesion_parameters = {\"Q\": {\"Q\": .8, \"R\":.2},\n                       \"R\": {\"R\":.9, \"Q\":.1}}\n\nac = bg.AlternatingCrossover(candidates = candidates,\n                             pref_intervals_by_bloc =pref_intervals_by_bloc,\n                             bloc_voter_prop = bloc_voter_prop,\n                             slate_to_candidates = slate_to_candidates,\n                             cohesion_parameters = cohesion_parameters)\n</code></pre> <pre><code>ac.generate_profile(100)\n</code></pre> <pre><code>PreferenceProfile too long, only showing 15 out of 15 rows.\n\n\n\n\n\n         Ballots Weight\n(Q1, Q2, R2, R1)     20\n(Q2, Q1, R1, R2)     15\n(Q1, Q2, R1, R2)     13\n(R1, R2, Q1, Q2)      9\n(Q2, Q1, R2, R1)      8\n(R2, R1, Q2, Q1)      7\n(R1, R2, Q2, Q1)      6\n(R2, Q1, R1, Q2)      5\n(R2, R1, Q1, Q2)      5\n(R1, Q2, R2, Q1)      4\n(R2, Q2, R1, Q1)      3\n(R1, Q1, R2, Q2)      2\n(Q2, R2, Q1, R1)      1\n(Q1, R2, Q2, R1)      1\n(Q1, R1, Q2, R2)      1\n</code></pre>"},{"location":"bg_models_2/#cambridge-sampler","title":"Cambridge Sampler","text":"<p>The Cambridge Sampler uses historical election data from Cambridge, MA to generate new ballots. You can use your own historical data with some of the provided optional parameters. The model assumes there is a majority and a minority bloc. Again there is a cohesion parameter measuring how often voters defect from the bloc. If voters vote with the bloc, they rank a bloc candidate first, and then the ballot is sampled from historical data with matching first entry. If they vote with the opposing bloc, they rank an opposing candidate first and then sample.</p> <p>The historical ballots only give the order in which majority/minority bloc candidates are listed ( for example, WWC says there were two majority candidates and then a minority on the ballot). Once the model decides which ballot type a voter has, it fills in the ballot with actual candidates using the preference interval ala PL.</p> <p>Since it samples from historical data, it's possible to generate incomplete ballots.</p> <pre><code>candidates = [\"Q1\", \"Q2\", \"R1\", \"R2\"]\n\npref_intervals_by_bloc = {\n    \"Q\": {\"Q\":PreferenceInterval({\"Q1\": 0.4, \"Q2\": 0.3}),\n          \"R\":PreferenceInterval({\"R1\": 0.2, \"R2\": 0.1})},\n    \"R\": {\"Q\":PreferenceInterval({\"Q1\": 0.3, \"Q2\": 0.7}),\n          \"R\":PreferenceInterval({\"R1\": 0.4, \"R2\": 0.6})}\n}\n\nbloc_voter_prop = {\"Q\": .7, \"R\": .3}\nslate_to_candidates = {\"Q\": [\"Q1\", \"Q2\"],\n                       \"R\": [\"R1\", \"R2\"]}\n\ncohesion_parameters = {\"Q\": {\"Q\": .8, \"R\":.2},\n                       \"R\": {\"R\":.9, \"Q\":.1}}\n\ncs = bg.CambridgeSampler(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                         bloc_voter_prop=bloc_voter_prop, candidates=candidates,\n                         slate_to_candidates=slate_to_candidates, cohesion_parameters=cohesion_parameters)\n</code></pre> <pre><code>cs.generate_profile(number_of_ballots=100)\n</code></pre> <pre><code>PreferenceProfile too long, only showing 15 out of 51 rows.\n\n\n\n\n\n         Ballots Weight\n    (Q2, Q1, R1)      6\n        (Q2, Q1)      5\n(R2, R1, Q2, Q1)      4\n(Q2, Q1, R1, R2)      4\n(R2, Q2, Q1, R1)      4\n           (Q1,)      4\n        (Q1, Q2)      4\n(Q1, R1, Q2, R2)      4\n(Q1, Q2, R1, R2)      4\n(Q2, R1, Q1, R2)      3\n    (R2, Q2, Q1)      3\n(Q2, R1, R2, Q1)      3\n(R1, R2, Q1, Q2)      3\n    (Q2, Q1, R2)      3\n        (R1, R2)      2\n</code></pre> <pre><code>\n</code></pre>"},{"location":"getting_started/","title":"Getting started with <code>votekit</code>","text":"<p>This guide will help you get started using <code>votekit</code>, by using real election data from the 2013 Minneapolis mayoral election. This election had 35 candidates running for one seat, and used a single-winner IRV method to elect the winner. Voters were allowed to rank their top three candidates. </p> <pre><code># these are the votekit functions we'll need access to\nfrom votekit.cvr_loaders import load_csv\nfrom votekit.elections import STV, fractional_transfer\nfrom votekit.cleaning import remove_noncands\n</code></pre> <p>You can find the necessary csv file <code>mn_2013_cast_vote_record.csv</code> in the <code>votekit/data</code> folder of the GitHub repo. Alternatively, you can download the offical cast vote record (CVR) here. Download a verison of the file, and then edit the path below to where you placed it. The csv file has 3 columns we care about. The first, entitled '1ST CHOICE MAYOR MINNEAPOLIS' in the official CVR, tells us a voters top choice, then the second tells us their second choice, and the third their third choice.</p> <p>The first thing we will do is create a <code>PreferenceProfile</code> object from our csv. A preference profile is a term from the social choice literature that represents the rankings of some set of candidates from some voters. Put another way, a preference profile stores the votes from an election, and is a collection of <code>Ballot</code> objects and candidates. </p> <p>We give the <code>load_csv</code> function the path to the csv file. By default, each column of the csv should correspond to a ranking of a candidate, given in decreasing order (the first column is the voters top choice, the last column their bottom choice.) There are some other optional parameters which you can read about in the documentation, like how to read a csv file that has more columns than just rankings.</p> <pre><code># you'll need to edit this path!\nminneapolis_profile = load_csv(\"../src/votekit/data/mn_2013_cast_vote_record.csv\")\n</code></pre> <p>The <code>PreferenceProfile</code> object has lots of helpful methods that allow us to study our votes. Let's use some of them to explore the ballots that were submitted. This is crucial since our data was not preprocessed. There could be undervotes, overvotes, defective, or spoiled ballots.</p> <p>The <code>get_candidates</code> method returns a unique list of candidates. The <code>head</code> method shows the top n ballots. In the first column, we see the ballot that was cast. In the second column, we see how many of that type of ballot were cast. </p> <pre><code># returns a list of unique candidates\nprint(minneapolis_profile.get_candidates())\n\n# returns the top n ballots\nminneapolis_profile.head(n=5)\n</code></pre> <pre><code>['JOHN LESLIE HARTWIG', 'ALICIA K. BENNETT', 'ABDUL M RAHAMAN \"THE ROCK\"', 'CAPTAIN JACK SPARROW', 'STEPHANIE WOODRUFF', 'JAMES EVERETT', 'JAMES \"JIMMY\" L. STROUD, JR.', 'DOUG MANN', 'CHRISTOPHER CLARK', 'TROY BENJEGERDES', 'JACKIE CHERRYHOMES', 'DON SAMUELS', 'KURTIS W. HANNA', 'overvote', 'MARK ANDREW', 'OLE SAVIOR', 'TONY LANE', 'JAYMIE KELLY', 'MIKE GOULD', 'CHRISTOPHER ROBIN ZIMMERMAN', 'GREGG A. IVERSON', 'DAN COHEN', 'CYD GORMAN', 'UWI', 'BILL KAHN', 'RAHN V. WORKCUFF', 'MERRILL ANDERSON', 'CAM WINTON', 'EDMUND BERNARD BRUYERE', 'BETSY HODGES', 'undervote', 'BOB FINE', 'JOHN CHARLES WILSON', 'JEFFREY ALAN WAGNER', 'JOSHUA REA', 'MARK V ANDERSON', 'NEAL BAXTER', 'BOB \"AGAIN\" CARNEY JR']\n</code></pre> Ballots Weight 0 (MARK ANDREW, undervote, undervote) 3864 1 (BETSY HODGES, MARK ANDREW, DON SAMUELS) 3309 2 (BETSY HODGES, DON SAMUELS, MARK ANDREW) 3031 3 (MARK ANDREW, BETSY HODGES, DON SAMUELS) 2502 4 (BETSY HODGES, undervote, undervote) 2212 <p>Woah, that's a little funky! There's a candidate called 'undervote','overvote', and 'UWI'. In this dataset, 'undervote' says that someone left a ranking blank. The 'overvote' candidate arises when someone lists two candidates in one ranking, and in our data set, we lose any knowledge of their actual preference. 'UWI' stands for unregistered write-in.</p> <p>It's really important to think carefully about how you want to handle cleaning up the ballots, as this depends entirely on the context of a given election. For now, let's assume that we want to get rid of the 'undervote', 'overvote', and 'UWI' candidates. The function <code>remove_noncands</code> will do this for us. If a ballot was \"A B undervote\", it would now be \"A B\". If a ballot was \"A UWI B\" it would now be \"A B\" as well. This might not be how you want to handle such things, but for now let's go with it. </p> <pre><code>minneapolis_profile = remove_noncands(minneapolis_profile, [\"undervote\", \"overvote\", \"UWI\"])\nprint(minneapolis_profile.get_candidates())\n</code></pre> <pre><code>['NEAL BAXTER', 'JAYMIE KELLY', 'MIKE GOULD', 'CHRISTOPHER ROBIN ZIMMERMAN', 'GREGG A. IVERSON', 'DAN COHEN', 'JOHN LESLIE HARTWIG', 'ALICIA K. BENNETT', 'CYD GORMAN', 'BILL KAHN', 'RAHN V. WORKCUFF', 'MERRILL ANDERSON', 'CAPTAIN JACK SPARROW', 'CAM WINTON', 'STEPHANIE WOODRUFF', 'EDMUND BERNARD BRUYERE', 'JAMES EVERETT', 'BETSY HODGES', 'JAMES \"JIMMY\" L. STROUD, JR.', 'DOUG MANN', 'CHRISTOPHER CLARK', 'TROY BENJEGERDES', 'JACKIE CHERRYHOMES', 'BOB FINE', 'JOHN CHARLES WILSON', 'DON SAMUELS', 'JEFFREY ALAN WAGNER', 'KURTIS W. HANNA', 'JOSHUA REA', 'MARK ANDREW', 'OLE SAVIOR', 'MARK V ANDERSON', 'ABDUL M RAHAMAN \"THE ROCK\"', 'TONY LANE', 'BOB \"AGAIN\" CARNEY JR']\n</code></pre> <p>Alright, things are looking a bit cleaner. Let's examine some of the ballots.</p> <pre><code># returns the top n ballots\nminneapolis_profile.head(n=5, percents = True)\n</code></pre> Ballots Weight Percent 0 (MARK ANDREW,) 3864 4.87% 1 (BETSY HODGES, MARK ANDREW, DON SAMUELS) 3309 4.17% 2 (BETSY HODGES, DON SAMUELS, MARK ANDREW) 3031 3.82% 3 (MARK ANDREW, BETSY HODGES, DON SAMUELS) 2502 3.15% 4 (BETSY HODGES,) 2212 2.79% <p>We can similarly print the bottom \\(n\\) ballots. Here we toggle the optional <code>percents</code> and <code>totals</code> arguments, which will show us the fraction of the total vote, as well as sum up the weights.</p> <pre><code># returns the bottom n ballots\nminneapolis_profile.tail(n=5, percents = False, totals = True)\n</code></pre> Ballots Weight 6916 (STEPHANIE WOODRUFF,) 1 6915 (DON SAMUELS, ABDUL M RAHAMAN \"THE ROCK\", MARK... 1 6914 (DON SAMUELS, ABDUL M RAHAMAN \"THE ROCK\", MIKE... 1 6913 (DON SAMUELS, ABDUL M RAHAMAN \"THE ROCK\", OLE ... 1 6912 (DON SAMUELS, ABDUL M RAHAMAN \"THE ROCK\", RAHN... 1 Totals 5 out of 79378 <p>There are a few other methods you can read about in the documentation, but now let's run an election!</p> <p>Just because we have a collection of ballots does not mean we have a winner. To convert a PreferenceProfile into a winner (or winners), we need to choose a method of election. The mayoral race was conducted as a single winner IRV election, which in <code>votekit</code> is equivalent to a STV election with one seat. The transfer method tells us what to do if someone has a surplus of votes over the winning quota (which by default is the Droop quota). </p> <pre><code>minn_election = STV(profile = minneapolis_profile, transfer = fractional_transfer, seats = 1)\n</code></pre> <pre><code># the run_election method prints a dataframe showing the order in which candidates are eliminated under STV\nminn_election.run_election()\n</code></pre> <pre><code>Current Round: 35\n\n\n\n\n\n                   Candidate     Status  Round\n                BETSY HODGES    Elected     35\n                 MARK ANDREW Eliminated     34\n                 DON SAMUELS Eliminated     33\n                  CAM WINTON Eliminated     32\n          JACKIE CHERRYHOMES Eliminated     31\n                    BOB FINE Eliminated     30\n                   DAN COHEN Eliminated     29\n          STEPHANIE WOODRUFF Eliminated     28\n             MARK V ANDERSON Eliminated     27\n                   DOUG MANN Eliminated     26\n                  OLE SAVIOR Eliminated     25\n               JAMES EVERETT Eliminated     24\n           ALICIA K. BENNETT Eliminated     23\n  ABDUL M RAHAMAN \"THE ROCK\" Eliminated     22\n        CAPTAIN JACK SPARROW Eliminated     21\n           CHRISTOPHER CLARK Eliminated     20\n                   TONY LANE Eliminated     19\n                JAYMIE KELLY Eliminated     18\n                  MIKE GOULD Eliminated     17\n             KURTIS W. HANNA Eliminated     16\n CHRISTOPHER ROBIN ZIMMERMAN Eliminated     15\n         JEFFREY ALAN WAGNER Eliminated     14\n                 NEAL BAXTER Eliminated     13\n            TROY BENJEGERDES Eliminated     12\n            GREGG A. IVERSON Eliminated     11\n            MERRILL ANDERSON Eliminated     10\n                  JOSHUA REA Eliminated      9\n                   BILL KAHN Eliminated      8\n         JOHN LESLIE HARTWIG Eliminated      7\n      EDMUND BERNARD BRUYERE Eliminated      6\nJAMES \"JIMMY\" L. STROUD, JR. Eliminated      5\n            RAHN V. WORKCUFF Eliminated      4\n       BOB \"AGAIN\" CARNEY JR Eliminated      3\n                  CYD GORMAN Eliminated      2\n         JOHN CHARLES WILSON Eliminated      1\n</code></pre> <p>And there you go! You've created a PreferenceProfile from real election data, done some cleaning, and then conducted an STV election. You can look at the offical results and confirm that <code>votekit</code> elected the same candidate as in the real 2013 election.</p>"},{"location":"some_plotting_options/","title":"Some Plotting Options: Summary Statistics, Pairwise Comparison Graphs, and MDS Plots.","text":"<p>In this tutorial we will explore various plotting options included in <code>votekit</code>. To do so, we will not use real election data, but rather some generated preference profiles. <code>votekit</code> allows us to choose many different models of ballot generator.</p> <p>For simplicity, let's start with the Impartial Culture model, which assumes that when there are \\(m\\) candidates, a voter casts a ballot by choosing uniformly at random from the \\(m!\\) total linear orderings of the candidates.</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.plots import plot_summary_stats, plot_MDS, compute_MDS\nfrom votekit.graphs import PairwiseComparisonGraph\nfrom votekit.metrics import earth_mover_dist, lp_dist\nfrom votekit.pref_interval import PreferenceInterval\nfrom functools import partial\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code># the list of candidates\ncandidates = [\"A\", \"B\", \"C\"]\n\n# initializing the ballot generator\nic = bg.ImpartialCulture(candidates=candidates)\n\n# generate 5 ballots under the IC model\nnumber_of_ballots = 5\nprofile = ic.generate_profile(number_of_ballots)\n\n# since this is a small preference profile, we can print the entire thing\nprint(profile)\n</code></pre> <pre><code>  Ballots Weight\n(A, C, B)      2\n(C, A, B)      1\n(C, B, A)      1\n(B, C, A)      1\n</code></pre> <p><code>votekit</code> comes with some basic summary statistics to help you analyze a profile. We can plot the number of first place votes each candidate received, the number of mentions they receive (i.e. the total number of times they appeared on a ballot), and a Borda count, which assigns \\(n-1\\) points to the first place winner of a ballot, \\(n-2\\) to the second place, ..., and 0 to the last place winner of a ballot.</p> <pre><code>fig = plot_summary_stats(profile, \"first place votes\", multi_color = False, title = \"First Place Votes\")\nfig = plot_summary_stats(profile, \"borda\", multi_color = False, title = \"Borda Scores\")\nfig = plot_summary_stats(profile, \"mentions\", multi_color = True, title = \"Mentions\")\n</code></pre> <p></p> <p></p> <p></p> <p>Check for understanding: In the IC model we are using, why is the number of mentions uniform?</p>"},{"location":"some_plotting_options/#graphs","title":"Graphs!","text":"<p>There are two kinds of graphs (networks) that <code>votekit</code> generates, a pairwise comparison graph, and a ballot graph. The former has vertices=candidates, and an edge going from A to B if A is preferred to B more often in the given preference profile. The edge is given weight equal to the number of times A is preferred to B minus the number of times B is preferred to A. We'll discuss ballot graphs in a later tutorial.</p>"},{"location":"some_plotting_options/#pairwisecomparisongraph","title":"<code>PairwiseComparisonGraph</code>","text":"<p><code>PairwiseComparisonGraph</code> takes in a <code>PreferenceProfile</code>. There is an optional <code>ballot_length</code> parameter that determines the length of the ballot and then the <code>PairwiseComparisonGraph</code> graph will randomly fill in any ballots that are too short. Since we are using IC ballots which have a full linear ranking, we don't need to worry about that.</p> <pre><code>pwc_graph = PairwiseComparisonGraph(profile)\npwc_graph.draw()\n</code></pre> <p></p> <p>Check for understanding: are the edge weights what you expect given your <code>PreferenceProfile</code>?</p> <p><code>PairwiseComparisonGraph</code> has methods for computing dominating tiers and the existence of a condorcet winner. A dominating tier is a group of candidates that beats every candidate not in the set in a head-to-head comparison. A condorcet winner is a candidate who wins every head-to-head contest with every other candidate.</p> <pre><code>print(pwc_graph.dominating_tiers())\nprint()\nprint(pwc_graph.has_condorcet_winner())\n</code></pre> <pre><code>[{'C'}, {'A'}, {'B'}]\n\nTrue\n</code></pre>"},{"location":"some_plotting_options/#mds-plots","title":"MDS Plots","text":"<p>One of the cool features of <code>votekit</code> is that we can create MDS plots, using different notions of distance between preference profiles. An MDS plot, in short, is a 2D representation of high dimensional data that attempts to minimize the distortion of the data. <code>votekit</code> comes with two distance metrics, the earthmover distance and the \\(L_p\\) distance.</p> <p>Let's explore how an MDS plot can show us the difference between different types of ballot generating models. We will explain what these generating models are doing in a different tutorial.</p> <pre><code>number_of_ballots = 1000\n\n\ncandidates = [\"W1\", \"W2\", \"C1\", \"C2\"]\nslate_to_candidate = {\"W\": [\"W1\", \"W2\"], \"C\": [\"C1\", \"C2\"]}\ncohesion_parameters = {\"W\":{\"W\": .7, \"C\":.3},\n                       \"C\":{ \"C\": .6, \"W\":.4}}\npref_intervals_by_bloc = {\n    \"W\": {\"W\": PreferenceInterval({\"W1\": 0.4, \"W2\": 0.3}), \n          \"C\": PreferenceInterval({\"C1\": 0.2, \"C2\": 0.1})},\n    \"C\": {\"W\": PreferenceInterval({\"W1\": 0.2, \"W2\": 0.2}), \n          \"C\": PreferenceInterval({\"C1\": 0.3, \"C2\": 0.3})}\n}\nbloc_voter_prop = {\"W\": 0.7, \"C\": 0.3}\n\nic = bg.ImpartialCulture(candidates=candidates)\n\npl = bg.name_PlackettLuce(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, candidates=candidates, \n                     cohesion_parameters=cohesion_parameters)\n\nbt = bg.name_BradleyTerry(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, candidates=candidates,\n                     cohesion_parameters=cohesion_parameters)\n\nac = bg.AlternatingCrossover(pref_intervals_by_bloc=pref_intervals_by_bloc,\n                             bloc_voter_prop=bloc_voter_prop, candidates=candidates,\n                             slate_to_candidates=slate_to_candidate, cohesion_parameters=cohesion_parameters)\n</code></pre> <p><code>compute_MDS</code> takes in a <code>data</code> parameter, which is a dictionary whose keys are labels and whose values are a particular list of <code>PreferenceProfiles</code>, and a <code>distance</code> parameter that sets the metric between preference profiles. Since computing these coordinates is the most time intensive part of the process, it has been decoupled from <code>plot_mds</code> which simply takes the output of <code>compute_MDS</code> and plots the data.</p> <p><code>comput_MDS</code> also comes with an optional <code>random_seed</code> parameter that allows for MDS replication.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nmds_coords = compute_MDS(data = {'IC': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'PL': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'BT': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'AC': [ac.generate_profile(number_of_ballots) for i in range(10)]\n                       }, distance = earth_mover_dist)\n\nplot = plot_MDS(mds_coords, legend=True, title=True)\nplt.show()\n</code></pre> <p></p> <p>Let's try a different metric.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nmds_coords = compute_MDS(data = {'IC': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'PL': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'BT': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'AC': [ac.generate_profile(number_of_ballots) for i in range(10)]\n                       }, distance = lp_dist)\n\nplot = plot_MDS(mds_coords, legend=False, title=False)\nplt.show()\n</code></pre> <p></p> <p>By default, the \\(L_p\\) distance function uses \\(p=1\\). If you want to change that, we need the <code>partial</code> function from the <code>functools</code> module.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nmds_coords = compute_MDS(data = {'IC': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'PL': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'BT': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'AC': [ac.generate_profile(number_of_ballots) for i in range(10)]\n                       }, distance = partial(lp_dist, p_value=2))\n\nplot = plot_MDS(mds_coords, legend=False, title=False)\nplt.show()\n</code></pre> <p></p> <p>Finally, to use the \\(L_\\infty\\) distance, use the keyword <code>inf</code>.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nmds_coords = compute_MDS(data = {'IC': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'PL': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'BT': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'AC': [ac.generate_profile(number_of_ballots) for i in range(10)]\n                       }, distance = partial(lp_dist, p_value=\"inf\"))\n\nplot = plot_MDS(mds_coords, legend=False, title=False)\nplt.show()\n</code></pre> <p></p> <p>We can also add optional plotting parameters as follows. These get passed to matplotlib <code>scatter</code>.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nmds_coords = compute_MDS(data = {'IC': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'PL': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'BT': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'AC': [ac.generate_profile(number_of_ballots) for i in range(10)]\n                       }, distance = earth_mover_dist)\n\n\nplot_kwarg_dict = {\"IC\": {\"marker\": \"v\", \"s\": 100},\n                   \"PL\": {\"marker\": \"s\", \"s\": 50},\n                   \"BT\": {\"marker\": \"x\", \"s\": 10},\n                   \"AC\": {\"marker\": \"d\", \"s\": 1}}\nplot = plot_MDS(mds_coords, plot_kwarg_dict= plot_kwarg_dict, legend=True, title=True)\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"}]}